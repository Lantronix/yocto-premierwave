diff -crB wide-dhcpv6-20080615/addrconf.c wide-dhcpv6-20080615-ltrx/addrconf.c
*** wide-dhcpv6-20080615/addrconf.c	2015-04-22 16:16:38.352482520 +0530
--- wide-dhcpv6-20080615-ltrx/addrconf.c	2015-04-22 16:17:46.304966640 +0530
***************
*** 122,128 ****
  	if (addr->vltime != DHCP6_DURATION_INFINITE &&
  	    (addr->pltime == DHCP6_DURATION_INFINITE ||
  	    addr->pltime > addr->vltime)) {
! 		dprintf(LOG_INFO, FNAME, "invalid address %s: "
  		    "pltime (%lu) is larger than vltime (%lu)",
  		    in6addr2str(&addr->addr, 0),
  		    addr->pltime, addr->vltime);
--- 122,128 ----
  	if (addr->vltime != DHCP6_DURATION_INFINITE &&
  	    (addr->pltime == DHCP6_DURATION_INFINITE ||
  	    addr->pltime > addr->vltime)) {
! 		debug_printf(LOG_INFO, FNAME, "invalid address %s: "
  		    "pltime (%lu) is larger than vltime (%lu)",
  		    in6addr2str(&addr->addr, 0),
  		    addr->pltime, addr->vltime);
***************
*** 131,137 ****
  
  	if (iac_na == NULL) {
  		if ((iac_na = malloc(sizeof(*iac_na))) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME, "memory allocation failed");
  			return (-1);
  		}
  		memset(iac_na, 0, sizeof(*iac_na));
--- 131,137 ----
  
  	if (iac_na == NULL) {
  		if ((iac_na = malloc(sizeof(*iac_na))) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME, "memory allocation failed");
  			return (-1);
  		}
  		memset(iac_na, 0, sizeof(*iac_na));
***************
*** 152,158 ****
  	/* search for the given address, and make a new one if it fails */
  	if ((sa = find_addr(&iac_na->statefuladdr_head, addr)) == NULL) {
  		if ((sa = malloc(sizeof(*sa))) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME, "memory allocation failed");
  			return (-1);
  		}
  		memset(sa, 0, sizeof(*sa));
--- 152,158 ----
  	/* search for the given address, and make a new one if it fails */
  	if ((sa = find_addr(&iac_na->statefuladdr_head, addr)) == NULL) {
  		if ((sa = malloc(sizeof(*sa))) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME, "memory allocation failed");
  			return (-1);
  		}
  		memset(sa, 0, sizeof(*sa));
***************
*** 169,175 ****
  	sa->addr.pltime = addr->pltime;
  	sa->addr.vltime = addr->vltime;
  	sa->dhcpif = dhcpifp;
! 	dprintf(LOG_DEBUG, FNAME, "%s an address %s pltime=%lu, vltime=%lu",
  	    sacreate ? "create" : "update",
  	    in6addr2str(&addr->addr, 0), addr->pltime, addr->vltime);
  
--- 169,175 ----
  	sa->addr.pltime = addr->pltime;
  	sa->addr.vltime = addr->vltime;
  	sa->dhcpif = dhcpifp;
! 	debug_printf(LOG_DEBUG, FNAME, "%s an address %s pltime=%lu, vltime=%lu",
  	    sacreate ? "create" : "update",
  	    in6addr2str(&addr->addr, 0), addr->pltime, addr->vltime);
  
***************
*** 194,200 ****
  		if (sa->timer == NULL) {
  			sa->timer = dhcp6_add_timer(addr_timo, sa);
  			if (sa->timer == NULL) {
! 				dprintf(LOG_NOTICE, FNAME,
  				    "failed to add stateful addr timer");
  				remove_addr(sa); /* XXX */
  				return (-1);
--- 194,200 ----
  		if (sa->timer == NULL) {
  			sa->timer = dhcp6_add_timer(addr_timo, sa);
  			if (sa->timer == NULL) {
! 				debug_printf(LOG_NOTICE, FNAME,
  				    "failed to add stateful addr timer");
  				remove_addr(sa); /* XXX */
  				return (-1);
***************
*** 233,239 ****
  {
  	int ret;
  
! 	dprintf(LOG_DEBUG, FNAME, "remove an address %s",
  	    in6addr2str(&sa->addr.addr, 0));
  
  	if (sa->timer)
--- 233,239 ----
  {
  	int ret;
  
! 	debug_printf(LOG_DEBUG, FNAME, "remove an address %s",
  	    in6addr2str(&sa->addr.addr, 0));
  
  	if (sa->timer)
***************
*** 343,349 ****
  	struct dhcp6_list *ial;
  
  	if (evd->type != DHCP6_EVDATA_IANA) {
! 		dprintf(LOG_ERR, FNAME, "assumption failure");
  		exit(1);
  	}
  
--- 343,349 ----
  	struct dhcp6_list *ial;
  
  	if (evd->type != DHCP6_EVDATA_IANA) {
! 		debug_printf(LOG_ERR, FNAME, "assumption failure");
  		exit(1);
  	}
  
***************
*** 362,368 ****
  	struct ia *ia;
  	void (*callback)__P((struct ia *));
  
! 	dprintf(LOG_DEBUG, FNAME, "address timeout for %s",
  	    in6addr2str(&sa->addr.addr, 0));
  
  	ia = sa->ctl->iacna_ia;
--- 362,368 ----
  	struct ia *ia;
  	void (*callback)__P((struct ia *));
  
! 	debug_printf(LOG_DEBUG, FNAME, "address timeout for %s",
  	    in6addr2str(&sa->addr.addr, 0));
  
  	ia = sa->ctl->iacna_ia;
diff -crB wide-dhcpv6-20080615/cftoken.c wide-dhcpv6-20080615-ltrx/cftoken.c
*** wide-dhcpv6-20080615/cftoken.c	2007-03-21 15:23:10.000000000 +0530
--- wide-dhcpv6-20080615-ltrx/cftoken.c	2015-04-22 16:17:46.344966922 +0530
***************
*** 2475,2484 ****
  	int l;
  {
  	if (w) {
! 		dprintf(LOG_DEBUG, FNAME,
  		    "<%d>%s [%s] (%d)", yy_start, w, t, l);
  	} else {
! 		dprintf(LOG_DEBUG, FNAME,
  		    "<%d>[%s] (%d)", yy_start, t, l);
  	}
  }
--- 2475,2484 ----
  	int l;
  {
  	if (w) {
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "<%d>%s [%s] (%d)", yy_start, w, t, l);
  	} else {
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "<%d>[%s] (%d)", yy_start, t, l);
  	}
  }
***************
*** 2494,2500 ****
  	if (bp < ep)
  		bp += vsnprintf(bp, ep - bp, s, ap);
  
! 	dprintf(level, FNAME, ebuf);
  }
  
  void
--- 2494,2500 ----
  	if (bp < ep)
  		bp += vsnprintf(bp, ep - bp, s, ap);
  
! 	debug_printf(level, FNAME, ebuf);
  }
  
  void
***************
*** 2532,2538 ****
  	FILE *fp;
  
  	if (incstackp >= MAX_INCLUDE_DEPTH) {
! 		dprintf(LOG_ERR, FNAME, "cfparse: includes nested too deeply");
  		return (-1);
  	}
  	incstack[incstackp].path = configfilename;
--- 2532,2538 ----
  	FILE *fp;
  
  	if (incstackp >= MAX_INCLUDE_DEPTH) {
! 		debug_printf(LOG_ERR, FNAME, "cfparse: includes nested too deeply");
  		return (-1);
  	}
  	incstack[incstackp].path = configfilename;
***************
*** 2541,2547 ****
  
  	fp = fopen(path, "r");
  	if (fp == NULL) {
! 		dprintf(LOG_ERR, FNAME, "cfparse: fopen(%s): %s",
  			path, strerror(errno));
  		if (errno == ENOENT)
  			return (0);
--- 2541,2547 ----
  
  	fp = fopen(path, "r");
  	if (fp == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "cfparse: fopen(%s): %s",
  			path, strerror(errno));
  		if (errno == ENOENT)
  			return (0);
***************
*** 2563,2569 ****
  {
  	configfilename = conf;
  	if ((yyin = fopen(configfilename, "r")) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "cfparse: fopen(%s): %s",
  			configfilename, strerror(errno));
  		if (errno == ENOENT)
  			return (0);
--- 2563,2569 ----
  {
  	configfilename = conf;
  	if ((yyin = fopen(configfilename, "r")) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "cfparse: fopen(%s): %s",
  			configfilename, strerror(errno));
  		if (errno == ENOENT)
  			return (0);
diff -crB wide-dhcpv6-20080615/cftoken.l wide-dhcpv6-20080615-ltrx/cftoken.l
*** wide-dhcpv6-20080615/cftoken.l	2015-04-22 16:16:38.352482520 +0530
--- wide-dhcpv6-20080615-ltrx/cftoken.l	2015-04-22 16:17:46.284966499 +0530
***************
*** 342,351 ****
  	int l;
  {
  	if (w) {
! 		dprintf(LOG_DEBUG, FNAME,
  		    "<%d>%s [%s] (%d)", yy_start, w, t, l);
  	} else {
! 		dprintf(LOG_DEBUG, FNAME,
  		    "<%d>[%s] (%d)", yy_start, t, l);
  	}
  }
--- 342,351 ----
  	int l;
  {
  	if (w) {
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "<%d>%s [%s] (%d)", yy_start, w, t, l);
  	} else {
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "<%d>[%s] (%d)", yy_start, t, l);
  	}
  }
***************
*** 361,367 ****
  	if (bp < ep)
  		bp += vsnprintf(bp, ep - bp, s, ap);
  
! 	dprintf(level, FNAME, ebuf);
  }
  
  void
--- 361,367 ----
  	if (bp < ep)
  		bp += vsnprintf(bp, ep - bp, s, ap);
  
! 	debug_printf(level, FNAME, ebuf);
  }
  
  void
***************
*** 399,405 ****
  	FILE *fp;
  
  	if (incstackp >= MAX_INCLUDE_DEPTH) {
! 		dprintf(LOG_ERR, FNAME, "cfparse: includes nested too deeply");
  		return (-1);
  	}
  	incstack[incstackp].path = configfilename;
--- 399,405 ----
  	FILE *fp;
  
  	if (incstackp >= MAX_INCLUDE_DEPTH) {
! 		debug_printf(LOG_ERR, FNAME, "cfparse: includes nested too deeply");
  		return (-1);
  	}
  	incstack[incstackp].path = configfilename;
***************
*** 408,414 ****
  
  	fp = fopen(path, "r");
  	if (fp == NULL) {
! 		dprintf(LOG_ERR, FNAME, "cfparse: fopen(%s): %s",
  			path, strerror(errno));
  		if (errno == ENOENT)
  			return (0);
--- 408,414 ----
  
  	fp = fopen(path, "r");
  	if (fp == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "cfparse: fopen(%s): %s",
  			path, strerror(errno));
  		if (errno == ENOENT)
  			return (0);
***************
*** 430,436 ****
  {
  	configfilename = conf;
  	if ((yyin = fopen(configfilename, "r")) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "cfparse: fopen(%s): %s",
  			configfilename, strerror(errno));
  		if (errno == ENOENT)
  			return (0);
--- 430,436 ----
  {
  	configfilename = conf;
  	if ((yyin = fopen(configfilename, "r")) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "cfparse: fopen(%s): %s",
  			configfilename, strerror(errno));
  		if (errno == ENOENT)
  			return (0);
diff -crB wide-dhcpv6-20080615/common.c wide-dhcpv6-20080615-ltrx/common.c
*** wide-dhcpv6-20080615/common.c	2015-04-22 16:16:38.352482520 +0530
--- wide-dhcpv6-20080615-ltrx/common.c	2015-04-22 16:17:46.296966581 +0530
***************
*** 265,271 ****
  	struct dhcp6_listval *lv = NULL;
  
  	if ((lv = malloc(sizeof(*lv))) == NULL) {
! 		dprintf(LOG_ERR, FNAME,
  		    "failed to allocate memory for list entry");
  		goto fail;
  	}
--- 265,271 ----
  	struct dhcp6_listval *lv = NULL;
  
  	if ((lv = malloc(sizeof(*lv))) == NULL) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "failed to allocate memory for list entry");
  		goto fail;
  	}
***************
*** 298,304 ****
  			goto fail;
  		break;
  	default:
! 		dprintf(LOG_ERR, FNAME,
  		    "unexpected list value type (%d)", type);
  		goto fail;
  	}
--- 298,304 ----
  			goto fail;
  		break;
  	default:
! 		debug_printf(LOG_ERR, FNAME,
  		    "unexpected list value type (%d)", type);
  		goto fail;
  	}
***************
*** 361,367 ****
  	void *val;
  
  	if (optlen % sizeof(struct in6_addr) || optlen == 0) {
! 		dprintf(LOG_INFO, FNAME,
  		    "malformed DHCP option: type %d, len %d", type, optlen);
  		return -1;
  	}
--- 361,367 ----
  	void *val;
  
  	if (optlen % sizeof(struct in6_addr) || optlen == 0) {
! 		debug_printf(LOG_INFO, FNAME,
  		    "malformed DHCP option: type %d, len %d", type, optlen);
  		return -1;
  	}
***************
*** 371,384 ****
  		memcpy(&valaddr, val, sizeof(valaddr));
  		if (dhcp6_find_listval(list,
  		    DHCP6_LISTVAL_ADDR6, &valaddr, 0)) {
! 			dprintf(LOG_INFO, FNAME, "duplicated %s address (%s)",
  			    dhcp6optstr(type), in6addr2str(&valaddr, 0));
  			continue;
  		}
  
  		if (dhcp6_add_listval(list, DHCP6_LISTVAL_ADDR6,
  		    &valaddr, NULL) == NULL) {
! 			dprintf(LOG_ERR, FNAME,
  			    "failed to copy %s address", dhcp6optstr(type));
  			return -1;
  		}
--- 371,384 ----
  		memcpy(&valaddr, val, sizeof(valaddr));
  		if (dhcp6_find_listval(list,
  		    DHCP6_LISTVAL_ADDR6, &valaddr, 0)) {
! 			debug_printf(LOG_INFO, FNAME, "duplicated %s address (%s)",
  			    dhcp6optstr(type), in6addr2str(&valaddr, 0));
  			continue;
  		}
  
  		if (dhcp6_add_listval(list, DHCP6_LISTVAL_ADDR6,
  		    &valaddr, NULL) == NULL) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "failed to copy %s address", dhcp6optstr(type));
  			return -1;
  		}
***************
*** 405,411 ****
  	tmpbuf = NULL;
  	optlen = dhcp6_count_list(list) * sizeof(struct in6_addr);
  	if ((tmpbuf = malloc(optlen)) == NULL) {
! 		dprintf(LOG_ERR, FNAME,
  		    "memory allocation failed for %s options",
  		    dhcp6optstr(type));
  		return -1;
--- 405,411 ----
  	tmpbuf = NULL;
  	optlen = dhcp6_count_list(list) * sizeof(struct in6_addr);
  	if ((tmpbuf = malloc(optlen)) == NULL) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "memory allocation failed for %s options",
  		    dhcp6optstr(type));
  		return -1;
***************
*** 438,447 ****
  
  		if (dnsdecode((u_char **)(void *)&val,
  		    (u_char *)(cp + optlen), name, sizeof(name)) == NULL) {
! 			dprintf(LOG_INFO, FNAME, "failed to "
  			    "decode a %s domain name",
  			    dhcp6optstr(type));
! 			dprintf(LOG_INFO, FNAME,
  			    "malformed DHCP option: type %d, len %d",
  			     type, optlen);
  			return -1;
--- 438,447 ----
  
  		if (dnsdecode((u_char **)(void *)&val,
  		    (u_char *)(cp + optlen), name, sizeof(name)) == NULL) {
! 			debug_printf(LOG_INFO, FNAME, "failed to "
  			    "decode a %s domain name",
  			    dhcp6optstr(type));
! 			debug_printf(LOG_INFO, FNAME,
  			    "malformed DHCP option: type %d, len %d",
  			     type, optlen);
  			return -1;
***************
*** 452,458 ****
  
  		if (dhcp6_add_listval(list,
  		    DHCP6_LISTVAL_VBUF, &vb, NULL) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "failed to "
  			    "copy a %s domain name", dhcp6optstr(type));
  			return -1;
  		}
--- 452,458 ----
  
  		if (dhcp6_add_listval(list,
  		    DHCP6_LISTVAL_VBUF, &vb, NULL) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "failed to "
  			    "copy a %s domain name", dhcp6optstr(type));
  			return -1;
  		}
***************
*** 485,491 ****
  
  	tmpbuf = NULL;
  	if ((tmpbuf = malloc(optlen)) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "memory allocation failed for "
  		    "%s domain options", dhcp6optstr(type));
  		return -1;
  	}
--- 485,491 ----
  
  	tmpbuf = NULL;
  	if ((tmpbuf = malloc(optlen)) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "memory allocation failed for "
  		    "%s domain options", dhcp6optstr(type));
  		return -1;
  	}
***************
*** 497,510 ****
  		nlen = dnsencode((const char *)d->val_vbuf.dv_buf,
  		    name, sizeof (name));
  		if (nlen < 0) {
! 			dprintf(LOG_ERR, FNAME,
  			    "failed to encode a %s domain name",
  			    dhcp6optstr(type));
  			free(tmpbuf);
  			return -1;
  		}
  		if (ep - cp < nlen) {
! 			dprintf(LOG_ERR, FNAME,
  			    "buffer length for %s domain name is too short",
  			    dhcp6optstr(type));
  			free(tmpbuf);
--- 497,510 ----
  		nlen = dnsencode((const char *)d->val_vbuf.dv_buf,
  		    name, sizeof (name));
  		if (nlen < 0) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "failed to encode a %s domain name",
  			    dhcp6optstr(type));
  			free(tmpbuf);
  			return -1;
  		}
  		if (ep - cp < nlen) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "buffer length for %s domain name is too short",
  			    dhcp6optstr(type));
  			free(tmpbuf);
***************
*** 530,536 ****
  	struct dhcp6_event *ev;
  
  	if ((ev = malloc(sizeof(*ev))) == NULL) {
! 		dprintf(LOG_ERR, FNAME,
  		    "failed to allocate memory for an event");
  		return (NULL);
  	}
--- 530,536 ----
  	struct dhcp6_event *ev;
  
  	if ((ev = malloc(sizeof(*ev))) == NULL) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "failed to allocate memory for an event");
  		return (NULL);
  	}
***************
*** 548,554 ****
  {
  	struct dhcp6_serverinfo *sp, *sp_next;
  
! 	dprintf(LOG_DEBUG, FNAME, "removing an event on %s, state=%s",
  	    ev->ifp->ifname, dhcp6_event_statestr(ev));
  
  	dhcp6_remove_evdata(ev);
--- 548,554 ----
  {
  	struct dhcp6_serverinfo *sp, *sp_next;
  
! 	debug_printf(LOG_DEBUG, FNAME, "removing an event on %s, state=%s",
  	    ev->ifp->ifname, dhcp6_event_statestr(ev));
  
  	dhcp6_remove_evdata(ev);
***************
*** 562,568 ****
  	for (sp = ev->servers; sp; sp = sp_next) {
  		sp_next = sp->next;
  
! 		dprintf(LOG_DEBUG, FNAME, "removing server (ID: %s)",
  		    duidstr(&sp->optinfo.serverID));
  		dhcp6_clear_options(&sp->optinfo);
  		if (sp->authparam != NULL)
--- 562,568 ----
  	for (sp = ev->servers; sp; sp = sp_next) {
  		sp_next = sp->next;
  
! 		debug_printf(LOG_DEBUG, FNAME, "removing server (ID: %s)",
  		    duidstr(&sp->optinfo.serverID));
  		dhcp6_clear_options(&sp->optinfo);
  		if (sp->authparam != NULL)
***************
*** 649,662 ****
  	char bufcurrent[] = "ffff ffff ffff ffff";
  
  	if (method != DHCP6_AUTHRDM_MONOCOUNTER) {
! 		dprintf(LOG_ERR, FNAME, "unsupported replay detection "
  		    "method (%d)", method);
  		return (-1);
  	}
  
  	(void)sprint_uint64(bufprev, sizeof(bufprev), prev);
  	(void)sprint_uint64(bufcurrent, sizeof(bufcurrent), current);
! 	dprintf(LOG_DEBUG, FNAME, "previous: %s, current: %s",
  	    bufprev, bufcurrent);
  
  	prev = ntohq(prev);
--- 649,662 ----
  	char bufcurrent[] = "ffff ffff ffff ffff";
  
  	if (method != DHCP6_AUTHRDM_MONOCOUNTER) {
! 		debug_printf(LOG_ERR, FNAME, "unsupported replay detection "
  		    "method (%d)", method);
  		return (-1);
  	}
  
  	(void)sprint_uint64(bufprev, sizeof(bufprev), prev);
  	(void)sprint_uint64(bufcurrent, sizeof(bufcurrent), current);
! 	debug_printf(LOG_DEBUG, FNAME, "previous: %s, current: %s",
  	    bufprev, bufcurrent);
  
  	prev = ntohq(prev);
***************
*** 667,673 ****
  	 * whether the serial number is increasing or not.
  	 */
          if (prev == (current ^ 0x8000000000000000ULL)) {
! 		dprintf(LOG_INFO, FNAME, "detected a singular point");
  		return (1);
  	}
  
--- 667,673 ----
  	 * whether the serial number is increasing or not.
  	 */
          if (prev == (current ^ 0x8000000000000000ULL)) {
! 		debug_printf(LOG_INFO, FNAME, "detected a singular point");
  		return (1);
  	}
  
***************
*** 688,694 ****
  	int error = -1;
  
  	if (getifaddrs(&ifap) != 0) {
! 		dprintf(LOG_WARNING, FNAME,
  			"getifaddrs failed: %s", strerror(errno));
  		return (-1);
  	}
--- 688,694 ----
  	int error = -1;
  
  	if (getifaddrs(&ifap) != 0) {
! 		debug_printf(LOG_WARNING, FNAME,
  			"getifaddrs failed: %s", strerror(errno));
  		return (-1);
  	}
***************
*** 765,771 ****
  	int retval = -1;
  
  	if (getifaddrs(&ifap) != 0) {
! 		dprintf(LOG_WARNING, FNAME,
  			"getifaddrs failed: %s", strerror(errno));
  		return (-1);
  	}
--- 765,771 ----
  	int retval = -1;
  
  	if (getifaddrs(&ifap) != 0) {
! 		debug_printf(LOG_WARNING, FNAME,
  			"getifaddrs failed: %s", strerror(errno));
  		return (-1);
  	}
***************
*** 781,787 ****
  
  	if (ifa != NULL) {
  		if ((ifid = if_nametoindex(ifa->ifa_name)) == 0) {
! 			dprintf(LOG_ERR, FNAME,
  			    "if_nametoindex failed for %s", ifa->ifa_name);
  			goto end;
  		}
--- 781,787 ----
  
  	if (ifa != NULL) {
  		if ((ifid = if_nametoindex(ifa->ifa_name)) == 0) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "if_nametoindex failed for %s", ifa->ifa_name);
  			goto end;
  		}
***************
*** 999,1018 ****
  	char tmpbuf[256];	/* DUID should be no more than 256 bytes */
  
  	if ((fp = fopen(idfile, "r")) == NULL && errno != ENOENT)
! 		dprintf(LOG_NOTICE, FNAME, "failed to open DUID file: %s",
  		    idfile);
  
  	if (fp) {
  		/* decode length */
  		if (fread(&len, sizeof(len), 1, fp) != 1) {
! 			dprintf(LOG_ERR, FNAME, "DUID file corrupted");
  			goto fail;
  		}
  	} else {
  		int l;
  
  		if ((l = gethwid(tmpbuf, sizeof(tmpbuf), NULL, &hwtype)) < 0) {
! 			dprintf(LOG_INFO, FNAME,
  			    "failed to get a hardware address");
  			goto fail;
  		}
--- 999,1018 ----
  	char tmpbuf[256];	/* DUID should be no more than 256 bytes */
  
  	if ((fp = fopen(idfile, "r")) == NULL && errno != ENOENT)
! 		debug_printf(LOG_NOTICE, FNAME, "failed to open DUID file: %s",
  		    idfile);
  
  	if (fp) {
  		/* decode length */
  		if (fread(&len, sizeof(len), 1, fp) != 1) {
! 			debug_printf(LOG_ERR, FNAME, "DUID file corrupted");
  			goto fail;
  		}
  	} else {
  		int l;
  
  		if ((l = gethwid(tmpbuf, sizeof(tmpbuf), NULL, &hwtype)) < 0) {
! 			debug_printf(LOG_INFO, FNAME,
  			    "failed to get a hardware address");
  			goto fail;
  		}
***************
*** 1022,1039 ****
  	memset(duid, 0, sizeof(*duid));
  	duid->duid_len = len;
  	if ((duid->duid_id = (char *)malloc(len)) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "failed to allocate memory");
  		goto fail;
  	}
  
  	/* copy (and fill) the ID */
  	if (fp) {
  		if (fread(duid->duid_id, len, 1, fp) != 1) {
! 			dprintf(LOG_ERR, FNAME, "DUID file corrupted");
  			goto fail;
  		}
  
! 		dprintf(LOG_DEBUG, FNAME,
  		    "extracted an existing DUID from %s: %s",
  		    idfile, duidstr(duid));
  	} else {
--- 1022,1039 ----
  	memset(duid, 0, sizeof(*duid));
  	duid->duid_len = len;
  	if ((duid->duid_id = (char *)malloc(len)) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "failed to allocate memory");
  		goto fail;
  	}
  
  	/* copy (and fill) the ID */
  	if (fp) {
  		if (fread(duid->duid_id, len, 1, fp) != 1) {
! 			debug_printf(LOG_ERR, FNAME, "DUID file corrupted");
  			goto fail;
  		}
  
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "extracted an existing DUID from %s: %s",
  		    idfile, duidstr(duid));
  	} else {
***************
*** 1047,1073 ****
  		dp->dh6_duid1_time = htonl((u_long)(t64 & 0xffffffff));
  		memcpy((void *)(dp + 1), tmpbuf, (len - sizeof(*dp)));
  
! 		dprintf(LOG_DEBUG, FNAME, "generated a new DUID: %s",
  		    duidstr(duid));
  	}
  
  	/* save the (new) ID to the file for next time */
  	if (!fp) {
  		if ((fp = fopen(idfile, "w+")) == NULL) {
! 			dprintf(LOG_ERR, FNAME,
  			    "failed to open DUID file for save");
  			goto fail;
  		}
  		if ((fwrite(&len, sizeof(len), 1, fp)) != 1) {
! 			dprintf(LOG_ERR, FNAME, "failed to save DUID");
  			goto fail;
  		}
  		if ((fwrite(duid->duid_id, len, 1, fp)) != 1) {
! 			dprintf(LOG_ERR, FNAME, "failed to save DUID");
  			goto fail;
  		}
  
! 		dprintf(LOG_DEBUG, FNAME, "saved generated DUID to %s",
  		    idfile);
  	}
  
--- 1047,1073 ----
  		dp->dh6_duid1_time = htonl((u_long)(t64 & 0xffffffff));
  		memcpy((void *)(dp + 1), tmpbuf, (len - sizeof(*dp)));
  
! 		debug_printf(LOG_DEBUG, FNAME, "generated a new DUID: %s",
  		    duidstr(duid));
  	}
  
  	/* save the (new) ID to the file for next time */
  	if (!fp) {
  		if ((fp = fopen(idfile, "w+")) == NULL) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "failed to open DUID file for save");
  			goto fail;
  		}
  		if ((fwrite(&len, sizeof(len), 1, fp)) != 1) {
! 			debug_printf(LOG_ERR, FNAME, "failed to save DUID");
  			goto fail;
  		}
  		if ((fwrite(duid->duid_id, len, 1, fp)) != 1) {
! 			debug_printf(LOG_ERR, FNAME, "failed to save DUID");
  			goto fail;
  		}
  
! 		debug_printf(LOG_DEBUG, FNAME, "saved generated DUID to %s",
  		    idfile);
  	}
  
***************
*** 1104,1110 ****
  	dl_phys_addr_req_t dlpar;
  	dl_phys_addr_ack_t *dlpaa;
  
! 	dprintf(LOG_DEBUG, FNAME, "trying %s ppa %d", ifname, ppa);
  
  	if (ifname[0] == '\0')
  		return (-1);
--- 1104,1110 ----
  	dl_phys_addr_req_t dlpar;
  	dl_phys_addr_ack_t *dlpaa;
  
! 	debug_printf(LOG_DEBUG, FNAME, "trying %s ppa %d", ifname, ppa);
  
  	if (ifname[0] == '\0')
  		return (-1);
***************
*** 1239,1245 ****
  
  		if ((root = di_init("/", DINFOSUBTREE | DINFOMINOR |
  		    DINFOPROP)) == DI_NODE_NIL) {
! 			dprintf(LOG_INFO, FNAME, "di_init failed");
  			return (-1);
  		}
  		parms.buf = buf;
--- 1239,1245 ----
  
  		if ((root = di_init("/", DINFOSUBTREE | DINFOMINOR |
  		    DINFOPROP)) == DI_NODE_NIL) {
! 			debug_printf(LOG_INFO, FNAME, "di_init failed");
  			return (-1);
  		}
  		parms.buf = buf;
***************
*** 1283,1289 ****
  		default:
  			continue; /* XXX */
  		}
! 		dprintf(LOG_DEBUG, FNAME, "found an interface %s for DUID",
  		    ifa->ifa_name);
  		memcpy(buf, LLADDR(sdl), sdl->sdl_alen);
  		l = sdl->sdl_alen; /* sdl will soon be freed */
--- 1283,1289 ----
  		default:
  			continue; /* XXX */
  		}
! 		debug_printf(LOG_DEBUG, FNAME, "found an interface %s for DUID",
  		    ifa->ifa_name);
  		memcpy(buf, LLADDR(sdl), sdl->sdl_alen);
  		l = sdl->sdl_alen; /* sdl will soon be freed */
***************
*** 1296,1302 ****
  		if (sll->sll_hatype != ARPHRD_ETHER)
  			continue;
  		*hwtypep = ARPHRD_ETHER;
! 		dprintf(LOG_DEBUG, FNAME, "found an interface %s for DUID",
  		    ifa->ifa_name);
  		memcpy(buf, sll->sll_addr, sll->sll_halen);
  		l = sll->sll_halen; /* sll will soon be freed */
--- 1296,1302 ----
  		if (sll->sll_hatype != ARPHRD_ETHER)
  			continue;
  		*hwtypep = ARPHRD_ETHER;
! 		debug_printf(LOG_DEBUG, FNAME, "found an interface %s for DUID",
  		    ifa->ifa_name);
  		memcpy(buf, sll->sll_addr, sll->sll_halen);
  		l = sll->sll_halen; /* sll will soon be freed */
***************
*** 1512,1523 ****
  		cp = (char *)(p + 1);
  		np = (struct dhcp6opt *)(cp + optlen);
  
! 		dprintf(LOG_DEBUG, FNAME, "get DHCP option %s, len %d",
  		    dhcp6optstr(opt), optlen);
  
  		/* option length field overrun */
  		if (np > ep) {
! 			dprintf(LOG_INFO, FNAME, "malformed DHCP options");
  			goto fail;
  		}
  
--- 1512,1523 ----
  		cp = (char *)(p + 1);
  		np = (struct dhcp6opt *)(cp + optlen);
  
! 		debug_printf(LOG_DEBUG, FNAME, "get DHCP option %s, len %d",
  		    dhcp6optstr(opt), optlen);
  
  		/* option length field overrun */
  		if (np > ep) {
! 			debug_printf(LOG_INFO, FNAME, "malformed DHCP options");
  			goto fail;
  		}
  
***************
*** 1527,1536 ****
  				goto malformed;
  			duid0.duid_len = optlen;
  			duid0.duid_id = cp;
! 			dprintf(LOG_DEBUG, "",
  				"  DUID: %s", duidstr(&duid0));
  			if (duidcpy(&optinfo->clientID, &duid0)) {
! 				dprintf(LOG_ERR, FNAME, "failed to copy DUID");
  				goto fail;
  			}
  			break;
--- 1527,1536 ----
  				goto malformed;
  			duid0.duid_len = optlen;
  			duid0.duid_id = cp;
! 			debug_printf(LOG_DEBUG, "",
  				"  DUID: %s", duidstr(&duid0));
  			if (duidcpy(&optinfo->clientID, &duid0)) {
! 				debug_printf(LOG_ERR, FNAME, "failed to copy DUID");
  				goto fail;
  			}
  			break;
***************
*** 1539,1547 ****
  				goto malformed;
  			duid0.duid_len = optlen;
  			duid0.duid_id = cp;
! 			dprintf(LOG_DEBUG, "", "  DUID: %s", duidstr(&duid0));
  			if (duidcpy(&optinfo->serverID, &duid0)) {
! 				dprintf(LOG_ERR, FNAME, "failed to copy DUID");
  				goto fail;
  			}
  			break;
--- 1539,1547 ----
  				goto malformed;
  			duid0.duid_len = optlen;
  			duid0.duid_id = cp;
! 			debug_printf(LOG_DEBUG, "", "  DUID: %s", duidstr(&duid0));
  			if (duidcpy(&optinfo->serverID, &duid0)) {
! 				debug_printf(LOG_ERR, FNAME, "failed to copy DUID");
  				goto fail;
  			}
  			break;
***************
*** 1550,1563 ****
  				goto malformed;
  			memcpy(&val16, cp, sizeof(val16));
  			num16 = ntohs(val16);
! 			dprintf(LOG_DEBUG, "", "  status code: %s",
  			    dhcp6_stcodestr(num16));
  
  			/* need to check duplication? */
  
  			if (dhcp6_add_listval(&optinfo->stcode_list,
  			    DHCP6_LISTVAL_STCODE, &num16, NULL) == NULL) {
! 				dprintf(LOG_ERR, FNAME, "failed to copy "
  				    "status code");
  				goto fail;
  			}
--- 1550,1563 ----
  				goto malformed;
  			memcpy(&val16, cp, sizeof(val16));
  			num16 = ntohs(val16);
! 			debug_printf(LOG_DEBUG, "", "  status code: %s",
  			    dhcp6_stcodestr(num16));
  
  			/* need to check duplication? */
  
  			if (dhcp6_add_listval(&optinfo->stcode_list,
  			    DHCP6_LISTVAL_STCODE, &num16, NULL) == NULL) {
! 				debug_printf(LOG_ERR, FNAME, "failed to copy "
  				    "status code");
  				goto fail;
  			}
***************
*** 1574,1586 ****
  				memcpy(&opttype, val, sizeof(u_int16_t));
  				num = (int)ntohs(opttype);
  
! 				dprintf(LOG_DEBUG, "",
  					"  requested option: %s",
  					dhcp6optstr(num));
  
  				if (dhcp6_find_listval(&optinfo->reqopt_list,
  				    DHCP6_LISTVAL_NUM, &num, 0)) {
! 					dprintf(LOG_INFO, FNAME, "duplicated "
  					    "option type (%s)",
  					    dhcp6optstr(opttype));
  					goto nextoption;
--- 1574,1586 ----
  				memcpy(&opttype, val, sizeof(u_int16_t));
  				num = (int)ntohs(opttype);
  
! 				debug_printf(LOG_DEBUG, "",
  					"  requested option: %s",
  					dhcp6optstr(num));
  
  				if (dhcp6_find_listval(&optinfo->reqopt_list,
  				    DHCP6_LISTVAL_NUM, &num, 0)) {
! 					debug_printf(LOG_INFO, FNAME, "duplicated "
  					    "option type (%s)",
  					    dhcp6optstr(opttype));
  					goto nextoption;
***************
*** 1588,1594 ****
  
  				if (dhcp6_add_listval(&optinfo->reqopt_list,
  				    DHCP6_LISTVAL_NUM, &num, NULL) == NULL) {
! 					dprintf(LOG_ERR, FNAME,
  					    "failed to copy requested option");
  					goto fail;
  				}
--- 1588,1594 ----
  
  				if (dhcp6_add_listval(&optinfo->reqopt_list,
  				    DHCP6_LISTVAL_NUM, &num, NULL) == NULL) {
! 					debug_printf(LOG_ERR, FNAME,
  					    "failed to copy requested option");
  					goto fail;
  				}
***************
*** 1599,1608 ****
  		case DH6OPT_PREFERENCE:
  			if (optlen != 1)
  				goto malformed;
! 			dprintf(LOG_DEBUG, "", "  preference: %d",
  			    (int)*(u_char *)cp);
  			if (optinfo->pref != DH6OPT_PREF_UNDEF) {
! 				dprintf(LOG_INFO, FNAME,
  				    "duplicated preference option");
  			} else
  				optinfo->pref = (int)*(u_char *)cp;
--- 1599,1608 ----
  		case DH6OPT_PREFERENCE:
  			if (optlen != 1)
  				goto malformed;
! 			debug_printf(LOG_DEBUG, "", "  preference: %d",
  			    (int)*(u_char *)cp);
  			if (optinfo->pref != DH6OPT_PREF_UNDEF) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "duplicated preference option");
  			} else
  				optinfo->pref = (int)*(u_char *)cp;
***************
*** 1612,1622 ****
  				goto malformed;
  			memcpy(&val16, cp, sizeof(val16));
  			val16 = ntohs(val16);
! 			dprintf(LOG_DEBUG, "", "  elapsed time: %lu",
  			    (u_int32_t)val16);
  			if (optinfo->elapsed_time !=
  			    DH6OPT_ELAPSED_TIME_UNDEF) {
! 				dprintf(LOG_INFO, FNAME,
  				    "duplicated elapsed time option");
  			} else
  				optinfo->elapsed_time = val16;
--- 1612,1622 ----
  				goto malformed;
  			memcpy(&val16, cp, sizeof(val16));
  			val16 = ntohs(val16);
! 			debug_printf(LOG_DEBUG, "", "  elapsed time: %lu",
  			    (u_int32_t)val16);
  			if (optinfo->elapsed_time !=
  			    DH6OPT_ELAPSED_TIME_UNDEF) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "duplicated elapsed time option");
  			} else
  				optinfo->elapsed_time = val16;
***************
*** 1637,1643 ****
  			 * [RFC3315 Section 21.4.2]
  			 */
  			if (optinfo->authproto != DHCP6_AUTHPROTO_UNDEF) {
! 				dprintf(LOG_INFO, FNAME, "found more than one "
  				    "authentication option");
  				goto fail;
  			}
--- 1637,1643 ----
  			 * [RFC3315 Section 21.4.2]
  			 */
  			if (optinfo->authproto != DHCP6_AUTHPROTO_UNDEF) {
! 				debug_printf(LOG_INFO, FNAME, "found more than one "
  				    "authentication option");
  				goto fail;
  			}
***************
*** 1648,1654 ****
  			memcpy(&optinfo->authrd, cp, sizeof(optinfo->authrd));
  			cp += sizeof(optinfo->authrd);
  
! 			dprintf(LOG_DEBUG, "", "  %s", sprint_auth(optinfo));
  
  			authinfolen =
  			    optlen - (sizeof(struct dhcp6opt_auth) - 4);
--- 1648,1654 ----
  			memcpy(&optinfo->authrd, cp, sizeof(optinfo->authrd));
  			cp += sizeof(optinfo->authrd);
  
! 			debug_printf(LOG_DEBUG, "", "  %s", sprint_auth(optinfo));
  
  			authinfolen =
  			    optlen - (sizeof(struct dhcp6opt_auth) - 4);
***************
*** 1670,1676 ****
  				optinfo->delayedauth_realmval =
  				    malloc(optinfo->delayedauth_realmlen);
  				if (optinfo->delayedauth_realmval == NULL) {
! 					dprintf(LOG_WARNING, FNAME, "failed "
  					    "allocate memory for auth realm");
  					goto fail;
  				}
--- 1670,1676 ----
  				optinfo->delayedauth_realmval =
  				    malloc(optinfo->delayedauth_realmlen);
  				if (optinfo->delayedauth_realmval == NULL) {
! 					debug_printf(LOG_WARNING, FNAME, "failed "
  					    "allocate memory for auth realm");
  					goto fail;
  				}
***************
*** 1687,1693 ****
  				optinfo->delayedauth_offset = cp - bp;
  				cp += 16;
  
! 				dprintf(LOG_DEBUG, "", "  auth key ID: %x, "
  				    "offset=%d, realmlen=%d",
  				    optinfo->delayedauth_keyid,
  				    optinfo->delayedauth_offset,
--- 1687,1693 ----
  				optinfo->delayedauth_offset = cp - bp;
  				cp += 16;
  
! 				debug_printf(LOG_DEBUG, "", "  auth key ID: %x, "
  				    "offset=%d, realmlen=%d",
  				    optinfo->delayedauth_keyid,
  				    optinfo->delayedauth_offset,
***************
*** 1698,1704 ****
  				break;
  #endif
  			default:
! 				dprintf(LOG_INFO, FNAME,
  				    "unsupported authentication protocol: %d",
  				    *cp);
  				goto fail;
--- 1698,1704 ----
  				break;
  #endif
  			default:
! 				debug_printf(LOG_INFO, FNAME,
  				    "unsupported authentication protocol: %d",
  				    *cp);
  				goto fail;
***************
*** 1779,1792 ****
  			ia.t1 = ntohl(optia.dh6_ia_t1);
  			ia.t2 = ntohl(optia.dh6_ia_t2);
  
! 			dprintf(LOG_DEBUG, "",
  			    "  IA_PD: ID=%lu, T1=%lu, T2=%lu",
  			    ia.iaid, ia.t1, ia.t2);
  
  			/* duplication check */
  			if (dhcp6_find_listval(&optinfo->iapd_list,
  			    DHCP6_LISTVAL_IAPD, &ia, 0)) {
! 				dprintf(LOG_INFO, FNAME,
  				    "duplicated IA_PD %lu", ia.iaid);
  				break; /* ignore this IA_PD */
  			}
--- 1779,1792 ----
  			ia.t1 = ntohl(optia.dh6_ia_t1);
  			ia.t2 = ntohl(optia.dh6_ia_t2);
  
! 			debug_printf(LOG_DEBUG, "",
  			    "  IA_PD: ID=%lu, T1=%lu, T2=%lu",
  			    ia.iaid, ia.t1, ia.t2);
  
  			/* duplication check */
  			if (dhcp6_find_listval(&optinfo->iapd_list,
  			    DHCP6_LISTVAL_IAPD, &ia, 0)) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "duplicated IA_PD %lu", ia.iaid);
  				break; /* ignore this IA_PD */
  			}
***************
*** 1813,1819 ****
  				goto malformed;
  			memcpy(&val32, cp, sizeof(val32));
  			val32 = ntohl(val32);
! 			dprintf(LOG_DEBUG, "",
  			    "   information refresh time: %lu", val32);
  			if (val32 < DHCP6_IRT_MINIMUM) {
  				/*
--- 1813,1819 ----
  				goto malformed;
  			memcpy(&val32, cp, sizeof(val32));
  			val32 = ntohl(val32);
! 			debug_printf(LOG_DEBUG, "",
  			    "   information refresh time: %lu", val32);
  			if (val32 < DHCP6_IRT_MINIMUM) {
  				/*
***************
*** 1823,1835 ****
  				 * [draft-ietf-dhc-lifetime-02.txt,
  				 *  Section 3.2]
  				 */
! 				dprintf(LOG_INFO, FNAME,
  				    "refresh time is too small (%d), adjusted",
  				    val32);
  				val32 = DHCP6_IRT_MINIMUM;
  			}
  			if (optinfo->refreshtime != DH6OPT_REFRESHTIME_UNDEF) {
! 				dprintf(LOG_INFO, FNAME,
  				    "duplicated refresh time option");
  			} else
  				optinfo->refreshtime = (int64_t)val32;
--- 1823,1835 ----
  				 * [draft-ietf-dhc-lifetime-02.txt,
  				 *  Section 3.2]
  				 */
! 				debug_printf(LOG_INFO, FNAME,
  				    "refresh time is too small (%d), adjusted",
  				    val32);
  				val32 = DHCP6_IRT_MINIMUM;
  			}
  			if (optinfo->refreshtime != DH6OPT_REFRESHTIME_UNDEF) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "duplicated refresh time option");
  			} else
  				optinfo->refreshtime = (int64_t)val32;
***************
*** 1843,1856 ****
  			ia.t1 = ntohl(optia.dh6_ia_t1);
  			ia.t2 = ntohl(optia.dh6_ia_t2);
  
! 			dprintf(LOG_DEBUG, "",
  			    "  IA_NA: ID=%lu, T1=%lu, T2=%lu",
  			    ia.iaid, ia.t1, ia.t2);
  
  			/* duplication check */
  			if (dhcp6_find_listval(&optinfo->iana_list,
  			    DHCP6_LISTVAL_IANA, &ia, 0)) {
! 				dprintf(LOG_INFO, FNAME,
  				    "duplicated IA_NA %lu", ia.iaid);
  				break; /* ignore this IA_NA */
  			}
--- 1843,1856 ----
  			ia.t1 = ntohl(optia.dh6_ia_t1);
  			ia.t2 = ntohl(optia.dh6_ia_t2);
  
! 			debug_printf(LOG_DEBUG, "",
  			    "  IA_NA: ID=%lu, T1=%lu, T2=%lu",
  			    ia.iaid, ia.t1, ia.t2);
  
  			/* duplication check */
  			if (dhcp6_find_listval(&optinfo->iana_list,
  			    DHCP6_LISTVAL_IANA, &ia, 0)) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "duplicated IA_NA %lu", ia.iaid);
  				break; /* ignore this IA_NA */
  			}
***************
*** 1874,1880 ****
  			break;
  		default:
  			/* no option specific behavior */
! 			dprintf(LOG_INFO, FNAME,
  			    "unknown or unexpected DHCP6 option %s, len %d",
  			    dhcp6optstr(opt), optlen);
  			break;
--- 1874,1880 ----
  			break;
  		default:
  			/* no option specific behavior */
! 			debug_printf(LOG_INFO, FNAME,
  			    "unknown or unexpected DHCP6 option %s, len %d",
  			    dhcp6optstr(opt), optlen);
  			break;
***************
*** 1884,1890 ****
  	return (0);
  
    malformed:
! 	dprintf(LOG_INFO, FNAME, "malformed DHCP option: type %d, len %d",
  	    opt, optlen);
    fail:
  	dhcp6_clear_options(optinfo);
--- 1884,1890 ----
  	return (0);
  
    malformed:
! 	debug_printf(LOG_INFO, FNAME, "malformed DHCP option: type %d, len %d",
  	    opt, optlen);
    fail:
  	dhcp6_clear_options(optinfo);
***************
*** 1967,1977 ****
  		cp = (char *)(p + 1);
  		np = (struct dhcp6opt *)(cp + optlen);
  
! 		dprintf(LOG_DEBUG, FNAME, "get DHCP option %s, len %d",
  		    dhcp6optstr(opt), optlen);
  
  		if (np > ep) {
! 			dprintf(LOG_INFO, FNAME, "malformed DHCP option");
  			goto fail;
  		}
  
--- 1967,1977 ----
  		cp = (char *)(p + 1);
  		np = (struct dhcp6opt *)(cp + optlen);
  
! 		debug_printf(LOG_DEBUG, FNAME, "get DHCP option %s, len %d",
  		    dhcp6optstr(opt), optlen);
  
  		if (np > ep) {
! 			debug_printf(LOG_INFO, FNAME, "malformed DHCP option");
  			goto fail;
  		}
  
***************
*** 1979,1985 ****
  		case DH6OPT_IA_PD_PREFIX:
  			/* check option context */
  			if (type != DH6OPT_IA_PD) {
! 				dprintf(LOG_INFO, FNAME,
  				    "%s is an invalid position for %s",
  				    dhcp6optstr(type), dhcp6optstr(opt));
  				goto fail;
--- 1979,1985 ----
  		case DH6OPT_IA_PD_PREFIX:
  			/* check option context */
  			if (type != DH6OPT_IA_PD) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "%s is an invalid position for %s",
  				    dhcp6optstr(type), dhcp6optstr(opt));
  				goto fail;
***************
*** 1991,1997 ****
  			/* copy and convert option values */
  			memcpy(&opt_iapd_prefix, p, sizeof(opt_iapd_prefix));
  			if (opt_iapd_prefix.dh6_iapd_prefix_prefix_len > 128) {
! 				dprintf(LOG_INFO, FNAME,
  				    "invalid prefix length (%d)",
  				    opt_iapd_prefix.dh6_iapd_prefix_prefix_len);
  				goto malformed;
--- 1991,1997 ----
  			/* copy and convert option values */
  			memcpy(&opt_iapd_prefix, p, sizeof(opt_iapd_prefix));
  			if (opt_iapd_prefix.dh6_iapd_prefix_prefix_len > 128) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "invalid prefix length (%d)",
  				    opt_iapd_prefix.dh6_iapd_prefix_prefix_len);
  				goto malformed;
***************
*** 2006,2012 ****
  			/* clear padding bits in the prefix address */
  			prefix6_mask(&iapd_prefix.addr, iapd_prefix.plen);
  
! 			dprintf(LOG_DEBUG, FNAME, "  IA_PD prefix: "
  			    "%s/%d pltime=%lu vltime=%lu",
  			    in6addr2str(&iapd_prefix.addr, 0),
  			    iapd_prefix.plen,
--- 2006,2012 ----
  			/* clear padding bits in the prefix address */
  			prefix6_mask(&iapd_prefix.addr, iapd_prefix.plen);
  
! 			debug_printf(LOG_DEBUG, FNAME, "  IA_PD prefix: "
  			    "%s/%d pltime=%lu vltime=%lu",
  			    in6addr2str(&iapd_prefix.addr, 0),
  			    iapd_prefix.plen,
***************
*** 2014,2020 ****
  
  			if (dhcp6_find_listval(list, DHCP6_LISTVAL_PREFIX6,
  			    &iapd_prefix, 0)) {
! 				dprintf(LOG_INFO, FNAME, 
  				    "duplicated IA_PD prefix "
  				    "%s/%d pltime=%lu vltime=%lu",
  				    in6addr2str(&iapd_prefix.addr, 0),
--- 2014,2020 ----
  
  			if (dhcp6_find_listval(list, DHCP6_LISTVAL_PREFIX6,
  			    &iapd_prefix, 0)) {
! 				debug_printf(LOG_INFO, FNAME, 
  				    "duplicated IA_PD prefix "
  				    "%s/%d pltime=%lu vltime=%lu",
  				    in6addr2str(&iapd_prefix.addr, 0),
***************
*** 2041,2047 ****
  		case DH6OPT_IAADDR:
  			/* check option context */
  			if (type != DH6OPT_IA_NA) {
! 				dprintf(LOG_INFO, FNAME,
  				    "%s is an invalid position for %s",
  				    dhcp6optstr(type), dhcp6optstr(opt));
  				goto fail;
--- 2041,2047 ----
  		case DH6OPT_IAADDR:
  			/* check option context */
  			if (type != DH6OPT_IA_NA) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "%s is an invalid position for %s",
  				    dhcp6optstr(type), dhcp6optstr(opt));
  				goto fail;
***************
*** 2057,2070 ****
  			memcpy(&ia_addr.addr, &opt_ia_addr.dh6_ia_addr_addr,
  			    sizeof(ia_addr.addr));
  
! 			dprintf(LOG_DEBUG, FNAME, "  IA_NA address: "
  			    "%s pltime=%lu vltime=%lu",
  			    in6addr2str(&ia_addr.addr, 0),
  			    ia_addr.pltime, ia_addr.vltime);
  
  			if (dhcp6_find_listval(list,
  			    DHCP6_LISTVAL_STATEFULADDR6, &ia_addr, 0)) {
! 				dprintf(LOG_INFO, FNAME, 
  				    "duplicated IA_NA address"
  				    "%s pltime=%lu vltime=%lu",
  				    in6addr2str(&ia_addr.addr, 0),
--- 2057,2070 ----
  			memcpy(&ia_addr.addr, &opt_ia_addr.dh6_ia_addr_addr,
  			    sizeof(ia_addr.addr));
  
! 			debug_printf(LOG_DEBUG, FNAME, "  IA_NA address: "
  			    "%s pltime=%lu vltime=%lu",
  			    in6addr2str(&ia_addr.addr, 0),
  			    ia_addr.pltime, ia_addr.vltime);
  
  			if (dhcp6_find_listval(list,
  			    DHCP6_LISTVAL_STATEFULADDR6, &ia_addr, 0)) {
! 				debug_printf(LOG_INFO, FNAME, 
  				    "duplicated IA_NA address"
  				    "%s pltime=%lu vltime=%lu",
  				    in6addr2str(&ia_addr.addr, 0),
***************
*** 2093,2099 ****
  			    type != DH6OPT_IA_PD_PREFIX &&
  			    type != DH6OPT_IA_NA &&
  			    type != DH6OPT_IAADDR) {
! 				dprintf(LOG_INFO, FNAME,
  				    "%s is an invalid position for %s",
  				    dhcp6optstr(type), dhcp6optstr(opt));
  				goto nextoption; /* or discard the message? */
--- 2093,2099 ----
  			    type != DH6OPT_IA_PD_PREFIX &&
  			    type != DH6OPT_IA_NA &&
  			    type != DH6OPT_IAADDR) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "%s is an invalid position for %s",
  				    dhcp6optstr(type), dhcp6optstr(opt));
  				goto nextoption; /* or discard the message? */
***************
*** 2107,2119 ****
  			opt_stcode.dh6_stcode_code =
  			    ntohs(opt_stcode.dh6_stcode_code);
  
! 			dprintf(LOG_DEBUG, "", "  status code: %s",
  			    dhcp6_stcodestr(opt_stcode.dh6_stcode_code));
  
  			/* duplication check */
  			if (dhcp6_find_listval(list, DHCP6_LISTVAL_STCODE,
  			    &opt_stcode.dh6_stcode_code, 0)) {
! 				dprintf(LOG_INFO, FNAME,
  				    "duplicated status code (%d)",
  				    opt_stcode.dh6_stcode_code);
  				goto nextoption;
--- 2107,2119 ----
  			opt_stcode.dh6_stcode_code =
  			    ntohs(opt_stcode.dh6_stcode_code);
  
! 			debug_printf(LOG_DEBUG, "", "  status code: %s",
  			    dhcp6_stcodestr(opt_stcode.dh6_stcode_code));
  
  			/* duplication check */
  			if (dhcp6_find_listval(list, DHCP6_LISTVAL_STCODE,
  			    &opt_stcode.dh6_stcode_code, 0)) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "duplicated status code (%d)",
  				    opt_stcode.dh6_stcode_code);
  				goto nextoption;
***************
*** 2133,2139 ****
  	return (0);
  
    malformed:
! 	dprintf(LOG_INFO, "", "  malformed DHCP option: type %d", opt);
  
    fail:
  	dhcp6_clear_list(&sublist);
--- 2133,2139 ----
  	return (0);
  
    malformed:
! 	debug_printf(LOG_INFO, "", "  malformed DHCP option: type %d", opt);
  
    fail:
  	dhcp6_clear_list(&sublist);
***************
*** 2221,2227 ****
  	struct dhcp6opt *opt = *optp, opth;
  
  	if ((void *)ep - (void *)optp < len + sizeof(struct dhcp6opt)) {
! 		dprintf(LOG_INFO, FNAME,
  		    "option buffer short for %s", dhcp6optstr(type));
  		return (-1);
  	}
--- 2221,2227 ----
  	struct dhcp6opt *opt = *optp, opth;
  
  	if ((void *)ep - (void *)optp < len + sizeof(struct dhcp6opt)) {
! 		debug_printf(LOG_INFO, FNAME,
  		    "option buffer short for %s", dhcp6optstr(type));
  		return (-1);
  	}
***************
*** 2233,2239 ****
  
  	*optp = (struct dhcp6opt *)((char *)(opt + 1) + len);
   	*totallenp += sizeof(struct dhcp6opt) + len;
! 	dprintf(LOG_DEBUG, FNAME, "set %s (len %d)", dhcp6optstr(type), len);
  
  	return (0);
  }
--- 2233,2239 ----
  
  	*optp = (struct dhcp6opt *)((char *)(opt + 1) + len);
   	*totallenp += sizeof(struct dhcp6opt) + len;
! 	debug_printf(LOG_DEBUG, FNAME, "set %s (len %d)", dhcp6optstr(type), len);
  
  	return (0);
  }
***************
*** 2335,2355 ****
  
  		tmpbuf = NULL;
  		if ((optlen = copyout_option(NULL, NULL, op)) < 0) {
! 			dprintf(LOG_INFO, FNAME,
  			    "failed to count option length");
  			goto fail;
  		}
  		if ((void *)optep - (void *)p < optlen) {
! 			dprintf(LOG_INFO, FNAME, "short buffer");
  			goto fail;
  		}
  		if ((tmpbuf = malloc(optlen)) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "memory allocation failed for IA_NA options");
  			goto fail;
  		}
  		if (copyout_option(tmpbuf, tmpbuf + optlen, op) < 0) {
! 			dprintf(LOG_ERR, FNAME,
  			    "failed to construct an IA_NA option");
  			goto fail;
  		}
--- 2335,2355 ----
  
  		tmpbuf = NULL;
  		if ((optlen = copyout_option(NULL, NULL, op)) < 0) {
! 			debug_printf(LOG_INFO, FNAME,
  			    "failed to count option length");
  			goto fail;
  		}
  		if ((void *)optep - (void *)p < optlen) {
! 			debug_printf(LOG_INFO, FNAME, "short buffer");
  			goto fail;
  		}
  		if ((tmpbuf = malloc(optlen)) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "memory allocation failed for IA_NA options");
  			goto fail;
  		}
  		if (copyout_option(tmpbuf, tmpbuf + optlen, op) < 0) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "failed to construct an IA_NA option");
  			goto fail;
  		}
***************
*** 2447,2453 ****
  		buflen = (dhcp6_count_list(&optinfo->reqopt_list) + (requestFQDN ? 1 : 0)) * 	// !!! LTRX Add one for FQDN option
  			sizeof(u_int16_t);
  		if ((tmpbuf = malloc(buflen)) == NULL) {
! 			dprintf(LOG_ERR, FNAME,
  			    "memory allocation failed for options");
  			goto fail;
  		}
--- 2447,2453 ----
  		buflen = (dhcp6_count_list(&optinfo->reqopt_list) + (requestFQDN ? 1 : 0)) * 	// !!! LTRX Add one for FQDN option
  			sizeof(u_int16_t);
  		if ((tmpbuf = malloc(buflen)) == NULL) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "memory allocation failed for options");
  			goto fail;
  		}
***************
*** 2462,2468 ****
  			 */
  			if (opt->val_num == DH6OPT_REFRESHTIME &&
  			    type != DH6_INFORM_REQ) {
! 				dprintf(LOG_DEBUG, FNAME,
  				    "refresh time option is not requested "
  				    "for %s", dhcp6msgstr(type));
  			}
--- 2462,2468 ----
  			 */
  			if (opt->val_num == DH6OPT_REFRESHTIME &&
  			    type != DH6_INFORM_REQ) {
! 				debug_printf(LOG_DEBUG, FNAME,
  				    "refresh time option is not requested "
  				    "for %s", dhcp6msgstr(type));
  			}
***************
*** 2541,2561 ****
  
  		tmpbuf = NULL;
  		if ((optlen = copyout_option(NULL, NULL, op)) < 0) {
! 			dprintf(LOG_INFO, FNAME,
  			    "failed to count option length");
  			goto fail;
  		}
  		if ((void *)optep - (void *)p < optlen) {
! 			dprintf(LOG_INFO, FNAME, "short buffer");
  			goto fail;
  		}
  		if ((tmpbuf = malloc(optlen)) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "memory allocation failed for IA_PD options");
  			goto fail;
  		}
  		if (copyout_option(tmpbuf, tmpbuf + optlen, op) < 0) {
! 			dprintf(LOG_ERR, FNAME,
  			    "failed to construct an IA_PD option");
  			goto fail;
  		}
--- 2541,2561 ----
  
  		tmpbuf = NULL;
  		if ((optlen = copyout_option(NULL, NULL, op)) < 0) {
! 			debug_printf(LOG_INFO, FNAME,
  			    "failed to count option length");
  			goto fail;
  		}
  		if ((void *)optep - (void *)p < optlen) {
! 			debug_printf(LOG_INFO, FNAME, "short buffer");
  			goto fail;
  		}
  		if ((tmpbuf = malloc(optlen)) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "memory allocation failed for IA_PD options");
  			goto fail;
  		}
  		if (copyout_option(tmpbuf, tmpbuf + optlen, op) < 0) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "failed to construct an IA_PD option");
  			goto fail;
  		}
***************
*** 2610,2622 ****
  				break;
  #endif
  			default:
! 				dprintf(LOG_ERR, FNAME,
  				    "unexpected authentication protocol");
  				goto fail;
  			}
  		}
  		if ((auth = malloc(authlen)) == NULL) {
! 			dprintf(LOG_WARNING, FNAME, "failed to allocate "
  			    "memory for authentication information");
  			goto fail;
  		}
--- 2610,2622 ----
  				break;
  #endif
  			default:
! 				debug_printf(LOG_ERR, FNAME,
  				    "unexpected authentication protocol");
  				goto fail;
  			}
  		}
  		if ((auth = malloc(authlen)) == NULL) {
! 			debug_printf(LOG_WARNING, FNAME, "failed to allocate "
  			    "memory for authentication information");
  			goto fail;
  		}
***************
*** 2652,2658 ****
  				optinfo->delayedauth_offset =
  				    ((char *)p - (char *)optbp) + authlen - 16;
  
! 				dprintf(LOG_DEBUG, FNAME,
  				    "key ID %x, offset %d",
  				    optinfo->delayedauth_keyid,
  				    optinfo->delayedauth_offset); 
--- 2652,2658 ----
  				optinfo->delayedauth_offset =
  				    ((char *)p - (char *)optbp) + authlen - 16;
  
! 				debug_printf(LOG_DEBUG, FNAME,
  				    "key ID %x, offset %d",
  				    optinfo->delayedauth_keyid,
  				    optinfo->delayedauth_offset); 
***************
*** 2661,2667 ****
  			case DHCP6_AUTHPROTO_RECONFIG:
  #endif
  			default:
! 				dprintf(LOG_ERR, FNAME,
  				    "unexpected authentication protocol");
  				free(auth);
  				goto fail;
--- 2661,2667 ----
  			case DHCP6_AUTHPROTO_RECONFIG:
  #endif
  			default:
! 				debug_printf(LOG_ERR, FNAME,
  				    "unexpected authentication protocol");
  				free(auth);
  				goto fail;
***************
*** 2813,2819 ****
  		 * we encounter an unknown option.  this should be an internal
  		 * error.
  		 */
! 		dprintf(LOG_ERR, FNAME, "unknown option: code %d",
  		    optval->type);
  		return (-1);
  	}
--- 2813,2819 ----
  		 * we encounter an unknown option.  this should be an internal
  		 * error.
  		 */
! 		debug_printf(LOG_ERR, FNAME, "unknown option: code %d",
  		    optval->type);
  		return (-1);
  	}
***************
*** 2839,2845 ****
  	if (!p)
  		return(optlen);
  
! 	dprintf(LOG_DEBUG, FNAME, "set %s", dhcp6optstr(opttype));
  	if (ep - p < headlen) /* check it just in case */
  		return (-1);
  
--- 2839,2845 ----
  	if (!p)
  		return(optlen);
  
! 	debug_printf(LOG_DEBUG, FNAME, "set %s", dhcp6optstr(opttype));
  	if (ep - p < headlen) /* check it just in case */
  		return (-1);
  
***************
*** 2930,2936 ****
  		ev->max_retrans_cnt = REL_MAX_RC;
  		break;
  	default:
! 		dprintf(LOG_ERR, FNAME, "unexpected event state %d on %s",
  		    ev->state, ev->ifp->ifname);
  		exit(1);
  	}
--- 2930,2936 ----
  		ev->max_retrans_cnt = REL_MAX_RC;
  		break;
  	default:
! 		debug_printf(LOG_ERR, FNAME, "unexpected event state %d on %s",
  		    ev->state, ev->ifp->ifname);
  		exit(1);
  	}
***************
*** 2988,2994 ****
  
  	statestr = dhcp6_event_statestr(ev);
  
! 	dprintf(LOG_DEBUG, FNAME, "reset a timer on %s, "
  		"state=%s, timeo=%d, retrans=%d",
  		ev->ifp->ifname, statestr, ev->timeouts, ev->retrans);
  }
--- 2988,2994 ----
  
  	statestr = dhcp6_event_statestr(ev);
  
! 	debug_printf(LOG_DEBUG, FNAME, "reset a timer on %s, "
  		"state=%s, timeo=%d, retrans=%d",
  		ev->ifp->ifname, statestr, ev->timeouts, ev->retrans);
  }
***************
*** 2999,3005 ****
  {
  	dd->duid_len = ds->duid_len;
  	if ((dd->duid_id = malloc(dd->duid_len)) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "memory allocation failed");
  		return (-1);
  	}
  	memcpy(dd->duid_id, ds->duid_id, dd->duid_len);
--- 2999,3005 ----
  {
  	dd->duid_len = ds->duid_len;
  	if ((dd->duid_id = malloc(dd->duid_len)) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "memory allocation failed");
  		return (-1);
  	}
  	memcpy(dd->duid_id, ds->duid_id, dd->duid_len);
***************
*** 3047,3063 ****
  	u_int32_t u32, l32;
  
  	if (rdm != DHCP6_AUTHRDM_MONOCOUNTER) {
! 		dprintf(LOG_INFO, FNAME, "unsupported RDM (%d)", rdm);
  		return (-1);
  	}
  	if (rdsize != sizeof(u_int64_t)) {
! 		dprintf(LOG_INFO, FNAME, "unsupported RD size (%d)", rdsize);
  		return (-1);
  	}
  
  #if defined(HAVE_CLOCK_GETTIME)
  	if (clock_gettime(CLOCK_REALTIME, &tp)) {
! 		dprintf(LOG_WARNING, FNAME, "clock_gettime failed: %s",
  		    strerror(errno));
  		return (-1);
  	}
--- 3047,3063 ----
  	u_int32_t u32, l32;
  
  	if (rdm != DHCP6_AUTHRDM_MONOCOUNTER) {
! 		debug_printf(LOG_INFO, FNAME, "unsupported RDM (%d)", rdm);
  		return (-1);
  	}
  	if (rdsize != sizeof(u_int64_t)) {
! 		debug_printf(LOG_INFO, FNAME, "unsupported RD size (%d)", rdsize);
  		return (-1);
  	}
  
  #if defined(HAVE_CLOCK_GETTIME)
  	if (clock_gettime(CLOCK_REALTIME, &tp)) {
! 		debug_printf(LOG_WARNING, FNAME, "clock_gettime failed: %s",
  		    strerror(errno));
  		return (-1);
  	}
***************
*** 3070,3076 ****
  	l32 = (u_int32_t)nsec;
  #else
  	if (gettimeofday(&tv, NULL) != 0) {
! 		dprintf(LOG_WARNING, FNAME, "gettimeofday failed: %s",
  		    strerror(errno));
  		return (-1);
  	}
--- 3070,3076 ----
  	l32 = (u_int32_t)nsec;
  #else
  	if (gettimeofday(&tv, NULL) != 0) {
! 		debug_printf(LOG_WARNING, FNAME, "gettimeofday failed: %s",
  		    strerror(errno));
  		return (-1);
  	}
***************
*** 3325,3331 ****
  }
  
  void
! dprintf(int level, const char *fname, const char *fmt, ...)
  {
  	va_list ap;
  	char logbuf[LINE_MAX];
--- 3325,3331 ----
  }
  
  void
! debug_printf(int level, const char *fname, const char *fmt, ...)
  {
  	va_list ap;
  	char logbuf[LINE_MAX];
***************
*** 3411,3417 ****
  	}
  
  	if ((s = socket(PF_INET6, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "can't open a temporary socket: %s",
  		    strerror(errno));
  		return (-1);
  	}
--- 3411,3417 ----
  	}
  
  	if ((s = socket(PF_INET6, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "can't open a temporary socket: %s",
  		    strerror(errno));
  		return (-1);
  	}
***************
*** 3429,3435 ****
  	memset(&ifr, 0, sizeof(ifr));
  	strncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);
  	if (ioctl(s, SIOGIFINDEX, &ifr) < 0) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to get the index of %s: %s",
  		    ifname, strerror(errno));
  		close(s); 
  		return (-1); 
--- 3429,3435 ----
  	memset(&ifr, 0, sizeof(ifr));
  	strncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);
  	if (ioctl(s, SIOGIFINDEX, &ifr) < 0) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to get the index of %s: %s",
  		    ifname, strerror(errno));
  		close(s); 
  		return (-1); 
***************
*** 3443,3449 ****
  #endif
  
  	if (ioctl(s, ioctl_cmd, &req)) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to %s an address on %s: %s",
  		    cmdstr, ifname, strerror(errno));
  		close(s);
  		return (-1);
--- 3443,3449 ----
  #endif
  
  	if (ioctl(s, ioctl_cmd, &req)) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to %s an address on %s: %s",
  		    cmdstr, ifname, strerror(errno));
  		close(s);
  		return (-1);
***************
*** 3452,3465 ****
  #ifdef __sun__
  	memcpy(&req.lifr_addr, addr, sizeof (*addr));
  	if (ioctl(s, SIOCSLIFADDR, &req) == -1) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to %s new address on %s: %s",
  		    cmdstr, ifname, strerror(errno));
  		close(s);
  		return (-1);
  	}
  #endif
  
! 	dprintf(LOG_DEBUG, FNAME, "%s an address %s/%d on %s", cmdstr,
  	    addr2str((struct sockaddr *)addr), plen, ifname);
  
  	close(s);
--- 3452,3465 ----
  #ifdef __sun__
  	memcpy(&req.lifr_addr, addr, sizeof (*addr));
  	if (ioctl(s, SIOCSLIFADDR, &req) == -1) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to %s new address on %s: %s",
  		    cmdstr, ifname, strerror(errno));
  		close(s);
  		return (-1);
  	}
  #endif
  
! 	debug_printf(LOG_DEBUG, FNAME, "%s an address %s/%d on %s", cmdstr,
  	    addr2str((struct sockaddr *)addr), plen, ifname);
  
  	close(s);
***************
*** 3503,3515 ****
  
  	/* no setuid */
  	if (getuid() != geteuid()) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "setuid'ed execution not allowed");
  		return (-1);
  	}
  
  	if (lstat(path, &s) != 0) {
! 		dprintf(LOG_NOTICE, FNAME, "lstat failed: %s",
  		    strerror(errno));
  		return (-1);
  	}
--- 3503,3515 ----
  
  	/* no setuid */
  	if (getuid() != geteuid()) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "setuid'ed execution not allowed");
  		return (-1);
  	}
  
  	if (lstat(path, &s) != 0) {
! 		debug_printf(LOG_NOTICE, FNAME, "lstat failed: %s",
  		    strerror(errno));
  		return (-1);
  	}
***************
*** 3517,3523 ****
  	/* the file must be owned by the running uid */
  	myuid = getuid();
  	if (s.st_uid != myuid) {
! 		dprintf(LOG_NOTICE, FNAME, "%s has invalid owner uid", path);
  		return (-1);
  	}
  
--- 3517,3523 ----
  	/* the file must be owned by the running uid */
  	myuid = getuid();
  	if (s.st_uid != myuid) {
! 		debug_printf(LOG_NOTICE, FNAME, "%s has invalid owner uid", path);
  		return (-1);
  	}
  
***************
*** 3525,3531 ****
  	case S_IFREG:
  		break;
  	default:
! 		dprintf(LOG_NOTICE, FNAME, "%s is an invalid file type 0x%o",
  		    path, (s.st_mode & S_IFMT));
  		return (-1);
  	}
--- 3525,3531 ----
  	case S_IFREG:
  		break;
  	default:
! 		debug_printf(LOG_NOTICE, FNAME, "%s is an invalid file type 0x%o",
  		    path, (s.st_mode & S_IFMT));
  		return (-1);
  	}
diff -crB wide-dhcpv6-20080615/common.h wide-dhcpv6-20080615-ltrx/common.h
*** wide-dhcpv6-20080615/common.h	2007-03-21 15:22:57.000000000 +0530
--- wide-dhcpv6-20080615-ltrx/common.h	2015-04-22 16:17:46.388967234 +0530
***************
*** 155,161 ****
  extern int in6_addrscopebyif __P((struct in6_addr *, char *));
  extern int in6_scope __P((struct in6_addr *));
  extern void setloglevel __P((int));
! extern void dprintf __P((int, const char *, const char *, ...));
  extern int get_duid __P((char *, struct duid *));
  extern void dhcp6_init_options __P((struct dhcp6_optinfo *));
  extern void dhcp6_clear_options __P((struct dhcp6_optinfo *));
--- 155,161 ----
  extern int in6_addrscopebyif __P((struct in6_addr *, char *));
  extern int in6_scope __P((struct in6_addr *));
  extern void setloglevel __P((int));
! extern void debug_printf __P((int, const char *, const char *, ...));
  extern int get_duid __P((char *, struct duid *));
  extern void dhcp6_init_options __P((struct dhcp6_optinfo *));
  extern void dhcp6_clear_options __P((struct dhcp6_optinfo *));
diff -crB wide-dhcpv6-20080615/config.c wide-dhcpv6-20080615-ltrx/config.c
*** wide-dhcpv6-20080615/config.c	2008-06-15 13:18:41.000000000 +0530
--- wide-dhcpv6-20080615-ltrx/config.c	2015-04-22 16:17:46.312966697 +0530
***************
*** 156,168 ****
  		struct cf_list *cfl;
  
  		if (if_nametoindex(ifp->name) == 0) {
! 			dprintf(LOG_ERR, FNAME, "invalid interface(%s): %s",
  			    ifp->name, strerror(errno));
  			goto bad;
  		}
  
  		if ((ifc = malloc(sizeof(*ifc))) == NULL) {
! 			dprintf(LOG_ERR, FNAME,
  			    "memory allocation for %s failed", ifp->name);
  			goto bad;
  		}
--- 156,168 ----
  		struct cf_list *cfl;
  
  		if (if_nametoindex(ifp->name) == 0) {
! 			debug_printf(LOG_ERR, FNAME, "invalid interface(%s): %s",
  			    ifp->name, strerror(errno));
  			goto bad;
  		}
  
  		if ((ifc = malloc(sizeof(*ifc))) == NULL) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "memory allocation for %s failed", ifp->name);
  			goto bad;
  		}
***************
*** 171,177 ****
  		dhcp6_ifconflist = ifc;
  
  		if ((ifc->ifname = strdup(ifp->name)) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "failed to copy ifname");
  			goto bad;
  		}
  
--- 171,177 ----
  		dhcp6_ifconflist = ifc;
  
  		if ((ifc->ifname = strdup(ifp->name)) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "failed to copy ifname");
  			goto bad;
  		}
  
***************
*** 183,189 ****
  			switch(cfl->type) {
  			case DECL_REQUEST:
  				if (dhcp6_mode != DHCP6_MODE_CLIENT) {
! 					dprintf(LOG_INFO, FNAME, "%s:%d "
  						"client-only configuration",
  						configfilename,
  						cfl->line);
--- 183,189 ----
  			switch(cfl->type) {
  			case DECL_REQUEST:
  				if (dhcp6_mode != DHCP6_MODE_CLIENT) {
! 					debug_printf(LOG_INFO, FNAME, "%s:%d "
  						"client-only configuration",
  						configfilename,
  						cfl->line);
***************
*** 208,214 ****
  				break;
  			case DECL_INFO_ONLY:
  				if (dhcp6_mode != DHCP6_MODE_CLIENT) {
! 					dprintf(LOG_INFO, FNAME, "%s:%d "
  						"client-only configuration",
  						configfilename, cfl->line);
  					goto bad;
--- 208,214 ----
  				break;
  			case DECL_INFO_ONLY:
  				if (dhcp6_mode != DHCP6_MODE_CLIENT) {
! 					debug_printf(LOG_INFO, FNAME, "%s:%d "
  						"client-only configuration",
  						configfilename, cfl->line);
  					goto bad;
***************
*** 217,223 ****
  				break;
  			case DECL_PREFERENCE:
  				if (dhcp6_mode != DHCP6_MODE_SERVER) {
! 					dprintf(LOG_INFO, FNAME, "%s:%d "
  						"server-only configuration",
  						configfilename, cfl->line);
  					goto bad;
--- 217,223 ----
  				break;
  			case DECL_PREFERENCE:
  				if (dhcp6_mode != DHCP6_MODE_SERVER) {
! 					debug_printf(LOG_INFO, FNAME, "%s:%d "
  						"server-only configuration",
  						configfilename, cfl->line);
  					goto bad;
***************
*** 225,231 ****
  				ifc->server_pref = (int)cfl->num;
  				if (ifc->server_pref < 0 ||
  				    ifc->server_pref > 255) {
! 					dprintf(LOG_INFO, FNAME, "%s:%d "
  						"bad value: %d",
  						configfilename, cfl->line,
  						ifc->server_pref);
--- 225,231 ----
  				ifc->server_pref = (int)cfl->num;
  				if (ifc->server_pref < 0 ||
  				    ifc->server_pref > 255) {
! 					debug_printf(LOG_INFO, FNAME, "%s:%d "
  						"bad value: %d",
  						configfilename, cfl->line,
  						ifc->server_pref);
***************
*** 234,246 ****
  				break;
  			case DECL_SCRIPT:
  				if (dhcp6_mode != DHCP6_MODE_CLIENT) {
! 					dprintf(LOG_INFO, FNAME, "%s:%d "
  						"client-only configuration",
  						configfilename, cfl->line);
  					goto bad;
  				}
  				if (ifc->scriptpath) {
! 					dprintf(LOG_INFO, FNAME,
  					    "%s:%d duplicated configuration",
  					    configfilename, cfl->line);
  					goto bad;
--- 234,246 ----
  				break;
  			case DECL_SCRIPT:
  				if (dhcp6_mode != DHCP6_MODE_CLIENT) {
! 					debug_printf(LOG_INFO, FNAME, "%s:%d "
  						"client-only configuration",
  						configfilename, cfl->line);
  					goto bad;
  				}
  				if (ifc->scriptpath) {
! 					debug_printf(LOG_INFO, FNAME,
  					    "%s:%d duplicated configuration",
  					    configfilename, cfl->line);
  					goto bad;
***************
*** 248,260 ****
  				cp = cfl->ptr;
  				ifc->scriptpath = strdup(cp + 1);
  				if (ifc->scriptpath == NULL) {
! 					dprintf(LOG_NOTICE, FNAME,
  					    "failed to copy script path");
  					goto bad;
  				}
  				cp = ifc->scriptpath;
  				if (*cp != '/') {
! 					dprintf(LOG_INFO, FNAME,
  					    "script must be an absolute path");
  					goto bad;
  				}
--- 248,260 ----
  				cp = cfl->ptr;
  				ifc->scriptpath = strdup(cp + 1);
  				if (ifc->scriptpath == NULL) {
! 					debug_printf(LOG_NOTICE, FNAME,
  					    "failed to copy script path");
  					goto bad;
  				}
  				cp = ifc->scriptpath;
  				if (*cp != '/') {
! 					debug_printf(LOG_INFO, FNAME,
  					    "script must be an absolute path");
  					goto bad;
  				}
***************
*** 272,278 ****
  						if (strcmp(spec->name, pool->name) == 0)
  							break;
  					if (pool == NULL) {
! 						dprintf(LOG_ERR, FNAME, "%s:%d "
  							"pool '%s' not found",
  							configfilename, cfl->line,
  					   		spec->name);
--- 272,278 ----
  						if (strcmp(spec->name, pool->name) == 0)
  							break;
  					if (pool == NULL) {
! 						debug_printf(LOG_ERR, FNAME, "%s:%d "
  							"pool '%s' not found",
  							configfilename, cfl->line,
  					   		spec->name);
***************
*** 281,287 ****
  					if (spec->vltime != DHCP6_DURATION_INFINITE &&
  						(spec->pltime == DHCP6_DURATION_INFINITE ||
  						spec->pltime > spec->vltime)) {
! 						dprintf(LOG_ERR, FNAME, "%s:%d ",
  							configfilename, cfl->line,
  							"specified a larger preferred lifetime "
  							"than valid lifetime");
--- 281,287 ----
  					if (spec->vltime != DHCP6_DURATION_INFINITE &&
  						(spec->pltime == DHCP6_DURATION_INFINITE ||
  						spec->pltime > spec->vltime)) {
! 						debug_printf(LOG_ERR, FNAME, "%s:%d ",
  							configfilename, cfl->line,
  							"specified a larger preferred lifetime "
  							"than valid lifetime");
***************
*** 289,305 ****
  					}
  					ifc->pool = *spec;
  					if ((ifc->pool.name = strdup(spec->name)) == NULL) {
! 						dprintf(LOG_ERR, FNAME,
  							"memory allocation failed");
  						goto bad;
  					}
! 					dprintf(LOG_DEBUG, FNAME,
  						"pool '%s' is specified to the interface '%s'",
  						ifc->pool.name, ifc->ifname);
  				}
  				break;
  			default:
! 				dprintf(LOG_ERR, FNAME, "%s:%d "
  					"invalid interface configuration",
  					configfilename, cfl->line);
  				goto bad;
--- 289,305 ----
  					}
  					ifc->pool = *spec;
  					if ((ifc->pool.name = strdup(spec->name)) == NULL) {
! 						debug_printf(LOG_ERR, FNAME,
  							"memory allocation failed");
  						goto bad;
  					}
! 					debug_printf(LOG_DEBUG, FNAME,
  						"pool '%s' is specified to the interface '%s'",
  						ifc->pool.name, ifc->ifname);
  				}
  				break;
  			default:
! 				debug_printf(LOG_ERR, FNAME, "%s:%d "
  					"invalid interface configuration",
  					configfilename, cfl->line);
  				goto bad;
***************
*** 338,344 ****
  		confsize = sizeof(struct iana_conf);
  		break;
  	default:
! 		dprintf(LOG_ERR, FNAME, "internal error");
  		goto bad;
  	}
  
--- 338,344 ----
  		confsize = sizeof(struct iana_conf);
  		break;
  	default:
! 		debug_printf(LOG_ERR, FNAME, "internal error");
  		goto bad;
  	}
  
***************
*** 346,352 ****
  		struct cf_list *cfl;
  
  		if ((iac = malloc(confsize)) == NULL) {
! 			dprintf(LOG_ERR, FNAME,
  			    "memory allocation for IA %s failed",
  			    iap->name);
  			goto bad;
--- 346,352 ----
  		struct cf_list *cfl;
  
  		if ((iac = malloc(confsize)) == NULL) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "memory allocation for IA %s failed",
  			    iap->name);
  			goto bad;
***************
*** 386,398 ****
  					if (add_prefix(&pdp->iapd_prefix_list,
  					    "IAPD", DHCP6_LISTVAL_PREFIX6,
  					    cfl->ptr)) {
! 						dprintf(LOG_NOTICE, FNAME, "failed "
  							"to configure prefix");
  						goto bad;
  					}
  					break;
  				default:
! 					dprintf(LOG_ERR, FNAME, "%s:%d "
  					    "invalid configuration",
  					    configfilename, cfl->line);
  					goto bad;
--- 386,398 ----
  					if (add_prefix(&pdp->iapd_prefix_list,
  					    "IAPD", DHCP6_LISTVAL_PREFIX6,
  					    cfl->ptr)) {
! 						debug_printf(LOG_NOTICE, FNAME, "failed "
  							"to configure prefix");
  						goto bad;
  					}
  					break;
  				default:
! 					debug_printf(LOG_ERR, FNAME, "%s:%d "
  					    "invalid configuration",
  					    configfilename, cfl->line);
  					goto bad;
***************
*** 404,423 ****
  					if (add_prefix(&nap->iana_address_list,
  					    "IANA", DHCP6_LISTVAL_STATEFULADDR6,
  					    cfl->ptr)) {
! 						dprintf(LOG_NOTICE, FNAME, "failed "
  							"to configure address");
  						goto bad;
  					}
  					break;
  				default:
! 					dprintf(LOG_ERR, FNAME, "%s:%d "
  					    "invalid configuration",
  					    configfilename, cfl->line);
  					goto bad;
  				}
  				break;
  			default:
! 				dprintf(LOG_ERR, FNAME, "%s:%d "
  				    "invalid iatype %d",
  				    configfilename, cfl->line, iatype);
  				goto bad;
--- 404,423 ----
  					if (add_prefix(&nap->iana_address_list,
  					    "IANA", DHCP6_LISTVAL_STATEFULADDR6,
  					    cfl->ptr)) {
! 						debug_printf(LOG_NOTICE, FNAME, "failed "
  							"to configure address");
  						goto bad;
  					}
  					break;
  				default:
! 					debug_printf(LOG_ERR, FNAME, "%s:%d "
  					    "invalid configuration",
  					    configfilename, cfl->line);
  					goto bad;
  				}
  				break;
  			default:
! 				debug_printf(LOG_ERR, FNAME, "%s:%d "
  				    "invalid iatype %d",
  				    configfilename, cfl->line, iatype);
  				goto bad;
***************
*** 443,449 ****
  	for (pif = TAILQ_FIRST(&iapdc->iapd_pif_list); pif;
  	    pif = TAILQ_NEXT(pif, link)) {
  		if (strcmp(pif->ifname, cfl0->ptr) == 0) {
! 			dprintf(LOG_NOTICE, FNAME, "%s:%d "
  			    "duplicated prefix interface: %s",
  			    configfilename, cfl0->line, cfl0->ptr);
  			return (0); /* ignore it */
--- 443,449 ----
  	for (pif = TAILQ_FIRST(&iapdc->iapd_pif_list); pif;
  	    pif = TAILQ_NEXT(pif, link)) {
  		if (strcmp(pif->ifname, cfl0->ptr) == 0) {
! 			debug_printf(LOG_NOTICE, FNAME, "%s:%d "
  			    "duplicated prefix interface: %s",
  			    configfilename, cfl0->line, cfl0->ptr);
  			return (0); /* ignore it */
***************
*** 451,457 ****
  	}
  
  	if ((pif = malloc(sizeof(*pif))) == NULL) {
! 		dprintf(LOG_ERR, FNAME,
  		    "memory allocation for %s failed", cfl0->ptr);
  		goto bad;
  	}
--- 451,457 ----
  	}
  
  	if ((pif = malloc(sizeof(*pif))) == NULL) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "memory allocation for %s failed", cfl0->ptr);
  		goto bad;
  	}
***************
*** 459,478 ****
  
  	/* validate and copy ifname */
  	if (if_nametoindex(cfl0->ptr) == 0) {
! 		dprintf(LOG_ERR, FNAME, "%s:%d invalid interface (%s): %s",
  		    configfilename, cfl0->line,
  		    cfl0->ptr, strerror(errno));
  		goto bad;
  	}
  	if ((pif->ifname = strdup(cfl0->ptr)) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy ifname");
  		goto bad;
  	}
  
  	pif->ifid_len = IFID_LEN_DEFAULT;
  	pif->sla_len = SLA_LEN_DEFAULT;
  	if (get_default_ifid(pif)) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to get default IF ID for %s", pif->ifname);
  		goto bad;
  	}
--- 459,478 ----
  
  	/* validate and copy ifname */
  	if (if_nametoindex(cfl0->ptr) == 0) {
! 		debug_printf(LOG_ERR, FNAME, "%s:%d invalid interface (%s): %s",
  		    configfilename, cfl0->line,
  		    cfl0->ptr, strerror(errno));
  		goto bad;
  	}
  	if ((pif->ifname = strdup(cfl0->ptr)) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy ifname");
  		goto bad;
  	}
  
  	pif->ifid_len = IFID_LEN_DEFAULT;
  	pif->sla_len = SLA_LEN_DEFAULT;
  	if (get_default_ifid(pif)) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to get default IF ID for %s", pif->ifname);
  		goto bad;
  	}
***************
*** 485,498 ****
  		case IFPARAM_SLA_LEN:
  			pif->sla_len = (int)cfl->num;
  			if (pif->sla_len < 0 || pif->sla_len > 128) {
! 				dprintf(LOG_ERR, FNAME, "%s:%d "
  				    "invalid SLA length: %d",
  				    configfilename, cfl->line, pif->sla_len); 
  				goto bad;
  			}
  			break;
  		default:
! 			dprintf(LOG_ERR, FNAME, "%s:%d internal error: "
  			    "invalid configuration",
  			    configfilename, cfl->line);
  			goto bad;
--- 485,498 ----
  		case IFPARAM_SLA_LEN:
  			pif->sla_len = (int)cfl->num;
  			if (pif->sla_len < 0 || pif->sla_len > 128) {
! 				debug_printf(LOG_ERR, FNAME, "%s:%d "
  				    "invalid SLA length: %d",
  				    configfilename, cfl->line, pif->sla_len); 
  				goto bad;
  			}
  			break;
  		default:
! 			debug_printf(LOG_ERR, FNAME, "%s:%d internal error: "
  			    "invalid configuration",
  			    configfilename, cfl->line);
  			goto bad;
***************
*** 520,526 ****
  		struct cf_list *cfl;
  
  		if ((hconf = malloc(sizeof(*hconf))) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "memory allocation failed "
  				"for host %s", host->name);
  			goto bad;
  		}
--- 520,526 ----
  		struct cf_list *cfl;
  
  		if ((hconf = malloc(sizeof(*hconf))) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "memory allocation failed "
  				"for host %s", host->name);
  			goto bad;
  		}
***************
*** 531,537 ****
  		host_conflist0 = hconf;
  
  		if ((hconf->name = strdup(host->name)) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "failed to copy host name: %s",
  			    host->name);
  			goto bad;
  		}
--- 531,537 ----
  		host_conflist0 = hconf;
  
  		if ((hconf->name = strdup(host->name)) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "failed to copy host name: %s",
  			    host->name);
  			goto bad;
  		}
***************
*** 540,546 ****
  			switch(cfl->type) {
  			case DECL_DUID:
  				if (hconf->duid.duid_id) {
! 					dprintf(LOG_ERR, FNAME, "%s:%d "
  					    "duplicated DUID for %s",
  					    configfilename,
  					    cfl->line, host->name);
--- 540,546 ----
  			switch(cfl->type) {
  			case DECL_DUID:
  				if (hconf->duid.duid_id) {
! 					debug_printf(LOG_ERR, FNAME, "%s:%d "
  					    "duplicated DUID for %s",
  					    configfilename,
  					    cfl->line, host->name);
***************
*** 548,561 ****
  				}
  				if ((configure_duid((char *)cfl->ptr,
  						    &hconf->duid)) != 0) {
! 					dprintf(LOG_ERR, FNAME, "%s:%d "
  					    "failed to configure "
  					    "DUID for %s",
  					    configfilename, cfl->line,
  					    host->name);
  					goto bad;
  				}
! 				dprintf(LOG_DEBUG, FNAME,
  				    "configure DUID for %s: %s",
  				    host->name, duidstr(&hconf->duid));
  				break;
--- 548,561 ----
  				}
  				if ((configure_duid((char *)cfl->ptr,
  						    &hconf->duid)) != 0) {
! 					debug_printf(LOG_ERR, FNAME, "%s:%d "
  					    "failed to configure "
  					    "DUID for %s",
  					    configfilename, cfl->line,
  					    host->name);
  					goto bad;
  				}
! 				debug_printf(LOG_DEBUG, FNAME,
  				    "configure DUID for %s: %s",
  				    host->name, duidstr(&hconf->duid));
  				break;
***************
*** 563,569 ****
  				if (add_prefix(&hconf->prefix_list,
  				    hconf->name, DHCP6_LISTVAL_PREFIX6,
  				    cfl->ptr)) {
! 					dprintf(LOG_ERR, FNAME, "failed "
  					    "to configure prefix for %s",
  					    host->name);
  					goto bad;
--- 563,569 ----
  				if (add_prefix(&hconf->prefix_list,
  				    hconf->name, DHCP6_LISTVAL_PREFIX6,
  				    cfl->ptr)) {
! 					debug_printf(LOG_ERR, FNAME, "failed "
  					    "to configure prefix for %s",
  					    host->name);
  					goto bad;
***************
*** 573,579 ****
  				if (add_prefix(&hconf->addr_list,
  				    hconf->name, DHCP6_LISTVAL_STATEFULADDR6,
  				    cfl->ptr)) {
! 					dprintf(LOG_ERR, FNAME, "failed "
  					    "to configure address for %s",
  					    host->name);
  					goto bad;
--- 573,579 ----
  				if (add_prefix(&hconf->addr_list,
  				    hconf->name, DHCP6_LISTVAL_STATEFULADDR6,
  				    cfl->ptr)) {
! 					debug_printf(LOG_ERR, FNAME, "failed "
  					    "to configure address for %s",
  					    host->name);
  					goto bad;
***************
*** 581,587 ****
  				break;
  			case DECL_DELAYEDKEY:
  				if (hconf->delayedkey != NULL) {
! 					dprintf(LOG_WARNING, FNAME,
  					    "%s:%d: duplicate key %s for %s"
  					    " (ignored)", configfilename,
  					    cfl->line, cfl->ptr, host->name);
--- 581,587 ----
  				break;
  			case DECL_DELAYEDKEY:
  				if (hconf->delayedkey != NULL) {
! 					debug_printf(LOG_WARNING, FNAME,
  					    "%s:%d: duplicate key %s for %s"
  					    " (ignored)", configfilename,
  					    cfl->line, cfl->ptr, host->name);
***************
*** 590,601 ****
  				if ((hconf->delayedkey =
  				    find_keybyname(key_list0, cfl->ptr))
  				    == NULL) {
! 					dprintf(LOG_ERR, FNAME, "failed to "
  					    "find key information for %s",
  					    cfl->ptr);
  					goto bad;
  				}
! 				dprintf(LOG_DEBUG, FNAME, "configure key for "
  				    "delayed auth with %s (keyid=%08x)",
  				    host->name, hconf->delayedkey->keyid);
  				break;
--- 590,601 ----
  				if ((hconf->delayedkey =
  				    find_keybyname(key_list0, cfl->ptr))
  				    == NULL) {
! 					debug_printf(LOG_ERR, FNAME, "failed to "
  					    "find key information for %s",
  					    cfl->ptr);
  					goto bad;
  				}
! 				debug_printf(LOG_DEBUG, FNAME, "configure key for "
  				    "delayed auth with %s (keyid=%08x)",
  				    host->name, hconf->delayedkey->keyid);
  				break;
***************
*** 610,616 ****
  						if (strcmp(spec->name, pool->name) == 0)
  							break;
  					if (pool == NULL) {
! 						dprintf(LOG_ERR, FNAME, "%s:%d "
  							"pool '%s' not found",
  							configfilename, cfl->line,
  					   		spec->name);
--- 610,616 ----
  						if (strcmp(spec->name, pool->name) == 0)
  							break;
  					if (pool == NULL) {
! 						debug_printf(LOG_ERR, FNAME, "%s:%d "
  							"pool '%s' not found",
  							configfilename, cfl->line,
  					   		spec->name);
***************
*** 619,625 ****
  					if (spec->vltime != DHCP6_DURATION_INFINITE &&
  						(spec->pltime == DHCP6_DURATION_INFINITE ||
  						spec->pltime > spec->vltime)) {
! 						dprintf(LOG_ERR, FNAME, "%s:%d ",
  							configfilename, cfl->line,
  							"specified a larger preferred lifetime "
  							"than valid lifetime");
--- 619,625 ----
  					if (spec->vltime != DHCP6_DURATION_INFINITE &&
  						(spec->pltime == DHCP6_DURATION_INFINITE ||
  						spec->pltime > spec->vltime)) {
! 						debug_printf(LOG_ERR, FNAME, "%s:%d ",
  							configfilename, cfl->line,
  							"specified a larger preferred lifetime "
  							"than valid lifetime");
***************
*** 627,643 ****
  					}
  					hconf->pool = *spec;
  					if ((hconf->pool.name = strdup(spec->name)) == NULL) {
! 						dprintf(LOG_ERR, FNAME,
  							"memory allocation failed");
  						goto bad;
  					}
! 					dprintf(LOG_DEBUG, FNAME,
  						"pool '%s' is specified to the host '%s'",
  						hconf->pool.name, hconf->name);
  				}
  				break;
  			default:
! 				dprintf(LOG_ERR, FNAME, "%s:%d "
  				    "invalid host configuration for %s",
  				    configfilename, cfl->line,
  				    host->name);
--- 627,643 ----
  					}
  					hconf->pool = *spec;
  					if ((hconf->pool.name = strdup(spec->name)) == NULL) {
! 						debug_printf(LOG_ERR, FNAME,
  							"memory allocation failed");
  						goto bad;
  					}
! 					debug_printf(LOG_DEBUG, FNAME,
  						"pool '%s' is specified to the host '%s'",
  						hconf->pool.name, hconf->name);
  				}
  				break;
  			default:
! 				debug_printf(LOG_ERR, FNAME, "%s:%d "
  				    "invalid host configuration for %s",
  				    configfilename, cfl->line,
  				    host->name);
***************
*** 669,675 ****
  		struct cf_list *cfl;
  
  		if ((kinfo = malloc(sizeof(*kinfo))) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "memory allocation failed "
  				"for key %s", key->name);
  			goto bad;
  		}
--- 669,675 ----
  		struct cf_list *cfl;
  
  		if ((kinfo = malloc(sizeof(*kinfo))) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "memory allocation failed "
  				"for key %s", key->name);
  			goto bad;
  		}
***************
*** 678,684 ****
  		key_list0 = kinfo;
  
  		if ((kinfo->name = strdup(key->name)) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "failed to copy key name: %s",
  			    key->name);
  			goto bad;
  		}
--- 678,684 ----
  		key_list0 = kinfo;
  
  		if ((kinfo->name = strdup(key->name)) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "failed to copy key name: %s",
  			    key->name);
  			goto bad;
  		}
***************
*** 689,695 ****
  			switch (cfl->type) {
  			case KEYPARAM_REALM:
  				if (kinfo->realm != NULL) {
! 					dprintf(LOG_WARNING, FNAME,
  					    "%s:%d duplicate realm for key %s "
  					    "(ignored)", configfilename,
  					    cfl->line, key->name);
--- 689,695 ----
  			switch (cfl->type) {
  			case KEYPARAM_REALM:
  				if (kinfo->realm != NULL) {
! 					debug_printf(LOG_WARNING, FNAME,
  					    "%s:%d duplicate realm for key %s "
  					    "(ignored)", configfilename,
  					    cfl->line, key->name);
***************
*** 697,703 ****
  				}
  				kinfo->realm = qstrdup(cfl->ptr);
  				if (kinfo->realm == NULL) {
! 					dprintf(LOG_WARNING, FNAME,
  					    "failed to allocate memory for "
  					    "realm");
  					goto bad;
--- 697,703 ----
  				}
  				kinfo->realm = qstrdup(cfl->ptr);
  				if (kinfo->realm == NULL) {
! 					debug_printf(LOG_WARNING, FNAME,
  					    "failed to allocate memory for "
  					    "realm");
  					goto bad;
***************
*** 706,712 ****
  				break;
  			case KEYPARAM_KEYID:
  				if (keyid != -1) {
! 					dprintf(LOG_WARNING, FNAME,
  					    "%s:%d duplicate realm for key %s "
  					    "(ignored)",
  					    configfilename, cfl->line);
--- 706,712 ----
  				break;
  			case KEYPARAM_KEYID:
  				if (keyid != -1) {
! 					debug_printf(LOG_WARNING, FNAME,
  					    "%s:%d duplicate realm for key %s "
  					    "(ignored)",
  					    configfilename, cfl->line);
***************
*** 714,720 ****
  				}
  				keyid = cfl->num;
  				if (keyid < 0 || keyid > 0xffffffff) {
! 					dprintf(LOG_WARNING, FNAME,
  					    "%s:%d key ID overflow",
  					     configfilename, cfl->line);
  					goto bad;
--- 714,720 ----
  				}
  				keyid = cfl->num;
  				if (keyid < 0 || keyid > 0xffffffff) {
! 					debug_printf(LOG_WARNING, FNAME,
  					    "%s:%d key ID overflow",
  					     configfilename, cfl->line);
  					goto bad;
***************
*** 723,729 ****
  			case KEYPARAM_SECRET:
  				/* duplicate check */
  				if (kinfo->secret != NULL) {
! 					dprintf(LOG_WARNING, FNAME,
  					    "%s:%d duplicate secret "
  					    "for key %s (ignored)",
  					    configfilename, cfl->line,
--- 723,729 ----
  			case KEYPARAM_SECRET:
  				/* duplicate check */
  				if (kinfo->secret != NULL) {
! 					debug_printf(LOG_WARNING, FNAME,
  					    "%s:%d duplicate secret "
  					    "for key %s (ignored)",
  					    configfilename, cfl->line,
***************
*** 733,739 ****
  
  				/* convert base64 string to binary secret */
  				if ((secretstr = qstrdup(cfl->ptr)) == NULL) {
! 					dprintf(LOG_WARNING, FNAME,
  					    "failed to make a copy of secret");
  					goto bad;
  				}
--- 733,739 ----
  
  				/* convert base64 string to binary secret */
  				if ((secretstr = qstrdup(cfl->ptr)) == NULL) {
! 					debug_printf(LOG_WARNING, FNAME,
  					    "failed to make a copy of secret");
  					goto bad;
  				}
***************
*** 741,747 ****
  				secretlen = base64_decodestring(secretstr,
  				    secret, sizeof(secret));
  				if (secretlen < 0) {
! 					dprintf(LOG_ERR, FNAME,
  					    "%s:%d failed to parse base64 key",
  					    configfilename, cfl->line);
  					free(secretstr);
--- 741,747 ----
  				secretlen = base64_decodestring(secretstr,
  				    secret, sizeof(secret));
  				if (secretlen < 0) {
! 					debug_printf(LOG_ERR, FNAME,
  					    "%s:%d failed to parse base64 key",
  					    configfilename, cfl->line);
  					free(secretstr);
***************
*** 752,758 ****
  				/* set the binary secret */
  				kinfo->secret = malloc(secretlen);
  				if (kinfo->secret == NULL) {
! 					dprintf(LOG_WARNING, FNAME,
  					    "failed to allocate memory "
  					    "for secret");
  					goto bad;
--- 752,758 ----
  				/* set the binary secret */
  				kinfo->secret = malloc(secretlen);
  				if (kinfo->secret == NULL) {
! 					debug_printf(LOG_WARNING, FNAME,
  					    "failed to allocate memory "
  					    "for secret");
  					goto bad;
***************
*** 762,768 ****
  				break;
  			case KEYPARAM_EXPIRE:
  				if (expire != NULL) {
! 					dprintf(LOG_WARNING, FNAME,
  					    "%s:%d duplicate expire for key "
  					    "%s (ignored)", configfilename,
  					    cfl->line, key->name);
--- 762,768 ----
  				break;
  			case KEYPARAM_EXPIRE:
  				if (expire != NULL) {
! 					debug_printf(LOG_WARNING, FNAME,
  					    "%s:%d duplicate expire for key "
  					    "%s (ignored)", configfilename,
  					    cfl->line, key->name);
***************
*** 771,777 ****
  				expire = qstrdup(cfl->ptr);
  				break;
  			default:
! 				dprintf(LOG_ERR, FNAME,
  				    "%s:%d invalid key parameter for %s",
  				    configfilename, cfl->line, key->name);
  				goto bad;
--- 771,777 ----
  				expire = qstrdup(cfl->ptr);
  				break;
  			default:
! 				debug_printf(LOG_ERR, FNAME,
  				    "%s:%d invalid key parameter for %s",
  				    configfilename, cfl->line, key->name);
  				goto bad;
***************
*** 780,797 ****
  
  		/* check for mandatory parameters or use default */
  		if (kinfo->realm == NULL) {
! 			dprintf(LOG_ERR, FNAME,
  			    "realm not specified for key %s", key->name);
  			goto bad;
  		}
  		if (keyid == -1) {
! 			dprintf(LOG_ERR, FNAME,
  			    "key ID not specified for key %s", key->name);
  			goto bad;
  		}
  		kinfo->keyid = keyid;
  		if (kinfo->secret == NULL) {
! 			dprintf(LOG_ERR, FNAME,
  			    "secret not specified for key %s", key->name);
  			goto bad;
  		}
--- 780,797 ----
  
  		/* check for mandatory parameters or use default */
  		if (kinfo->realm == NULL) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "realm not specified for key %s", key->name);
  			goto bad;
  		}
  		if (keyid == -1) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "key ID not specified for key %s", key->name);
  			goto bad;
  		}
  		kinfo->keyid = keyid;
  		if (kinfo->secret == NULL) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "secret not specified for key %s", key->name);
  			goto bad;
  		}
***************
*** 802,808 ****
  				struct tm *lt;
  
  				if (time(&now) == -1) {
! 					dprintf(LOG_ERR, FNAME, "cannot get "
  					    "current time: %s",
  					    strerror(errno));
  					goto bad;
--- 802,808 ----
  				struct tm *lt;
  
  				if (time(&now) == -1) {
! 					debug_printf(LOG_ERR, FNAME, "cannot get "
  					    "current time: %s",
  					    strerror(errno));
  					goto bad;
***************
*** 815,828 ****
  				    strptime(expire, "%m-%d %H:%M", lt)
  				    == NULL &&
  				    strptime(expire, "%H:%M", lt) == NULL) {
! 					dprintf(LOG_ERR, FNAME, "invalid "
  					    "expiration time: %s");
  					goto bad;
  				}
  
  				expire_time = mktime(lt);
  				if (expire_time < now) {
! 					dprintf(LOG_ERR, FNAME, "past "
  					    "expiration time specified: %s",
  					    expire);
  					goto bad;
--- 815,828 ----
  				    strptime(expire, "%m-%d %H:%M", lt)
  				    == NULL &&
  				    strptime(expire, "%H:%M", lt) == NULL) {
! 					debug_printf(LOG_ERR, FNAME, "invalid "
  					    "expiration time: %s");
  					goto bad;
  				}
  
  				expire_time = mktime(lt);
  				if (expire_time < now) {
! 					debug_printf(LOG_ERR, FNAME, "past "
  					    "expiration time specified: %s",
  					    expire);
  					goto bad;
***************
*** 867,873 ****
  		struct cf_list *cfl;
  
  		if ((ainfo = malloc(sizeof(*ainfo))) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "memory allocation failed "
  				"for auth info %s", auth->name);
  			goto bad;
  		}
--- 867,873 ----
  		struct cf_list *cfl;
  
  		if ((ainfo = malloc(sizeof(*ainfo))) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "memory allocation failed "
  				"for auth info %s", auth->name);
  			goto bad;
  		}
***************
*** 879,885 ****
  		ainfo->rdm = DHCP6_AUTHRDM_UNDEF;
  
  		if ((ainfo->name = strdup(auth->name)) == NULL) {
! 			dprintf(LOG_ERR, FNAME,
  			    "failed to copy auth info name: %s", auth->name);
  			goto bad;
  		}
--- 879,885 ----
  		ainfo->rdm = DHCP6_AUTHRDM_UNDEF;
  
  		if ((ainfo->name = strdup(auth->name)) == NULL) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "failed to copy auth info name: %s", auth->name);
  			goto bad;
  		}
***************
*** 888,894 ****
  			switch (cfl->type) {
  			case AUTHPARAM_PROTO:
  				if (ainfo->protocol != DHCP6_AUTHPROTO_UNDEF) {
! 					dprintf(LOG_WARNING, FNAME,
  					    "%s:%d duplicate protocol "
  					    "for auth info %s "
  					    "(ignored)",
--- 888,894 ----
  			switch (cfl->type) {
  			case AUTHPARAM_PROTO:
  				if (ainfo->protocol != DHCP6_AUTHPROTO_UNDEF) {
! 					debug_printf(LOG_WARNING, FNAME,
  					    "%s:%d duplicate protocol "
  					    "for auth info %s "
  					    "(ignored)",
***************
*** 900,906 ****
  				break;
  			case AUTHPARAM_ALG:
  				if (ainfo->algorithm != DHCP6_AUTHALG_UNDEF) {
! 					dprintf(LOG_WARNING, FNAME,
  					    "%s:%d duplicate algorithm "
  					    "for auth info %s "
  					    "(ignored)",
--- 900,906 ----
  				break;
  			case AUTHPARAM_ALG:
  				if (ainfo->algorithm != DHCP6_AUTHALG_UNDEF) {
! 					debug_printf(LOG_WARNING, FNAME,
  					    "%s:%d duplicate algorithm "
  					    "for auth info %s "
  					    "(ignored)",
***************
*** 912,918 ****
  				break;
  			case AUTHPARAM_RDM:
  				if (ainfo->rdm != DHCP6_AUTHRDM_UNDEF) {
! 					dprintf(LOG_WARNING, FNAME,
  					    "%s:%d duplicate RDM "
  					    "for auth info %s "
  					    "(ignored)",
--- 912,918 ----
  				break;
  			case AUTHPARAM_RDM:
  				if (ainfo->rdm != DHCP6_AUTHRDM_UNDEF) {
! 					debug_printf(LOG_WARNING, FNAME,
  					    "%s:%d duplicate RDM "
  					    "for auth info %s "
  					    "(ignored)",
***************
*** 923,935 ****
  				ainfo->rdm = (int)cfl->num;
  				break;
  			case AUTHPARAM_KEY:
! 				dprintf(LOG_WARNING, FNAME,
  				    "%s:%d auth info specific keys "
  				    "are not supported",
  				    configfilename, cfl->line);
  				break;
  			default:
! 				dprintf(LOG_ERR, FNAME,
  				    "%s:%d invalid auth info parameter for %s",
  				    configfilename, cfl->line, auth->name);
  				goto bad;
--- 923,935 ----
  				ainfo->rdm = (int)cfl->num;
  				break;
  			case AUTHPARAM_KEY:
! 				debug_printf(LOG_WARNING, FNAME,
  				    "%s:%d auth info specific keys "
  				    "are not supported",
  				    configfilename, cfl->line);
  				break;
  			default:
! 				debug_printf(LOG_ERR, FNAME,
  				    "%s:%d invalid auth info parameter for %s",
  				    configfilename, cfl->line, auth->name);
  				goto bad;
***************
*** 939,958 ****
  		/* check for mandatory parameters and consistency */
  		switch (ainfo->protocol) {
  		case DHCP6_AUTHPROTO_UNDEF:
! 			dprintf(LOG_ERR, FNAME,
  			    "auth protocol is not specified for %s",
  			    auth->name);
  			goto bad;
  		case DHCP6_AUTHPROTO_DELAYED:
  			if (dhcp6_mode != DHCP6_MODE_CLIENT) {
! 				dprintf(LOG_ERR, FNAME,
  				    "client-only auth protocol is specified");
  				goto bad;
  			}
  			break;
  		case DHCP6_AUTHPROTO_RECONFIG:
  			if (dhcp6_mode != DHCP6_MODE_SERVER) {
! 				dprintf(LOG_ERR, FNAME,
  				    "server-only auth protocol is specified");
  				goto bad;
  			}
--- 939,958 ----
  		/* check for mandatory parameters and consistency */
  		switch (ainfo->protocol) {
  		case DHCP6_AUTHPROTO_UNDEF:
! 			debug_printf(LOG_ERR, FNAME,
  			    "auth protocol is not specified for %s",
  			    auth->name);
  			goto bad;
  		case DHCP6_AUTHPROTO_DELAYED:
  			if (dhcp6_mode != DHCP6_MODE_CLIENT) {
! 				debug_printf(LOG_ERR, FNAME,
  				    "client-only auth protocol is specified");
  				goto bad;
  			}
  			break;
  		case DHCP6_AUTHPROTO_RECONFIG:
  			if (dhcp6_mode != DHCP6_MODE_SERVER) {
! 				debug_printf(LOG_ERR, FNAME,
  				    "server-only auth protocol is specified");
  				goto bad;
  			}
***************
*** 1039,1045 ****
  
  	/* check against configuration restriction */
  	if (cf_addr_list != NULL && dhcp6_mode != DHCP6_MODE_SERVER) {
! 		dprintf(LOG_INFO, FNAME, "%s:%d server-only configuration",
  		    configfilename, cf_addr_list->line);
  		return -1;
  	}
--- 1039,1045 ----
  
  	/* check against configuration restriction */
  	if (cf_addr_list != NULL && dhcp6_mode != DHCP6_MODE_SERVER) {
! 		debug_printf(LOG_INFO, FNAME, "%s:%d server-only configuration",
  		    configfilename, cf_addr_list->line);
  		return -1;
  	}
***************
*** 1049,1055 ****
  		/* duplication check */
  		if (dhcp6_find_listval(list0, DHCP6_LISTVAL_ADDR6,
  		    cl->ptr, 0)) {
! 			dprintf(LOG_INFO, FNAME,
  			    "%s:%d duplicated %s server: %s",
  			    configfilename, cl->line,
  			    optname,
--- 1049,1055 ----
  		/* duplication check */
  		if (dhcp6_find_listval(list0, DHCP6_LISTVAL_ADDR6,
  		    cl->ptr, 0)) {
! 			debug_printf(LOG_INFO, FNAME,
  			    "%s:%d duplicated %s server: %s",
  			    configfilename, cl->line,
  			    optname,
***************
*** 1058,1064 ****
  		}
  		if (dhcp6_add_listval(list0, DHCP6_LISTVAL_ADDR6,
  		    cl->ptr, NULL) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "failed to add a %s server",
  			    optname);
  			return -1;
  		}
--- 1058,1064 ----
  		}
  		if (dhcp6_add_listval(list0, DHCP6_LISTVAL_ADDR6,
  		    cl->ptr, NULL) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "failed to add a %s server",
  			    optname);
  			return -1;
  		}
***************
*** 1077,1083 ****
  
  	/* check against configuration restriction */
  	if (cf_name_list != NULL && dhcp6_mode != DHCP6_MODE_SERVER) {
! 		dprintf(LOG_INFO, FNAME, "%s:%d server-only configuration",
  		    configfilename, cf_name_list->line);
  		return -1;
  	}
--- 1077,1083 ----
  
  	/* check against configuration restriction */
  	if (cf_name_list != NULL && dhcp6_mode != DHCP6_MODE_SERVER) {
! 		debug_printf(LOG_INFO, FNAME, "%s:%d server-only configuration",
  		    configfilename, cf_name_list->line);
  		return -1;
  	}
***************
*** 1089,1095 ****
  
  		name = strdup(cl->ptr + 1);
  		if (name == NULL) {
! 			dprintf(LOG_ERR, FNAME,
  			    "failed to copy a %s domain name",
  			    optname);
  			return -1;
--- 1089,1095 ----
  
  		name = strdup(cl->ptr + 1);
  		if (name == NULL) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "failed to copy a %s domain name",
  			    optname);
  			return -1;
***************
*** 1103,1109 ****
  		/* duplication check */
  		if (dhcp6_find_listval(list0, DHCP6_LISTVAL_VBUF,
  		    &name_vbuf, 0)) {
! 			dprintf(LOG_INFO, FNAME,
  			    "%s:%d duplicated %s name: %s",
  			    configfilename, cl->line, optname,
  			    name_vbuf.dv_buf);
--- 1103,1109 ----
  		/* duplication check */
  		if (dhcp6_find_listval(list0, DHCP6_LISTVAL_VBUF,
  		    &name_vbuf, 0)) {
! 			debug_printf(LOG_INFO, FNAME,
  			    "%s:%d duplicated %s name: %s",
  			    configfilename, cl->line, optname,
  			    name_vbuf.dv_buf);
***************
*** 1114,1120 ****
  		/* add the name */
  		if (dhcp6_add_listval(list0, DHCP6_LISTVAL_VBUF,
  		    &name_vbuf, NULL) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "failed to add a %s name",
  			    optname);
  			dhcp6_vbuf_free(&name_vbuf);
  			return -1;
--- 1114,1120 ----
  		/* add the name */
  		if (dhcp6_add_listval(list0, DHCP6_LISTVAL_VBUF,
  		    &name_vbuf, NULL) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "failed to add a %s name",
  			    optname);
  			dhcp6_vbuf_free(&name_vbuf);
  			return -1;
***************
*** 1145,1156 ****
  		goto bad;
  	duidlen += (slen / 3);
  	if (duidlen > 128) {
! 		dprintf(LOG_ERR, FNAME, "too long DUID (%d)", duidlen);
  		return (-1);
  	}
  
  	if ((idbuf = malloc(duidlen)) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "memory allocation failed");
  		return (-1);
  	}
  
--- 1145,1156 ----
  		goto bad;
  	duidlen += (slen / 3);
  	if (duidlen > 128) {
! 		debug_printf(LOG_ERR, FNAME, "too long DUID (%d)", duidlen);
  		return (-1);
  	}
  
  	if ((idbuf = malloc(duidlen)) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "memory allocation failed");
  		return (-1);
  	}
  
***************
*** 1175,1181 ****
    bad:
  	if (idbuf)
  		free(idbuf);
! 	dprintf(LOG_ERR, FNAME, "assumption failure (bad string)");
  	return (-1);
  }
  
--- 1175,1181 ----
    bad:
  	if (idbuf)
  		free(idbuf);
! 	debug_printf(LOG_ERR, FNAME, "assumption failure (bad string)");
  	return (-1);
  }
  
***************
*** 1193,1204 ****
  #endif
  
  	if (pif->ifid_len < 64) {
! 		dprintf(LOG_NOTICE, FNAME, "ID length too short");
  		return (-1);
  	}
  
  	if (getifaddrs(&ifap) < 0) {
! 		dprintf(LOG_ERR, FNAME, "getifaddrs failed: %s",
  		    strerror(errno));
  		return (-1);
  	}
--- 1193,1204 ----
  #endif
  
  	if (pif->ifid_len < 64) {
! 		debug_printf(LOG_NOTICE, FNAME, "ID length too short");
  		return (-1);
  	}
  
  	if (getifaddrs(&ifap) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "getifaddrs failed: %s",
  		    strerror(errno));
  		return (-1);
  	}
***************
*** 1218,1224 ****
  
  		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
  		if (sdl->sdl_alen < 6) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "link layer address is too short (%s)",
  			    pif->ifname);
  			goto fail;
--- 1218,1224 ----
  
  		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
  		if (sdl->sdl_alen < 6) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "link layer address is too short (%s)",
  			    pif->ifname);
  			goto fail;
***************
*** 1233,1239 ****
  
  		sll = (struct sockaddr_ll *)ifa->ifa_addr;
  		if (sll->sll_halen < 6) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "link layer address is too short (%s)",
  			    pif->ifname);
  			goto fail;
--- 1233,1239 ----
  
  		sll = (struct sockaddr_ll *)ifa->ifa_addr;
  		if (sll->sll_halen < 6) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "link layer address is too short (%s)",
  			    pif->ifname);
  			goto fail;
***************
*** 1256,1262 ****
  	}
  
  	if (ifa == NULL) {
! 		dprintf(LOG_INFO, FNAME,
  		    "cannot find interface information for %s", pif->ifname);
  		goto fail;
  	}
--- 1256,1262 ----
  	}
  
  	if (ifa == NULL) {
! 		debug_printf(LOG_INFO, FNAME,
  		    "cannot find interface information for %s", pif->ifname);
  		goto fail;
  	}
***************
*** 1352,1358 ****
  
  	/* clear unused IA configuration */
  	if (!TAILQ_EMPTY(&ia_conflist0)) {
! 		dprintf(LOG_INFO, FNAME,
  		    "some IA configuration defined but not used");
  	}
  	clear_iaconf(&ia_conflist0);
--- 1352,1358 ----
  
  	/* clear unused IA configuration */
  	if (!TAILQ_EMPTY(&ia_conflist0)) {
! 		debug_printf(LOG_INFO, FNAME,
  		    "some IA configuration defined but not used");
  	}
  	clear_iaconf(&ia_conflist0);
***************
*** 1475,1481 ****
  		switch(iac->type) {
  		case IATYPE_PD:
  			if (!TAILQ_EMPTY(&iac->iadata)) {
! 				dprintf(LOG_ERR, FNAME, "assumption failure");
  				exit(1);
  			}
  			clear_pd_pif((struct iapd_conf *)iac);
--- 1475,1481 ----
  		switch(iac->type) {
  		case IATYPE_PD:
  			if (!TAILQ_EMPTY(&iac->iadata)) {
! 				debug_printf(LOG_ERR, FNAME, "assumption failure");
  				exit(1);
  			}
  			clear_pd_pif((struct iapd_conf *)iac);
***************
*** 1557,1563 ****
  				ifc->allow_flags |= DHCIFF_RAPID_COMMIT;
  				break;
  			default:
! 				dprintf(LOG_ERR, FNAME,
  				    "invalid operation (%d) "
  				    "for option type (%d)",
  				    opcode, cfl->type);
--- 1557,1563 ----
  				ifc->allow_flags |= DHCIFF_RAPID_COMMIT;
  				break;
  			default:
! 				debug_printf(LOG_ERR, FNAME,
  				    "invalid operation (%d) "
  				    "for option type (%d)",
  				    opcode, cfl->type);
***************
*** 1566,1572 ****
  			break;
  		case DHCPOPT_AUTHINFO:
  			if (opcode != DHCPOPTCODE_SEND) {
! 				dprintf(LOG_ERR, FNAME,
  				    "invalid operation (%d) "
  				    "for option type (%d)",
  				    opcode, cfl->type);
--- 1566,1572 ----
  			break;
  		case DHCPOPT_AUTHINFO:
  			if (opcode != DHCPOPTCODE_SEND) {
! 				debug_printf(LOG_ERR, FNAME,
  				    "invalid operation (%d) "
  				    "for option type (%d)",
  				    opcode, cfl->type);
***************
*** 1574,1587 ****
  			}
  			ainfo = find_authinfo(auth_list0, cfl->ptr);
  			if (ainfo == NULL) {
! 				dprintf(LOG_ERR, FNAME, "%s:%d "
  				    "auth info (%s) is not defined",
  				    configfilename, cfl->line,
  				    (char *)cfl->ptr);
  				return (-1);
  			}
  			if (ifc->authinfo != NULL) {
! 				dprintf(LOG_ERR, FNAME,
  				    "%s:%d authinfo is doubly specified on %s",
  				    configfilename, cfl->line, ifc->ifname);
  				return (-1);
--- 1574,1587 ----
  			}
  			ainfo = find_authinfo(auth_list0, cfl->ptr);
  			if (ainfo == NULL) {
! 				debug_printf(LOG_ERR, FNAME, "%s:%d "
  				    "auth info (%s) is not defined",
  				    configfilename, cfl->line,
  				    (char *)cfl->ptr);
  				return (-1);
  			}
  			if (ifc->authinfo != NULL) {
! 				debug_printf(LOG_ERR, FNAME,
  				    "%s:%d authinfo is doubly specified on %s",
  				    configfilename, cfl->line, ifc->ifname);
  				return (-1);
***************
*** 1594,1600 ****
  				iac = find_iaconf(&ia_conflist0, IATYPE_PD,
  				    (u_int32_t)cfl->num);
  				if (iac == NULL) {
! 					dprintf(LOG_ERR, FNAME, "%s:%d "
  					    "IA_PD (%lu) is not defined",
  					    configfilename, cfl->line,
  					    (u_long)cfl->num);
--- 1594,1600 ----
  				iac = find_iaconf(&ia_conflist0, IATYPE_PD,
  				    (u_int32_t)cfl->num);
  				if (iac == NULL) {
! 					debug_printf(LOG_ERR, FNAME, "%s:%d "
  					    "IA_PD (%lu) is not defined",
  					    configfilename, cfl->line,
  					    (u_long)cfl->num);
***************
*** 1607,1613 ****
  
  				break;
  			default:
! 				dprintf(LOG_ERR, FNAME,
  				    "invalid operation (%d) "
  				    "for option type (%d)", opcode, cfl->type);
  				break;
--- 1607,1613 ----
  
  				break;
  			default:
! 				debug_printf(LOG_ERR, FNAME,
  				    "invalid operation (%d) "
  				    "for option type (%d)", opcode, cfl->type);
  				break;
***************
*** 1619,1625 ****
  				iac = find_iaconf(&ia_conflist0, IATYPE_NA,
  				    (u_int32_t)cfl->num);
  				if (iac == NULL) {
! 					dprintf(LOG_ERR, FNAME, "%s:%d "
  					    "IA_NA (%lu) is not defined",
  					    configfilename, cfl->line,
  					    (u_long)cfl->num);
--- 1619,1625 ----
  				iac = find_iaconf(&ia_conflist0, IATYPE_NA,
  				    (u_int32_t)cfl->num);
  				if (iac == NULL) {
! 					debug_printf(LOG_ERR, FNAME, "%s:%d "
  					    "IA_NA (%lu) is not defined",
  					    configfilename, cfl->line,
  					    (u_long)cfl->num);
***************
*** 1632,1638 ****
  
  				break;
  			default:
! 				dprintf(LOG_ERR, FNAME,
  				    "invalid operation (%d) "
  				    "for option type (%d)", opcode, cfl->type);
  				break;
--- 1632,1638 ----
  
  				break;
  			default:
! 				debug_printf(LOG_ERR, FNAME,
  				    "invalid operation (%d) "
  				    "for option type (%d)", opcode, cfl->type);
  				break;
***************
*** 1693,1699 ****
  				if (dhcp6_find_listval(&ifc->reqopt_list,
  					DHCP6_LISTVAL_NUM, &opttype, 0)
  				    != NULL) {
! 					dprintf(LOG_INFO, FNAME,
  					    "duplicated requested option: %s",
  					    dhcp6optstr(opttype));
  					goto next; /* ignore it */
--- 1693,1699 ----
  				if (dhcp6_find_listval(&ifc->reqopt_list,
  					DHCP6_LISTVAL_NUM, &opttype, 0)
  				    != NULL) {
! 					debug_printf(LOG_INFO, FNAME,
  					    "duplicated requested option: %s",
  					    dhcp6optstr(opttype));
  					goto next; /* ignore it */
***************
*** 1701,1720 ****
  				if (dhcp6_add_listval(&ifc->reqopt_list,
  				    DHCP6_LISTVAL_NUM, &opttype, NULL)
  				    == NULL) {
! 					dprintf(LOG_ERR, FNAME, "failed to "
  					    "configure an option");
  					return (-1);
  				}
  				break;
  			default:
! 				dprintf(LOG_ERR, FNAME,
  				    "invalid operation (%d) "
  				    "for option type (%d)", opcode, cfl->type);
  				break;
  			}
  			break;
  		default:
! 			dprintf(LOG_ERR, FNAME,
  			    "%s:%d unsupported option type: %d",
  			    configfilename, cfl->line, cfl->type);
  			return (-1);
--- 1701,1720 ----
  				if (dhcp6_add_listval(&ifc->reqopt_list,
  				    DHCP6_LISTVAL_NUM, &opttype, NULL)
  				    == NULL) {
! 					debug_printf(LOG_ERR, FNAME, "failed to "
  					    "configure an option");
  					return (-1);
  				}
  				break;
  			default:
! 				debug_printf(LOG_ERR, FNAME,
  				    "invalid operation (%d) "
  				    "for option type (%d)", opcode, cfl->type);
  				break;
  			}
  			break;
  		default:
! 			debug_printf(LOG_ERR, FNAME,
  			    "%s:%d unsupported option type: %d",
  			    configfilename, cfl->line, cfl->type);
  			return (-1);
***************
*** 1740,1752 ****
  
  	/* additional validation of parameters */
  	if (oprefix.plen < 0 || oprefix.plen > 128) {
! 		dprintf(LOG_ERR, FNAME, "invalid prefix: %d", oprefix.plen);
  		return (-1);
  	}
  	/* clear trailing bits */
  	prefix6_mask(&oprefix.addr, oprefix.plen);
  	if (!IN6_ARE_ADDR_EQUAL(&prefix0->addr, &oprefix.addr)) {
! 		dprintf(LOG_WARNING, FNAME, "prefix %s/%d for %s "
  		    "has a trailing garbage.  It should be %s/%d",
  		    in6addr2str(&prefix0->addr, 0), prefix0->plen,
  		    name, in6addr2str(&oprefix.addr, 0), oprefix.plen);
--- 1740,1752 ----
  
  	/* additional validation of parameters */
  	if (oprefix.plen < 0 || oprefix.plen > 128) {
! 		debug_printf(LOG_ERR, FNAME, "invalid prefix: %d", oprefix.plen);
  		return (-1);
  	}
  	/* clear trailing bits */
  	prefix6_mask(&oprefix.addr, oprefix.plen);
  	if (!IN6_ARE_ADDR_EQUAL(&prefix0->addr, &oprefix.addr)) {
! 		debug_printf(LOG_WARNING, FNAME, "prefix %s/%d for %s "
  		    "has a trailing garbage.  It should be %s/%d",
  		    in6addr2str(&prefix0->addr, 0), prefix0->plen,
  		    name, in6addr2str(&oprefix.addr, 0), oprefix.plen);
***************
*** 1757,1763 ****
  	if (IN6_IS_ADDR_MULTICAST(&oprefix.addr) ||
  	    IN6_IS_ADDR_LINKLOCAL(&oprefix.addr) ||
  	    IN6_IS_ADDR_SITELOCAL(&oprefix.addr)) {
! 		dprintf(LOG_ERR, FNAME, "invalid prefix address: %s",
  		    in6addr2str(&oprefix.addr, 0));
  		return (-1);
  	}
--- 1757,1763 ----
  	if (IN6_IS_ADDR_MULTICAST(&oprefix.addr) ||
  	    IN6_IS_ADDR_LINKLOCAL(&oprefix.addr) ||
  	    IN6_IS_ADDR_SITELOCAL(&oprefix.addr)) {
! 		debug_printf(LOG_ERR, FNAME, "invalid prefix address: %s",
  		    in6addr2str(&oprefix.addr, 0));
  		return (-1);
  	}
***************
*** 1765,1775 ****
  	/* prefix duplication check */
  	if (dhcp6_find_listval(head, type, &oprefix, 0)) {
  		if (type == DHCP6_LISTVAL_PREFIX6) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "duplicated prefix: %s/%d for %s",
  			    in6addr2str(&oprefix.addr, 0), oprefix.plen, name);
  		} else {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "duplicated address: %s for %s",
  			    in6addr2str(&oprefix.addr, 0), name);
  		}
--- 1765,1775 ----
  	/* prefix duplication check */
  	if (dhcp6_find_listval(head, type, &oprefix, 0)) {
  		if (type == DHCP6_LISTVAL_PREFIX6) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "duplicated prefix: %s/%d for %s",
  			    in6addr2str(&oprefix.addr, 0), oprefix.plen, name);
  		} else {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "duplicated address: %s for %s",
  			    in6addr2str(&oprefix.addr, 0), name);
  		}
***************
*** 1781,1792 ****
  	    (oprefix.pltime == DHCP6_DURATION_INFINITE ||
  	    oprefix.pltime > oprefix.vltime)) {
  		if (type == DHCP6_LISTVAL_PREFIX6) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "%s/%d has larger preferred lifetime "
  			    "than valid lifetime",
  			    in6addr2str(&oprefix.addr, 0), oprefix.plen);
  		} else {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "%s has larger preferred lifetime "
  			    "than valid lifetime",
  			    in6addr2str(&oprefix.addr, 0));
--- 1781,1792 ----
  	    (oprefix.pltime == DHCP6_DURATION_INFINITE ||
  	    oprefix.pltime > oprefix.vltime)) {
  		if (type == DHCP6_LISTVAL_PREFIX6) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "%s/%d has larger preferred lifetime "
  			    "than valid lifetime",
  			    in6addr2str(&oprefix.addr, 0), oprefix.plen);
  		} else {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "%s has larger preferred lifetime "
  			    "than valid lifetime",
  			    in6addr2str(&oprefix.addr, 0));
***************
*** 1915,1924 ****
  {
  	struct cf_namelist *plp;
  
! 	dprintf(LOG_DEBUG, FNAME, "called");
  
  	if (poollist && dhcp6_mode != DHCP6_MODE_SERVER) {
! 		dprintf(LOG_ERR, FNAME, "%s:%d "
  			"pool statement is server-only",
  			configfilename, poollist->line);
  		goto bad;
--- 1915,1924 ----
  {
  	struct cf_namelist *plp;
  
! 	debug_printf(LOG_DEBUG, FNAME, "called");
  
  	if (poollist && dhcp6_mode != DHCP6_MODE_SERVER) {
! 		debug_printf(LOG_ERR, FNAME, "%s:%d "
  			"pool statement is server-only",
  			configfilename, poollist->line);
  		goto bad;
***************
*** 1935,1941 ****
  				range = cfl->ptr;
  				break;
  			default:
! 				dprintf(LOG_ERR, FNAME, "%s:%d "
  					"invalid pool configuration",
  					configfilename, cfl->line);
  				goto bad;
--- 1935,1941 ----
  				range = cfl->ptr;
  				break;
  			default:
! 				debug_printf(LOG_ERR, FNAME, "%s:%d "
  					"invalid pool configuration",
  					configfilename, cfl->line);
  				goto bad;
***************
*** 1943,1956 ****
  		}
  
  		if (!range) {
! 			dprintf(LOG_ERR, FNAME, "%s:%d "
  				"pool '%s' has no range declaration",
  				configfilename, plp->line,
  				plp->name);
  			goto bad;
  		}
  		if ((pool = create_pool(plp->name, range)) == NULL) {
! 			dprintf(LOG_ERR, FNAME,
  				"faled to craete pool '%s'", plp->name);
  			goto bad;
  		}
--- 1943,1956 ----
  		}
  
  		if (!range) {
! 			debug_printf(LOG_ERR, FNAME, "%s:%d "
  				"pool '%s' has no range declaration",
  				configfilename, plp->line,
  				plp->name);
  			goto bad;
  		}
  		if ((pool = create_pool(plp->name, range)) == NULL) {
! 			debug_printf(LOG_ERR, FNAME,
  				"faled to craete pool '%s'", plp->name);
  			goto bad;
  		}
***************
*** 1971,1977 ****
  {
  	struct pool_conf *pool, *pool_next;
  
! 	dprintf(LOG_DEBUG, FNAME, "called");
  
  	for (pool = plist; pool; pool = pool_next) {
  		pool_next = pool->next;
--- 1971,1977 ----
  {
  	struct pool_conf *pool, *pool_next;
  
! 	debug_printf(LOG_DEBUG, FNAME, "called");
  
  	for (pool = plist; pool; pool = pool_next) {
  		pool_next = pool->next;
***************
*** 1999,2005 ****
  	if (dynamic_hostconf_count >= DHCP6_DYNAMIC_HOSTCONF_MAX) {
  		struct dynamic_hostconf_listhead *head = &dynamic_hostconf_head;
  
! 		dprintf(LOG_DEBUG, FNAME, "reached to the max count (count=%lu)",
  			dynamic_hostconf_count);
  
  		/* Find the last entry that doesn't need authentication */
--- 1999,2005 ----
  	if (dynamic_hostconf_count >= DHCP6_DYNAMIC_HOSTCONF_MAX) {
  		struct dynamic_hostconf_listhead *head = &dynamic_hostconf_head;
  
! 		debug_printf(LOG_DEBUG, FNAME, "reached to the max count (count=%lu)",
  			dynamic_hostconf_count);
  
  		/* Find the last entry that doesn't need authentication */
***************
*** 2013,2026 ****
  		clear_hostconf(dynconf->host);
  	} else {
  		if ((dynconf = malloc(sizeof(*dynconf))) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "memory allocation failed");
  			return (NULL);
  		}
  	}
  	memset(dynconf, 0, sizeof(*dynconf));
  
  	if ((host = malloc(sizeof(*host))) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "memory allocation failed");
  		goto bad;
  	}
  	memset(host, 0, sizeof(*host));
--- 2013,2026 ----
  		clear_hostconf(dynconf->host);
  	} else {
  		if ((dynconf = malloc(sizeof(*dynconf))) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "memory allocation failed");
  			return (NULL);
  		}
  	}
  	memset(dynconf, 0, sizeof(*dynconf));
  
  	if ((host = malloc(sizeof(*host))) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "memory allocation failed");
  		goto bad;
  	}
  	memset(host, 0, sizeof(*host));
***************
*** 2030,2036 ****
  	if ((strid = duidstr(duid)) == NULL)
  		strid = "???";
  	if ((host->name = strdup(strid)) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "memory allocation failed");
  		goto bad;
  	}
  	if (duidcpy(&host->duid, duid) != 0) {
--- 2030,2036 ----
  	if ((strid = duidstr(duid)) == NULL)
  		strid = "???";
  	if ((host->name = strdup(strid)) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "memory allocation failed");
  		goto bad;
  	}
  	if (duidcpy(&host->duid, duid) != 0) {
***************
*** 2038,2044 ****
  	}
  	if (pool->name) {
  		if ((host->pool.name = strdup(pool->name)) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "memory allocation failed");
  			goto bad;
  		}
  	}
--- 2038,2044 ----
  	}
  	if (pool->name) {
  		if ((host->pool.name = strdup(pool->name)) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "memory allocation failed");
  			goto bad;
  		}
  	}
***************
*** 2049,2055 ****
  	TAILQ_INSERT_HEAD(&dynamic_hostconf_head, dynconf, link);
  	dynamic_hostconf_count++; 
  
! 	dprintf(LOG_DEBUG, FNAME, "created host_conf (name=%s)", host->name);
  
  	return (host);
  
--- 2049,2055 ----
  	TAILQ_INSERT_HEAD(&dynamic_hostconf_head, dynconf, link);
  	dynamic_hostconf_count++; 
  
! 	debug_printf(LOG_DEBUG, FNAME, "created host_conf (name=%s)", host->name);
  
  	return (host);
  
***************
*** 2097,2118 ****
  		return (NULL);
  	}
  
! 	dprintf(LOG_DEBUG, FNAME, "name=%s, range=%s->%s", name,
  		in6addr2str(&range->min, 0), in6addr2str(&range->max, 0));
  
  	if (in6_addr_cmp(&range->min, &range->max) > 0) {
! 		dprintf(LOG_ERR, FNAME, "invalid address range %s->%s",
  			in6addr2str(&range->min, 0),
  			in6addr2str(&range->max, 0));
  		return (NULL);
  	}
  
  	if ((pool = malloc(sizeof(struct pool_conf))) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "memory allocation failed");
  		return (NULL);
  	}
  	if ((pool->name = strdup(name)) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "memory allocation failed");
  		free(pool);
  		return (NULL);
  	}
--- 2097,2118 ----
  		return (NULL);
  	}
  
! 	debug_printf(LOG_DEBUG, FNAME, "name=%s, range=%s->%s", name,
  		in6addr2str(&range->min, 0), in6addr2str(&range->max, 0));
  
  	if (in6_addr_cmp(&range->min, &range->max) > 0) {
! 		debug_printf(LOG_ERR, FNAME, "invalid address range %s->%s",
  			in6addr2str(&range->min, 0),
  			in6addr2str(&range->max, 0));
  		return (NULL);
  	}
  
  	if ((pool = malloc(sizeof(struct pool_conf))) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "memory allocation failed");
  		return (NULL);
  	}
  	if ((pool->name = strdup(name)) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "memory allocation failed");
  		free(pool);
  		return (NULL);
  	}
***************
*** 2131,2146 ****
  	if (!name)
  		return (NULL);
  
! 	dprintf(LOG_DEBUG, FNAME, "name=%s", name);
  
  	for (pool = pool_conflist; pool; pool = pool->next) {
  		if (strcmp(name, pool->name) == 0) {
! 			dprintf(LOG_DEBUG, FNAME, "found (name=%s)", name);
  			return (pool);
  		}
  	}
  
! 	dprintf(LOG_DEBUG, FNAME, "not found (name=%s)", name);
  
  	return (NULL);
  }
--- 2131,2146 ----
  	if (!name)
  		return (NULL);
  
! 	debug_printf(LOG_DEBUG, FNAME, "name=%s", name);
  
  	for (pool = pool_conflist; pool; pool = pool->next) {
  		if (strcmp(name, pool->name) == 0) {
! 			debug_printf(LOG_DEBUG, FNAME, "found (name=%s)", name);
  			return (pool);
  		}
  	}
  
! 	debug_printf(LOG_DEBUG, FNAME, "not found (name=%s)", name);
  
  	return (NULL);
  }
***************
*** 2154,2160 ****
  	if (!pool || !addr)
  		return (0);
  
! 	dprintf(LOG_DEBUG, FNAME, "called (pool=%s)", pool->name);
  
  	for (cur = pool->min; in6_addr_cmp(&cur, &pool->max) <= 0;
  	    in6_addr_inc(&cur)) {
--- 2154,2160 ----
  	if (!pool || !addr)
  		return (0);
  
! 	debug_printf(LOG_DEBUG, FNAME, "called (pool=%s)", pool->name);
  
  	for (cur = pool->min; in6_addr_cmp(&cur, &pool->max) <= 0;
  	    in6_addr_inc(&cur)) {
***************
*** 2162,2178 ****
  		    !IN6_IS_ADDR_MULTICAST(&cur) &&
  		    !IN6_IS_ADDR_LINKLOCAL(&cur) &&
  		    !IN6_IS_ADDR_SITELOCAL(&cur)) {
! 			dprintf(LOG_DEBUG, FNAME, "found %s",
  				in6addr2str(&cur, 0));
  			*addr= cur;
  			return 1;
  		}
  
! 		dprintf(LOG_DEBUG, FNAME, "next address %s",
  			in6addr2str(&cur, 0));
  	}
  
! 	dprintf(LOG_NOTICE, FNAME, "no available address");
  	return 0;
  }
  
--- 2162,2178 ----
  		    !IN6_IS_ADDR_MULTICAST(&cur) &&
  		    !IN6_IS_ADDR_LINKLOCAL(&cur) &&
  		    !IN6_IS_ADDR_SITELOCAL(&cur)) {
! 			debug_printf(LOG_DEBUG, FNAME, "found %s",
  				in6addr2str(&cur, 0));
  			*addr= cur;
  			return 1;
  		}
  
! 		debug_printf(LOG_DEBUG, FNAME, "next address %s",
  			in6addr2str(&cur, 0));
  	}
  
! 	debug_printf(LOG_NOTICE, FNAME, "no available address");
  	return 0;
  }
  
***************
*** 2184,2190 ****
  	if (!pool || !addr)
  		return (0);
  
! 	dprintf(LOG_DEBUG, FNAME, "pool=%s, addr=%s",
  		 pool->name, in6addr2str(addr, 0));
  
  	if (in6_addr_cmp(addr, &pool->min) >= 0 &&
--- 2184,2190 ----
  	if (!pool || !addr)
  		return (0);
  
! 	debug_printf(LOG_DEBUG, FNAME, "pool=%s, addr=%s",
  		 pool->name, in6addr2str(addr, 0));
  
  	if (in6_addr_cmp(addr, &pool->min) >= 0 &&
***************
*** 2196,2202 ****
  		return (1);
  	}
  
! 	dprintf(LOG_DEBUG, FNAME, "unavailable address (pool=%s, addr=%s)",
  		 pool->name, in6addr2str(addr, 0));
  
  	return (0);
--- 2196,2202 ----
  		return (1);
  	}
  
! 	debug_printf(LOG_DEBUG, FNAME, "unavailable address (pool=%s, addr=%s)",
  		 pool->name, in6addr2str(addr, 0));
  
  	return (0);
diff -crB wide-dhcpv6-20080615/dhcp6c.c wide-dhcpv6-20080615-ltrx/dhcp6c.c
*** wide-dhcpv6-20080615/dhcp6c.c	2015-04-22 16:16:38.356482549 +0530
--- wide-dhcpv6-20080615-ltrx/dhcp6c.c	2015-04-22 16:17:46.400967316 +0530
***************
*** 215,221 ****
  	client6_init();
  	while (argc-- > 0) { 
  		if ((ifp = ifinit(argv[0])) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "failed to initialize %s",
  			    argv[0]);
  			exit(1);
  		}
--- 215,221 ----
  	client6_init();
  	while (argc-- > 0) { 
  		if ((ifp = ifinit(argv[0])) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "failed to initialize %s",
  			    argv[0]);
  			exit(1);
  		}
***************
*** 223,229 ****
  	}
  
  	if (infreq_mode == 0 && (cfparse(conffile)) != 0) {
! 		dprintf(LOG_ERR, FNAME, "failed to parse configuration file");
  		exit(1);
  	}
  
--- 223,229 ----
  	}
  
  	if (infreq_mode == 0 && (cfparse(conffile)) != 0) {
! 		debug_printf(LOG_ERR, FNAME, "failed to parse configuration file");
  		exit(1);
  	}
  
***************
*** 265,277 ****
  
  	/* get our DUID */
  	if (get_duid(DUID_FILE, &client_duid)) {
! 		dprintf(LOG_ERR, FNAME, "failed to get a DUID");
  		exit(1);
  	}
  
  	if (dhcp6_ctl_authinit(ctlkeyfile, &ctlkey, &ctldigestlen) != 0) {
  #if 0 /* LTRX: MD 9/20/2012. Suppress error message. */
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed initialize control message authentication");
  #endif
  		/* run the server anyway */
--- 265,277 ----
  
  	/* get our DUID */
  	if (get_duid(DUID_FILE, &client_duid)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to get a DUID");
  		exit(1);
  	}
  
  	if (dhcp6_ctl_authinit(ctlkeyfile, &ctlkey, &ctldigestlen) != 0) {
  #if 0 /* LTRX: MD 9/20/2012. Suppress error message. */
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed initialize control message authentication");
  #endif
  		/* run the server anyway */
***************
*** 284,308 ****
  	hints.ai_flags = AI_PASSIVE;
  	error = getaddrinfo(NULL, DH6PORT_DOWNSTREAM, &hints, &res);
  	if (error) {
! 		dprintf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
  	sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  	if (sock < 0) {
! 		dprintf(LOG_ERR, FNAME, "socket");
  		exit(1);
  	}
  	if (setsockopt(sock, SOL_SOCKET, SO_REUSEPORT,
  		       &on, sizeof(on)) < 0) {
! 		dprintf(LOG_ERR, FNAME,
  		    "setsockopt(SO_REUSEPORT): %s", strerror(errno));
  		exit(1);
  	}
  #ifdef IPV6_RECVPKTINFO
  	if (setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,
  		       sizeof(on)) < 0) {
! 		dprintf(LOG_ERR, FNAME,
  			"setsockopt(IPV6_RECVPKTINFO): %s",
  			strerror(errno));
  		exit(1);
--- 284,308 ----
  	hints.ai_flags = AI_PASSIVE;
  	error = getaddrinfo(NULL, DH6PORT_DOWNSTREAM, &hints, &res);
  	if (error) {
! 		debug_printf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
  	sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  	if (sock < 0) {
! 		debug_printf(LOG_ERR, FNAME, "socket");
  		exit(1);
  	}
  	if (setsockopt(sock, SOL_SOCKET, SO_REUSEPORT,
  		       &on, sizeof(on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "setsockopt(SO_REUSEPORT): %s", strerror(errno));
  		exit(1);
  	}
  #ifdef IPV6_RECVPKTINFO
  	if (setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,
  		       sizeof(on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME,
  			"setsockopt(IPV6_RECVPKTINFO): %s",
  			strerror(errno));
  		exit(1);
***************
*** 310,316 ****
  #else
  	if (setsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, &on,
  		       sizeof(on)) < 0) {
! 		dprintf(LOG_ERR, FNAME,
  		    "setsockopt(IPV6_PKTINFO): %s",
  		    strerror(errno));
  		exit(1);
--- 310,316 ----
  #else
  	if (setsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, &on,
  		       sizeof(on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "setsockopt(IPV6_PKTINFO): %s",
  		    strerror(errno));
  		exit(1);
***************
*** 318,324 ****
  #endif
  	if (setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, &on,
  		       sizeof(on)) < 0) {
! 		dprintf(LOG_ERR, FNAME,
  		    "setsockopt(sock, IPV6_MULTICAST_LOOP): %s",
  		    strerror(errno));
  		exit(1);
--- 318,324 ----
  #endif
  	if (setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, &on,
  		       sizeof(on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "setsockopt(sock, IPV6_MULTICAST_LOOP): %s",
  		    strerror(errno));
  		exit(1);
***************
*** 326,332 ****
  #ifdef IPV6_V6ONLY
  	if (setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY,
  	    &on, sizeof(on)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "setsockopt(IPV6_V6ONLY): %s",
  		    strerror(errno));
  		exit(1);
  	}
--- 326,332 ----
  #ifdef IPV6_V6ONLY
  	if (setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY,
  	    &on, sizeof(on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "setsockopt(IPV6_V6ONLY): %s",
  		    strerror(errno));
  		exit(1);
  	}
***************
*** 338,351 ****
  	 * the outgoing port is also bound to the DH6PORT_DOWNSTREAM.
  	 */
  	if (bind(sock, res->ai_addr, res->ai_addrlen) < 0) {
! 		dprintf(LOG_ERR, FNAME, "bind: %s", strerror(errno));
  		exit(1);
  	}
  	freeaddrinfo(res);
  
  	/* open a routing socket to watch the routing table */
  	if ((rtsock = socket(PF_ROUTE, SOCK_RAW, 0)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "open a routing socket: %s",
  		    strerror(errno));
  		exit(1);
  	}
--- 338,351 ----
  	 * the outgoing port is also bound to the DH6PORT_DOWNSTREAM.
  	 */
  	if (bind(sock, res->ai_addr, res->ai_addrlen) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "bind: %s", strerror(errno));
  		exit(1);
  	}
  	freeaddrinfo(res);
  
  	/* open a routing socket to watch the routing table */
  	if ((rtsock = socket(PF_ROUTE, SOCK_RAW, 0)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "open a routing socket: %s",
  		    strerror(errno));
  		exit(1);
  	}
***************
*** 356,362 ****
  	hints.ai_protocol = IPPROTO_UDP;
  	error = getaddrinfo(DH6ADDR_ALLAGENT, DH6PORT_UPSTREAM, &hints, &res);
  	if (error) {
! 		dprintf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
--- 356,362 ----
  	hints.ai_protocol = IPPROTO_UDP;
  	error = getaddrinfo(DH6ADDR_ALLAGENT, DH6PORT_UPSTREAM, &hints, &res);
  	if (error) {
! 		debug_printf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
***************
*** 366,386 ****
  
  	/* set up control socket */
  	if (ctlkey == NULL)
! 		dprintf(LOG_NOTICE, FNAME, "skip opening control port");
  	else if (dhcp6_ctl_init(ctladdr, ctlport,
  	    DHCP6CTL_DEF_COMMANDQUEUELEN, &ctlsock)) {
! 		dprintf(LOG_ERR, FNAME,
  		    "failed to initialize control channel");
  		exit(1);
  	}
  
  	if (signal(SIGHUP, client6_signal) == SIG_ERR) {
! 		dprintf(LOG_WARNING, FNAME, "failed to set signal: %s",
  		    strerror(errno));
  		exit(1);
  	}
  	if (signal(SIGTERM, client6_signal) == SIG_ERR) {
! 		dprintf(LOG_WARNING, FNAME, "failed to set signal: %s",
  		    strerror(errno));
  		exit(1);
  	}
--- 366,386 ----
  
  	/* set up control socket */
  	if (ctlkey == NULL)
! 		debug_printf(LOG_NOTICE, FNAME, "skip opening control port");
  	else if (dhcp6_ctl_init(ctladdr, ctlport,
  	    DHCP6CTL_DEF_COMMANDQUEUELEN, &ctlsock)) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "failed to initialize control channel");
  		exit(1);
  	}
  
  	if (signal(SIGHUP, client6_signal) == SIG_ERR) {
! 		debug_printf(LOG_WARNING, FNAME, "failed to set signal: %s",
  		    strerror(errno));
  		exit(1);
  	}
  	if (signal(SIGTERM, client6_signal) == SIG_ERR) {
! 		debug_printf(LOG_WARNING, FNAME, "failed to set signal: %s",
  		    strerror(errno));
  		exit(1);
  	}
***************
*** 394,421 ****
  
  	/* make sure that the interface does not have a timer */
  	if (ifp->timer != NULL) {
! 		dprintf(LOG_DEBUG, FNAME,
  		    "removed existing timer on %s", ifp->ifname);
  		dhcp6_remove_timer(&ifp->timer);
  	}
  
  	/* create an event for the initial delay */
  	if ((ev = dhcp6_create_event(ifp, DHCP6S_INIT)) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to create an event");
  		return (-1);
  	}
  	TAILQ_INSERT_TAIL(&ifp->event_list, ev, link);
  
  	if ((ev->authparam = new_authparam(ifp->authproto,
  	    ifp->authalgorithm, ifp->authrdm)) == NULL) {
! 		dprintf(LOG_WARNING, FNAME, "failed to allocate "
  		    "authentication parameters");
  		dhcp6_remove_event(ev);
  		return (-1);
  	}
  
  	if ((ev->timer = dhcp6_add_timer(client6_timo, ev)) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to add a timer for %s",
  		    ifp->ifname);
  		dhcp6_remove_event(ev);
  		return (-1);
--- 394,421 ----
  
  	/* make sure that the interface does not have a timer */
  	if (ifp->timer != NULL) {
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "removed existing timer on %s", ifp->ifname);
  		dhcp6_remove_timer(&ifp->timer);
  	}
  
  	/* create an event for the initial delay */
  	if ((ev = dhcp6_create_event(ifp, DHCP6S_INIT)) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to create an event");
  		return (-1);
  	}
  	TAILQ_INSERT_TAIL(&ifp->event_list, ev, link);
  
  	if ((ev->authparam = new_authparam(ifp->authproto,
  	    ifp->authalgorithm, ifp->authrdm)) == NULL) {
! 		debug_printf(LOG_WARNING, FNAME, "failed to allocate "
  		    "authentication parameters");
  		dhcp6_remove_event(ev);
  		return (-1);
  	}
  
  	if ((ev->timer = dhcp6_add_timer(client6_timo, ev)) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to add a timer for %s",
  		    ifp->ifname);
  		dhcp6_remove_event(ev);
  		return (-1);
***************
*** 433,439 ****
  
  	for (ifp = dhcp6_if; ifp; ifp = ifp->next) {
  		if (isrestart &&ifreset(ifp)) {
! 			dprintf(LOG_NOTICE, FNAME, "failed to reset %s",
  			    ifp->ifname);
  			continue; /* XXX: try to recover? */
  		}
--- 433,439 ----
  
  	for (ifp = dhcp6_if; ifp; ifp = ifp->next) {
  		if (isrestart &&ifreset(ifp)) {
! 			debug_printf(LOG_NOTICE, FNAME, "failed to reset %s",
  			    ifp->ifname);
  			continue; /* XXX: try to recover? */
  		}
***************
*** 490,496 ****
  	}
  
  	/* We have no existing event.  Do exit. */
! 	dprintf(LOG_INFO, FNAME, "exiting");
  
  	exit(0);
  }
--- 490,496 ----
  	}
  
  	/* We have no existing event.  Do exit. */
! 	debug_printf(LOG_INFO, FNAME, "exiting");
  
  	exit(0);
  }
***************
*** 505,511 ****
  		check_exit();
  	}
  	if ((sig_flags & SIGF_HUP)) {
! 		dprintf(LOG_INFO, FNAME, "restarting");
  		free_resources(NULL);
  		client6_startall(1);
  	}
--- 505,511 ----
  		check_exit();
  	}
  	if ((sig_flags & SIGF_HUP)) {
! 		debug_printf(LOG_INFO, FNAME, "restarting");
  		free_resources(NULL);
  		client6_startall(1);
  	}
***************
*** 540,546 ****
  		switch (ret) {
  		case -1:
  			if (errno != EINTR) {
! 				dprintf(LOG_ERR, FNAME, "select: %s",
  				    strerror(errno));
  				exit(1);
  			}
--- 540,546 ----
  		switch (ret) {
  		case -1:
  			if (errno != EINTR) {
! 				debug_printf(LOG_ERR, FNAME, "select: %s",
  				    strerror(errno));
  				exit(1);
  			}
***************
*** 634,664 ****
  	commandlen = (int)(ntohs(ctlhead->len));
  	version = ntohs(ctlhead->version);
  	if (len != sizeof(struct dhcp6ctl) + commandlen) {
! 		dprintf(LOG_ERR, FNAME,
  		    "assumption failure: command length mismatch");
  		return (DHCP6CTL_R_FAILURE);
  	}
  
  	/* replay protection and message authentication */
  	if ((now = time(NULL)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "failed to get current time: %s",
  		    strerror(errno));
  		return (DHCP6CTL_R_FAILURE);
  	}
  	ts0 = (u_int32_t)now;
  	ts = ntohl(ctlhead->timestamp);
  	if (ts + CTLSKEW < ts0 || (ts - CTLSKEW) > ts0) {
! 		dprintf(LOG_INFO, FNAME, "timestamp is out of range");
  		return (DHCP6CTL_R_FAILURE);
  	}
  
  	if (ctlkey == NULL) {	/* should not happen!! */
! 		dprintf(LOG_ERR, FNAME, "no secret key for control channel");
  		return (DHCP6CTL_R_FAILURE);
  	}
  	if (dhcp6_verify_mac(buf, len, DHCP6CTL_AUTHPROTO_UNDEF,
  	    DHCP6CTL_AUTHALG_HMACMD5, sizeof(*ctlhead), ctlkey) != 0) {
! 		dprintf(LOG_INFO, FNAME, "authentication failure");
  		return (DHCP6CTL_R_FAILURE);
  	}
  
--- 634,664 ----
  	commandlen = (int)(ntohs(ctlhead->len));
  	version = ntohs(ctlhead->version);
  	if (len != sizeof(struct dhcp6ctl) + commandlen) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "assumption failure: command length mismatch");
  		return (DHCP6CTL_R_FAILURE);
  	}
  
  	/* replay protection and message authentication */
  	if ((now = time(NULL)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "failed to get current time: %s",
  		    strerror(errno));
  		return (DHCP6CTL_R_FAILURE);
  	}
  	ts0 = (u_int32_t)now;
  	ts = ntohl(ctlhead->timestamp);
  	if (ts + CTLSKEW < ts0 || (ts - CTLSKEW) > ts0) {
! 		debug_printf(LOG_INFO, FNAME, "timestamp is out of range");
  		return (DHCP6CTL_R_FAILURE);
  	}
  
  	if (ctlkey == NULL) {	/* should not happen!! */
! 		debug_printf(LOG_ERR, FNAME, "no secret key for control channel");
  		return (DHCP6CTL_R_FAILURE);
  	}
  	if (dhcp6_verify_mac(buf, len, DHCP6CTL_AUTHPROTO_UNDEF,
  	    DHCP6CTL_AUTHALG_HMACMD5, sizeof(*ctlhead), ctlkey) != 0) {
! 		debug_printf(LOG_INFO, FNAME, "authentication failure");
  		return (DHCP6CTL_R_FAILURE);
  	}
  
***************
*** 666,679 ****
  	commandlen -= ctldigestlen;
  
  	if (version > DHCP6CTL_VERSION) {
! 		dprintf(LOG_INFO, FNAME, "unsupported version: %d", version);
  		return (DHCP6CTL_R_FAILURE);
  	}
  
  	switch (command) {
  	case DHCP6CTL_COMMAND_RELOAD:
  		if (commandlen != 0) {
! 			dprintf(LOG_INFO, FNAME, "invalid command length "
  			    "for reload: %d", commandlen);
  			return (DHCP6CTL_R_DONE);
  		}
--- 666,679 ----
  	commandlen -= ctldigestlen;
  
  	if (version > DHCP6CTL_VERSION) {
! 		debug_printf(LOG_INFO, FNAME, "unsupported version: %d", version);
  		return (DHCP6CTL_R_FAILURE);
  	}
  
  	switch (command) {
  	case DHCP6CTL_COMMAND_RELOAD:
  		if (commandlen != 0) {
! 			debug_printf(LOG_INFO, FNAME, "invalid command length "
  			    "for reload: %d", commandlen);
  			return (DHCP6CTL_R_DONE);
  		}
***************
*** 692,698 ****
  				return (DHCP6CTL_R_FAILURE);
  			break;
  		default:
! 			dprintf(LOG_INFO, FNAME,
  			    "unknown start target: %ul", p32);
  			return (DHCP6CTL_R_FAILURE);
  		}
--- 692,698 ----
  				return (DHCP6CTL_R_FAILURE);
  			break;
  		default:
! 			debug_printf(LOG_INFO, FNAME,
  			    "unknown start target: %ul", p32);
  			return (DHCP6CTL_R_FAILURE);
  		}
***************
*** 719,732 ****
  				}
  				break;
  			default:
! 				dprintf(LOG_INFO, FNAME,
  				    "unknown start target: %ul", p32);
  				return (DHCP6CTL_R_FAILURE);
  			}
  		}
  		break;
  	default:
! 		dprintf(LOG_INFO, FNAME,
  		    "unknown control command: %d (len=%d)",
  		    (int)command, commandlen);
  		return (DHCP6CTL_R_FAILURE);
--- 719,732 ----
  				}
  				break;
  			default:
! 				debug_printf(LOG_INFO, FNAME,
  				    "unknown start target: %ul", p32);
  				return (DHCP6CTL_R_FAILURE);
  			}
  		}
  		break;
  	default:
! 		debug_printf(LOG_INFO, FNAME,
  		    "unknown control command: %d (len=%d)",
  		    (int)command, commandlen);
  		return (DHCP6CTL_R_FAILURE);
***************
*** 740,751 ****
  {
  	/* reload the configuration file */
  	if (cfparse(conffile) != 0) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "failed to reload configuration file");
  		return;
  	}
  
! 	dprintf(LOG_NOTICE, FNAME, "client reloaded");
  
  	return;
  }
--- 740,751 ----
  {
  	/* reload the configuration file */
  	if (cfparse(conffile) != 0) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "failed to reload configuration file");
  		return;
  	}
  
! 	debug_printf(LOG_NOTICE, FNAME, "client reloaded");
  
  	return;
  }
***************
*** 758,777 ****
  	struct dhcp6_if *ifp;
  
  	if ((ifp = find_ifconfbyname(ifname)) == NULL) {
! 		dprintf(LOG_INFO, FNAME,
  		    "failed to find interface configuration for %s",
  		    ifname);
  		return (-1);
  	}
  
! 	dprintf(LOG_DEBUG, FNAME, "%s interface %s",
  	    command == DHCP6CTL_COMMAND_START ? "start" : "stop", ifname);
  
  	switch(command) {
  	case DHCP6CTL_COMMAND_START:
  		free_resources(ifp);
  		if (client6_start(ifp)) {
! 			dprintf(LOG_NOTICE, FNAME, "failed to restart %s",
  			    ifname);
  			return (-1);
  		}
--- 758,777 ----
  	struct dhcp6_if *ifp;
  
  	if ((ifp = find_ifconfbyname(ifname)) == NULL) {
! 		debug_printf(LOG_INFO, FNAME,
  		    "failed to find interface configuration for %s",
  		    ifname);
  		return (-1);
  	}
  
! 	debug_printf(LOG_DEBUG, FNAME, "%s interface %s",
  	    command == DHCP6CTL_COMMAND_START ? "start" : "stop", ifname);
  
  	switch(command) {
  	case DHCP6CTL_COMMAND_START:
  		free_resources(ifp);
  		if (client6_start(ifp)) {
! 			debug_printf(LOG_NOTICE, FNAME, "failed to restart %s",
  			    ifname);
  			return (-1);
  		}
***************
*** 779,791 ****
  	case DHCP6CTL_COMMAND_STOP:
  		free_resources(ifp);
  		if (ifp->timer != NULL) {
! 			dprintf(LOG_DEBUG, FNAME,
  			    "removed existing timer on %s", ifp->ifname);
  			dhcp6_remove_timer(&ifp->timer);
  		}
  		break;
  	default:		/* impossible case, should be a bug */
! 		dprintf(LOG_ERR, FNAME, "unknown command: %d", (int)command);
  		break;
  	}
  
--- 779,791 ----
  	case DHCP6CTL_COMMAND_STOP:
  		free_resources(ifp);
  		if (ifp->timer != NULL) {
! 			debug_printf(LOG_DEBUG, FNAME,
  			    "removed existing timer on %s", ifp->ifname);
  			dhcp6_remove_timer(&ifp->timer);
  		}
  		break;
  	default:		/* impossible case, should be a bug */
! 		debug_printf(LOG_ERR, FNAME, "unknown command: %d", (int)command);
  		break;
  	}
  
***************
*** 798,804 ****
  {
  	struct dhcp6_if *ifp = arg;
  
! 	dprintf(LOG_DEBUG, FNAME,
  	    "information refresh time on %s expired", ifp->ifname);
  
  	dhcp6_remove_timer(&ifp->timer);
--- 798,804 ----
  {
  	struct dhcp6_if *ifp = arg;
  
! 	debug_printf(LOG_DEBUG, FNAME,
  	    "information refresh time on %s expired", ifp->ifname);
  
  	dhcp6_remove_timer(&ifp->timer);
***************
*** 824,830 ****
  	 * [RFC3315 14.]
  	 */
  	if (ev->max_retrans_cnt && ev->timeouts >= ev->max_retrans_cnt) {
! 		dprintf(LOG_INFO, FNAME, "no responses were received");
  		dhcp6_remove_event(ev);
  
  		if (state == DHCP6S_RELEASE)
--- 824,830 ----
  	 * [RFC3315 14.]
  	 */
  	if (ev->max_retrans_cnt && ev->timeouts >= ev->max_retrans_cnt) {
! 		debug_printf(LOG_INFO, FNAME, "no responses were received");
  		dhcp6_remove_event(ev);
  
  		if (state == DHCP6S_RELEASE)
***************
*** 841,847 ****
  		else {
  			ev->state = DHCP6S_SOLICIT;
  			if (construct_confdata(ifp, ev)) {
! 				dprintf(LOG_ERR, FNAME, "can't send solicit");
  				exit(1); /* XXX */
  			}
  		}
--- 841,847 ----
  		else {
  			ev->state = DHCP6S_SOLICIT;
  			if (construct_confdata(ifp, ev)) {
! 				debug_printf(LOG_ERR, FNAME, "can't send solicit");
  				exit(1); /* XXX */
  			}
  		}
***************
*** 857,863 ****
  		if (!TAILQ_EMPTY(&ev->data_list))
  			client6_send(ev);
  		else {
! 			dprintf(LOG_INFO, FNAME,
  			    "all information to be updated was canceled");
  			dhcp6_remove_event(ev);
  			return (NULL);
--- 857,863 ----
  		if (!TAILQ_EMPTY(&ev->data_list))
  			client6_send(ev);
  		else {
! 			debug_printf(LOG_INFO, FNAME,
  			    "all information to be updated was canceled");
  			dhcp6_remove_event(ev);
  			return (NULL);
***************
*** 876,888 ****
  			ev->current_server = select_server(ev);
  			if (ev->current_server == NULL) {
  				/* this should not happen! */
! 				dprintf(LOG_NOTICE, FNAME,
  				    "can't find a server");
  				exit(1); /* XXX */
  			}
  			if (duidcpy(&ev->serverid,
  			    &ev->current_server->optinfo.serverID)) {
! 				dprintf(LOG_NOTICE, FNAME,
  				    "can't copy server ID");
  				return (NULL); /* XXX: better recovery? */
  			}
--- 876,888 ----
  			ev->current_server = select_server(ev);
  			if (ev->current_server == NULL) {
  				/* this should not happen! */
! 				debug_printf(LOG_NOTICE, FNAME,
  				    "can't find a server");
  				exit(1); /* XXX */
  			}
  			if (duidcpy(&ev->serverid,
  			    &ev->current_server->optinfo.serverID)) {
! 				debug_printf(LOG_NOTICE, FNAME,
  				    "can't copy server ID");
  				return (NULL); /* XXX: better recovery? */
  			}
***************
*** 897,903 ****
  
  			if (construct_reqdata(ifp,
  			    &ev->current_server->optinfo, ev)) {
! 				dprintf(LOG_NOTICE, FNAME,
  				    "failed to construct request data");
  				break;
  			}
--- 897,903 ----
  
  			if (construct_reqdata(ifp,
  			    &ev->current_server->optinfo, ev)) {
! 				debug_printf(LOG_NOTICE, FNAME,
  				    "failed to construct request data");
  				break;
  			}
***************
*** 931,937 ****
  
  		evd = NULL;
  		if ((evd = malloc(sizeof(*evd))) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to create a new event data");
  			goto fail;
  		}
--- 931,937 ----
  
  		evd = NULL;
  		if ((evd = malloc(sizeof(*evd))) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to create a new event data");
  			goto fail;
  		}
***************
*** 983,989 ****
  			TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
  			break;
  		default:
! 			dprintf(LOG_ERR, FNAME, "internal error");
  			exit(1);
  		}
  	}
--- 983,989 ----
  			TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
  			break;
  		default:
! 			debug_printf(LOG_ERR, FNAME, "internal error");
  			exit(1);
  		}
  	}
***************
*** 1079,1085 ****
  			TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
  			break;
  		default:
! 			dprintf(LOG_ERR, FNAME, "internal error");
  			exit(1);
  		}
  	}
--- 1079,1085 ----
  			TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
  			break;
  		default:
! 			debug_printf(LOG_ERR, FNAME, "internal error");
  			exit(1);
  		}
  	}
***************
*** 1103,1109 ****
  	struct dhcp6_list *ial;
  
  	if (evd->type != DHCP6_EVDATA_IAPD && evd->type != DHCP6_EVDATA_IANA) {
! 		dprintf(LOG_ERR, FNAME, "assumption failure %d", evd->type);
  		exit(1);
  	}
  
--- 1103,1109 ----
  	struct dhcp6_list *ial;
  
  	if (evd->type != DHCP6_EVDATA_IAPD && evd->type != DHCP6_EVDATA_IANA) {
! 		debug_printf(LOG_ERR, FNAME, "assumption failure %d", evd->type);
  		exit(1);
  	}
  
***************
*** 1125,1131 ****
  	 */
  	for (s = ev->servers; s; s = s->next) {
  		if (s->active) {
! 			dprintf(LOG_DEBUG, FNAME, "picked a server (ID: %s)",
  			    duidstr(&s->optinfo.serverID));
  			return (s);
  		}
--- 1125,1131 ----
  	 */
  	for (s = ev->servers; s; s = s->next) {
  		if (s->active) {
! 			debug_printf(LOG_DEBUG, FNAME, "picked a server (ID: %s)",
  			    duidstr(&s->optinfo.serverID));
  			return (s);
  		}
***************
*** 1186,1192 ****
  		dh6->dh6_msgtype = DH6_INFORM_REQ;
  		break;
  	default:
! 		dprintf(LOG_ERR, FNAME, "unexpected state");
  		exit(1);	/* XXX */
  	}
  
--- 1186,1192 ----
  		dh6->dh6_msgtype = DH6_INFORM_REQ;
  		break;
  	default:
! 		debug_printf(LOG_ERR, FNAME, "unexpected state");
  		exit(1);	/* XXX */
  	}
  
***************
*** 1204,1210 ****
  #else
  		ev->xid = random() & DH6_XIDMASK;
  #endif
! 		dprintf(LOG_DEBUG, FNAME, "a new XID (%x) is generated",
  		    ev->xid);
  	}
  	dh6->dh6_xid &= ~ntohl(DH6_XIDMASK);
--- 1204,1210 ----
  #else
  		ev->xid = random() & DH6_XIDMASK;
  #endif
! 		debug_printf(LOG_DEBUG, FNAME, "a new XID (%x) is generated",
  		    ev->xid);
  	}
  	dh6->dh6_xid &= ~ntohl(DH6_XIDMASK);
***************
*** 1222,1228 ****
  	case DHCP6S_RENEW:
  	case DHCP6S_RELEASE:
  		if (duidcpy(&optinfo.serverID, &ev->serverid)) {
! 			dprintf(LOG_ERR, FNAME, "failed to copy server ID");
  			goto end;
  		}
  		break;
--- 1222,1228 ----
  	case DHCP6S_RENEW:
  	case DHCP6S_RELEASE:
  		if (duidcpy(&optinfo.serverID, &ev->serverid)) {
! 			debug_printf(LOG_ERR, FNAME, "failed to copy server ID");
  			goto end;
  		}
  		break;
***************
*** 1230,1236 ****
  
  	/* client ID */
  	if (duidcpy(&optinfo.clientID, &client_duid)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto end;
  	}
  
--- 1230,1236 ----
  
  	/* client ID */
  	if (duidcpy(&optinfo.clientID, &client_duid)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto end;
  	}
  
***************
*** 1275,1281 ****
  	/* option request options */
  	if (ev->state != DHCP6S_RELEASE &&
  	    dhcp6_copy_list(&optinfo.reqopt_list, &ifp->reqopt_list)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy requested options");
  		goto end;
  	}
  
--- 1275,1281 ----
  	/* option request options */
  	if (ev->state != DHCP6S_RELEASE &&
  	    dhcp6_copy_list(&optinfo.reqopt_list, &ifp->reqopt_list)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy requested options");
  		goto end;
  	}
  
***************
*** 1286,1292 ****
  		case DHCP6_EVDATA_IAPD:
  			if (dhcp6_copy_list(&optinfo.iapd_list,
  			    (struct dhcp6_list *)evd->data)) {
! 				dprintf(LOG_NOTICE, FNAME,
  				    "failed to add an IAPD");
  				goto end;
  			}
--- 1286,1292 ----
  		case DHCP6_EVDATA_IAPD:
  			if (dhcp6_copy_list(&optinfo.iapd_list,
  			    (struct dhcp6_list *)evd->data)) {
! 				debug_printf(LOG_NOTICE, FNAME,
  				    "failed to add an IAPD");
  				goto end;
  			}
***************
*** 1294,1306 ****
  		case DHCP6_EVDATA_IANA:
  			if (dhcp6_copy_list(&optinfo.iana_list,
  			    (struct dhcp6_list *)evd->data)) {
! 				dprintf(LOG_NOTICE, FNAME,
  				    "failed to add an IAPD");
  				goto end;
  			}
  			break;
  		default:
! 			dprintf(LOG_ERR, FNAME, "unexpected event data (%d)",
  			    evd->type);
  			exit(1);
  		}
--- 1294,1306 ----
  		case DHCP6_EVDATA_IANA:
  			if (dhcp6_copy_list(&optinfo.iana_list,
  			    (struct dhcp6_list *)evd->data)) {
! 				debug_printf(LOG_NOTICE, FNAME,
  				    "failed to add an IAPD");
  				goto end;
  			}
  			break;
  		default:
! 			debug_printf(LOG_ERR, FNAME, "unexpected event data (%d)",
  			    evd->type);
  			exit(1);
  		}
***************
*** 1308,1314 ****
  
  	/* authentication information */
  	if (set_auth(ev, &optinfo)) {
! 		dprintf(LOG_INFO, FNAME,
  		    "failed to set authentication option");
  		goto end;
  	}
--- 1308,1314 ----
  
  	/* authentication information */
  	if (set_auth(ev, &optinfo)) {
! 		debug_printf(LOG_INFO, FNAME,
  		    "failed to set authentication option");
  		goto end;
  	}
***************
*** 1317,1323 ****
  	if ((optlen = dhcp6_set_options(dh6->dh6_msgtype,
  	    (struct dhcp6opt *)(dh6 + 1),
  	    (struct dhcp6opt *)(buf + sizeof(buf)), &optinfo)) < 0) {
! 		dprintf(LOG_INFO, FNAME, "failed to construct options");
  		goto end;
  	}
  	len += optlen;
--- 1317,1323 ----
  	if ((optlen = dhcp6_set_options(dh6->dh6_msgtype,
  	    (struct dhcp6opt *)(dh6 + 1),
  	    (struct dhcp6opt *)(buf + sizeof(buf)), &optinfo)) < 0) {
! 		debug_printf(LOG_INFO, FNAME, "failed to construct options");
  		goto end;
  	}
  	len += optlen;
***************
*** 1333,1339 ****
  			    optinfo.authproto, optinfo.authalgorithm,
  			    optinfo.delayedauth_offset + sizeof(*dh6),
  			    ev->authparam->key)) {
! 				dprintf(LOG_WARNING, FNAME,
  				    "failed to calculate MAC");
  				goto end;
  			}
--- 1333,1339 ----
  			    optinfo.authproto, optinfo.authalgorithm,
  			    optinfo.delayedauth_offset + sizeof(*dh6),
  			    ev->authparam->key)) {
! 				debug_printf(LOG_WARNING, FNAME,
  				    "failed to calculate MAC");
  				goto end;
  			}
***************
*** 1355,1366 ****
  
  	if (sendto(sock, buf, len, 0, (struct sockaddr *)&dst,
  	    sysdep_sa_len((struct sockaddr *)&dst)) == -1) {
! 		dprintf(LOG_ERR, FNAME,
  		    "transmit failed: %s", strerror(errno));
  		goto end;
  	}
  
! 	dprintf(LOG_DEBUG, FNAME, "send %s to %s",
  	    dhcp6msgstr(dh6->dh6_msgtype), addr2str((struct sockaddr *)&dst));
  
    end:
--- 1355,1366 ----
  
  	if (sendto(sock, buf, len, 0, (struct sockaddr *)&dst,
  	    sysdep_sa_len((struct sockaddr *)&dst)) == -1) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "transmit failed: %s", strerror(errno));
  		goto end;
  	}
  
! 	debug_printf(LOG_DEBUG, FNAME, "send %s to %s",
  	    dhcp6msgstr(dh6->dh6_msgtype), addr2str((struct sockaddr *)&dst));
  
    end:
***************
*** 1418,1424 ****
  	mhdr.msg_control = (caddr_t)cmsgbuf;
  	mhdr.msg_controllen = sizeof(cmsgbuf);
  	if ((len = recvmsg(sock, &mhdr, 0)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "recvmsg: %s", strerror(errno));
  		return;
  	}
  
--- 1418,1424 ----
  	mhdr.msg_control = (caddr_t)cmsgbuf;
  	mhdr.msg_controllen = sizeof(cmsgbuf);
  	if ((len = recvmsg(sock, &mhdr, 0)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "recvmsg: %s", strerror(errno));
  		return;
  	}
  
***************
*** 1432,1455 ****
  		}
  	}
  	if (pi == NULL) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to get packet info");
  		return;
  	}
  
  	if ((ifp = find_ifconfbyid((unsigned int)pi->ipi6_ifindex)) == NULL) {
! 		dprintf(LOG_INFO, FNAME, "unexpected interface (%d)",
  		    (unsigned int)pi->ipi6_ifindex);
  		return;
  	}
  
  	if (len < sizeof(*dh6)) {
! 		dprintf(LOG_INFO, FNAME, "short packet (%d bytes)", len);
  		return;
  	}
  
  	dh6 = (struct dhcp6 *)rbuf;
  
! 	dprintf(LOG_DEBUG, FNAME, "receive %s from %s on %s",
  	    dhcp6msgstr(dh6->dh6_msgtype),
  	    addr2str((struct sockaddr *)&from), ifp->ifname);
  
--- 1432,1455 ----
  		}
  	}
  	if (pi == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to get packet info");
  		return;
  	}
  
  	if ((ifp = find_ifconfbyid((unsigned int)pi->ipi6_ifindex)) == NULL) {
! 		debug_printf(LOG_INFO, FNAME, "unexpected interface (%d)",
  		    (unsigned int)pi->ipi6_ifindex);
  		return;
  	}
  
  	if (len < sizeof(*dh6)) {
! 		debug_printf(LOG_INFO, FNAME, "short packet (%d bytes)", len);
  		return;
  	}
  
  	dh6 = (struct dhcp6 *)rbuf;
  
! 	debug_printf(LOG_DEBUG, FNAME, "receive %s from %s on %s",
  	    dhcp6msgstr(dh6->dh6_msgtype),
  	    addr2str((struct sockaddr *)&from), ifp->ifname);
  
***************
*** 1458,1464 ****
  	p = (struct dhcp6opt *)(dh6 + 1);
  	ep = (struct dhcp6opt *)((char *)dh6 + len);
  	if (dhcp6_get_options(p, ep, &optinfo) < 0) {
! 		dprintf(LOG_INFO, FNAME, "failed to parse options");
  		return;
  	}
  
--- 1458,1464 ----
  	p = (struct dhcp6opt *)(dh6 + 1);
  	ep = (struct dhcp6opt *)((char *)dh6 + len);
  	if (dhcp6_get_options(p, ep, &optinfo) < 0) {
! 		debug_printf(LOG_INFO, FNAME, "failed to parse options");
  		return;
  	}
  
***************
*** 1470,1476 ****
  		(void)client6_recvreply(ifp, dh6, len, &optinfo);
  		break;
  	default:
! 		dprintf(LOG_INFO, FNAME, "received an unexpected message (%s) "
  		    "from %s", dhcp6msgstr(dh6->dh6_msgtype),
  		    addr2str((struct sockaddr *)&from));
  		break;
--- 1470,1476 ----
  		(void)client6_recvreply(ifp, dh6, len, &optinfo);
  		break;
  	default:
! 		debug_printf(LOG_INFO, FNAME, "received an unexpected message (%s) "
  		    "from %s", dhcp6msgstr(dh6->dh6_msgtype),
  		    addr2str((struct sockaddr *)&from));
  		break;
***************
*** 1495,1526 ****
  	/* find the corresponding event based on the received xid */
  	ev = find_event_withid(ifp, ntohl(dh6->dh6_xid) & DH6_XIDMASK);
  	if (ev == NULL) {
! 		dprintf(LOG_INFO, FNAME, "XID mismatch");
  		return (-1);
  	}
  
  	/* packet validation based on Section 15.3 of RFC3315. */
  	if (optinfo->serverID.duid_len == 0) {
! 		dprintf(LOG_INFO, FNAME, "no server ID option");
  		return (-1);
  	} else {
! 		dprintf(LOG_DEBUG, FNAME, "server ID: %s, pref=%d",
  		    duidstr(&optinfo->serverID),
  		    optinfo->pref);
  	}
  	if (optinfo->clientID.duid_len == 0) {
! 		dprintf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  	if (duidcmp(&optinfo->clientID, &client_duid)) {
! 		dprintf(LOG_INFO, FNAME, "client DUID mismatch");
  		return (-1);
  	}
  
  	/* validate authentication */
  	authparam0 = *ev->authparam;
  	if (process_auth(&authparam0, dh6, len, optinfo)) {
! 		dprintf(LOG_INFO, FNAME, "failed to process authentication");
  		return (-1);
  	}
  
--- 1495,1526 ----
  	/* find the corresponding event based on the received xid */
  	ev = find_event_withid(ifp, ntohl(dh6->dh6_xid) & DH6_XIDMASK);
  	if (ev == NULL) {
! 		debug_printf(LOG_INFO, FNAME, "XID mismatch");
  		return (-1);
  	}
  
  	/* packet validation based on Section 15.3 of RFC3315. */
  	if (optinfo->serverID.duid_len == 0) {
! 		debug_printf(LOG_INFO, FNAME, "no server ID option");
  		return (-1);
  	} else {
! 		debug_printf(LOG_DEBUG, FNAME, "server ID: %s, pref=%d",
  		    duidstr(&optinfo->serverID),
  		    optinfo->pref);
  	}
  	if (optinfo->clientID.duid_len == 0) {
! 		debug_printf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  	if (duidcmp(&optinfo->clientID, &client_duid)) {
! 		debug_printf(LOG_INFO, FNAME, "client DUID mismatch");
  		return (-1);
  	}
  
  	/* validate authentication */
  	authparam0 = *ev->authparam;
  	if (process_auth(&authparam0, dh6, len, optinfo)) {
! 		debug_printf(LOG_INFO, FNAME, "failed to process authentication");
  		return (-1);
  	}
  
***************
*** 1553,1559 ****
  		}
  		if (dhcp6_find_listval(&optinfo->stcode_list,
  		    DHCP6_LISTVAL_STCODE, &stcode, 0)) {
! 			dprintf(LOG_INFO, FNAME,
  			    "advertise contains %s status", stcodestr);
  			return (-1);
  		}
--- 1553,1559 ----
  		}
  		if (dhcp6_find_listval(&optinfo->stcode_list,
  		    DHCP6_LISTVAL_STCODE, &stcode, 0)) {
! 			debug_printf(LOG_INFO, FNAME,
  			    "advertise contains %s status", stcodestr);
  			return (-1);
  		}
***************
*** 1568,1587 ****
  		 * We process the message as if we expected the Advertise.
  		 * [RFC3315 Section 17.1.4]
  		 */
! 		dprintf(LOG_INFO, FNAME, "unexpected advertise");
  		/* proceed anyway */
  	}
  
  	/* ignore the server if it is known */
  	if (find_server(ev, &optinfo->serverID)) {
! 		dprintf(LOG_INFO, FNAME, "duplicated server (ID: %s)",
  		    duidstr(&optinfo->serverID));
  		return (-1);
  	}
  
  	/* keep the server */
  	if ((newserver = malloc(sizeof(*newserver))) == NULL) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "memory allocation failed for server");
  		return (-1);
  	}
--- 1568,1587 ----
  		 * We process the message as if we expected the Advertise.
  		 * [RFC3315 Section 17.1.4]
  		 */
! 		debug_printf(LOG_INFO, FNAME, "unexpected advertise");
  		/* proceed anyway */
  	}
  
  	/* ignore the server if it is known */
  	if (find_server(ev, &optinfo->serverID)) {
! 		debug_printf(LOG_INFO, FNAME, "duplicated server (ID: %s)",
  		    duidstr(&optinfo->serverID));
  		return (-1);
  	}
  
  	/* keep the server */
  	if ((newserver = malloc(sizeof(*newserver))) == NULL) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "memory allocation failed for server");
  		return (-1);
  	}
***************
*** 1596,1602 ****
  	/* allocate new authentication parameter for the soliciting event */
  	if ((authparam = new_authparam(ev->authparam->authproto,
  	    ev->authparam->authalgorithm, ev->authparam->authrdm)) == NULL) {
! 		dprintf(LOG_WARNING, FNAME, "memory allocation failed "
  		    "for authentication parameters");
  		free(newserver);
  		return (-1);
--- 1596,1602 ----
  	/* allocate new authentication parameter for the soliciting event */
  	if ((authparam = new_authparam(ev->authparam->authproto,
  	    ev->authparam->authalgorithm, ev->authparam->authrdm)) == NULL) {
! 		debug_printf(LOG_WARNING, FNAME, "memory allocation failed "
  		    "for authentication parameters");
  		free(newserver);
  		return (-1);
***************
*** 1606,1612 ****
  	/* copy options */
  	dhcp6_init_options(&newserver->optinfo);
  	if (dhcp6_copy_options(&newserver->optinfo, optinfo)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy options");
  		if (newserver->authparam != NULL)
  			free(newserver->authparam);
  		free(newserver);
--- 1606,1612 ----
  	/* copy options */
  	dhcp6_init_options(&newserver->optinfo);
  	if (dhcp6_copy_options(&newserver->optinfo, optinfo)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy options");
  		if (newserver->authparam != NULL)
  			free(newserver->authparam);
  		free(newserver);
***************
*** 1634,1644 ****
  		ev->current_server = newserver;
  		if (duidcpy(&ev->serverid,
  		    &ev->current_server->optinfo.serverID)) {
! 			dprintf(LOG_NOTICE, FNAME, "can't copy server ID");
  			return (-1); /* XXX: better recovery? */
  		}
  		if (construct_reqdata(ifp, &ev->current_server->optinfo, ev)) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to construct request data");
  			return (-1); /* XXX */
  		}
--- 1634,1644 ----
  		ev->current_server = newserver;
  		if (duidcpy(&ev->serverid,
  		    &ev->current_server->optinfo.serverID)) {
! 			debug_printf(LOG_NOTICE, FNAME, "can't copy server ID");
  			return (-1); /* XXX: better recovery? */
  		}
  		if (construct_reqdata(ifp, &ev->current_server->optinfo, ev)) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to construct request data");
  			return (-1); /* XXX */
  		}
***************
*** 1674,1680 ****
  		else
  			timo.tv_sec = timo.tv_usec = 0;
  
! 		dprintf(LOG_DEBUG, FNAME, "reset timer for %s to %d.%06d",
  		    ifp->ifname, (int)timo.tv_sec, (int)timo.tv_usec);
  
  		dhcp6_set_timer(&timo, ev->timer);
--- 1674,1680 ----
  		else
  			timo.tv_sec = timo.tv_usec = 0;
  
! 		debug_printf(LOG_DEBUG, FNAME, "reset timer for %s to %d.%06d",
  		    ifp->ifname, (int)timo.tv_sec, (int)timo.tv_usec);
  
  		dhcp6_set_timer(&timo, ev->timer);
***************
*** 1712,1718 ****
  	/* find the corresponding event based on the received xid */
  	ev = find_event_withid(ifp, ntohl(dh6->dh6_xid) & DH6_XIDMASK);
  	if (ev == NULL) {
! 		dprintf(LOG_INFO, FNAME, "XID mismatch");
  		return (-1);
  	}
  
--- 1712,1718 ----
  	/* find the corresponding event based on the received xid */
  	ev = find_event_withid(ifp, ntohl(dh6->dh6_xid) & DH6_XIDMASK);
  	if (ev == NULL) {
! 		debug_printf(LOG_INFO, FNAME, "XID mismatch");
  		return (-1);
  	}
  
***************
*** 1724,1736 ****
  	    state != DHCP6S_RELEASE &&
  	    (state != DHCP6S_SOLICIT ||
  	     !(ifp->send_flags & DHCIFF_RAPID_COMMIT))) {
! 		dprintf(LOG_INFO, FNAME, "unexpected reply");
  		return (-1);
  	}
  
  	/* A Reply message must contain a Server ID option */
  	if (optinfo->serverID.duid_len == 0) {
! 		dprintf(LOG_INFO, FNAME, "no server ID option");
  		return (-1);
  	}
  
--- 1724,1736 ----
  	    state != DHCP6S_RELEASE &&
  	    (state != DHCP6S_SOLICIT ||
  	     !(ifp->send_flags & DHCIFF_RAPID_COMMIT))) {
! 		debug_printf(LOG_INFO, FNAME, "unexpected reply");
  		return (-1);
  	}
  
  	/* A Reply message must contain a Server ID option */
  	if (optinfo->serverID.duid_len == 0) {
! 		debug_printf(LOG_INFO, FNAME, "no server ID option");
  		return (-1);
  	}
  
***************
*** 1739,1755 ****
  	 * client implementation) must match ours.
  	 */
  	if (optinfo->clientID.duid_len == 0) {
! 		dprintf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  	if (duidcmp(&optinfo->clientID, &client_duid)) {
! 		dprintf(LOG_INFO, FNAME, "client DUID mismatch");
  		return (-1);
  	}
  
  	/* validate authentication */
  	if (process_auth(ev->authparam, dh6, len, optinfo)) {
! 		dprintf(LOG_INFO, FNAME, "failed to process authentication");
  		return (-1);
  	}
  
--- 1739,1755 ----
  	 * client implementation) must match ours.
  	 */
  	if (optinfo->clientID.duid_len == 0) {
! 		debug_printf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  	if (duidcmp(&optinfo->clientID, &client_duid)) {
! 		debug_printf(LOG_INFO, FNAME, "client DUID mismatch");
  		return (-1);
  	}
  
  	/* validate authentication */
  	if (process_auth(ev->authparam, dh6, len, optinfo)) {
! 		debug_printf(LOG_INFO, FNAME, "failed to process authentication");
  		return (-1);
  	}
  
***************
*** 1763,1769 ****
  	if (state == DHCP6S_SOLICIT &&
  	    (ifp->send_flags & DHCIFF_RAPID_COMMIT) &&
  	    !optinfo->rapidcommit) {
! 		dprintf(LOG_INFO, FNAME, "no rapid commit");
  		return (-1);
  	}
  
--- 1763,1769 ----
  	if (state == DHCP6S_SOLICIT &&
  	    (ifp->send_flags & DHCIFF_RAPID_COMMIT) &&
  	    !optinfo->rapidcommit) {
! 		debug_printf(LOG_INFO, FNAME, "no rapid commit");
  		return (-1);
  	}
  
***************
*** 1774,1780 ****
  	 */
  	for (lv = TAILQ_FIRST(&optinfo->stcode_list); lv;
  	     lv = TAILQ_NEXT(lv, link)) {
! 		dprintf(LOG_INFO, FNAME, "status code: %s",
  		    dhcp6_stcodestr(lv->val_num16));
  	}
  
--- 1774,1780 ----
  	 */
  	for (lv = TAILQ_FIRST(&optinfo->stcode_list); lv;
  	     lv = TAILQ_NEXT(lv, link)) {
! 		debug_printf(LOG_INFO, FNAME, "status code: %s",
  		    dhcp6_stcodestr(lv->val_num16));
  	}
  
***************
*** 1838,1844 ****
  	 * configuration parameters.
  	 */
  	if (ifp->scriptpath != NULL && strlen(ifp->scriptpath) != 0) {
! 		dprintf(LOG_DEBUG, FNAME, "executes %s", ifp->scriptpath);
  		client6_script(ifp->scriptpath, state, optinfo);
  	}
  
--- 1838,1844 ----
  	 * configuration parameters.
  	 */
  	if (ifp->scriptpath != NULL && strlen(ifp->scriptpath) != 0) {
! 		debug_printf(LOG_DEBUG, FNAME, "executes %s", ifp->scriptpath);
  		client6_script(ifp->scriptpath, state, optinfo);
  	}
  
***************
*** 1856,1862 ****
  
  		ifp->timer = dhcp6_add_timer(client6_expire_refreshtime, ifp);
  		if (ifp->timer == NULL) {
! 			dprintf(LOG_WARNING, FNAME,
  			    "failed to add timer for refresh time");
  		} else {
  			struct timeval tv;
--- 1856,1862 ----
  
  		ifp->timer = dhcp6_add_timer(client6_expire_refreshtime, ifp);
  		if (ifp->timer == NULL) {
! 			debug_printf(LOG_WARNING, FNAME,
  			    "failed to add timer for refresh time");
  		} else {
  			struct timeval tv;
***************
*** 1869,1875 ****
  				 * XXX: tv_sec can overflow for an
  				 * unsigned 32bit value.
  				 */
! 				dprintf(LOG_WARNING, FNAME,
  				    "refresh time is too large: %lu",
  				    (u_int32_t)refreshtime);
  				tv.tv_sec = 0x7fffffff;	/* XXX */
--- 1869,1875 ----
  				 * XXX: tv_sec can overflow for an
  				 * unsigned 32bit value.
  				 */
! 				debug_printf(LOG_WARNING, FNAME,
  				    "refresh time is too large: %lu",
  				    (u_int32_t)refreshtime);
  				tv.tv_sec = 0x7fffffff;	/* XXX */
***************
*** 1882,1888 ****
  		 * draft-ietf-dhc-lifetime-02 clarifies that refresh time
  		 * is only used for information-request and reply exchanges.
  		 */
! 		dprintf(LOG_INFO, FNAME,
  		    "unexpected information refresh time option (ignored)");
  	}
  
--- 1882,1888 ----
  		 * draft-ietf-dhc-lifetime-02 clarifies that refresh time
  		 * is only used for information-request and reply exchanges.
  		 */
! 		debug_printf(LOG_INFO, FNAME,
  		    "unexpected information refresh time option (ignored)");
  	}
  
***************
*** 1907,1913 ****
  		check_exit();
  	}
  
! 	dprintf(LOG_DEBUG, FNAME, "got an expected reply, sleeping.");
  
  	if (infreq_mode) {
  		exit_ok = 1;
--- 1907,1913 ----
  		check_exit();
  	}
  
! 	debug_printf(LOG_DEBUG, FNAME, "got an expected reply, sleeping.");
  
  	if (infreq_mode) {
  		exit_ok = 1;
***************
*** 1950,1968 ****
  		break;
  	case DHCP6_AUTHPROTO_DELAYED:
  		if ((optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
! 			dprintf(LOG_INFO, FNAME, "server did not include "
  			    "authentication information");
  			break;
  		}
  
  		if (optinfo->authalgorithm != DHCP6_AUTHALG_HMACMD5) {
! 			dprintf(LOG_INFO, FNAME, "unknown authentication "
  			    "algorithm (%d)", optinfo->authalgorithm);
  			break;
  		}
  
  		if (optinfo->authrdm != DHCP6_AUTHRDM_MONOCOUNTER) {
! 			dprintf(LOG_INFO, FNAME,"unknown RDM (%d)",
  			    optinfo->authrdm);
  			break;
  		}
--- 1950,1968 ----
  		break;
  	case DHCP6_AUTHPROTO_DELAYED:
  		if ((optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
! 			debug_printf(LOG_INFO, FNAME, "server did not include "
  			    "authentication information");
  			break;
  		}
  
  		if (optinfo->authalgorithm != DHCP6_AUTHALG_HMACMD5) {
! 			debug_printf(LOG_INFO, FNAME, "unknown authentication "
  			    "algorithm (%d)", optinfo->authalgorithm);
  			break;
  		}
  
  		if (optinfo->authrdm != DHCP6_AUTHRDM_MONOCOUNTER) {
! 			debug_printf(LOG_INFO, FNAME,"unknown RDM (%d)",
  			    optinfo->authrdm);
  			break;
  		}
***************
*** 1972,1983 ****
  		 * we accept the message anyway (XXX).
  		 */
  		if ((authparam->flags & AUTHPARAM_FLAGS_NOPREVRD)) {
! 			dprintf(LOG_WARNING, FNAME, "previous RD value is "
  			    "unknown (accept it)");
  		} else {
  			if (dhcp6_auth_replaycheck(optinfo->authrdm,
  			    authparam->prevrd, optinfo->authrd)) {
! 				dprintf(LOG_INFO, FNAME,
  				    "possible replay attack detected");
  				break;
  			}
--- 1972,1983 ----
  		 * we accept the message anyway (XXX).
  		 */
  		if ((authparam->flags & AUTHPARAM_FLAGS_NOPREVRD)) {
! 			debug_printf(LOG_WARNING, FNAME, "previous RD value is "
  			    "unknown (accept it)");
  		} else {
  			if (dhcp6_auth_replaycheck(optinfo->authrdm,
  			    authparam->prevrd, optinfo->authrd)) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "possible replay attack detected");
  				break;
  			}
***************
*** 1994,2000 ****
  			    optinfo->delayedauth_realmlen != key->realmlen ||
  			    memcmp(optinfo->delayedauth_realmval, key->realm,
  			    key->realmlen) != 0) {
! 				dprintf(LOG_INFO, FNAME,
  				    "authentication key mismatch");
  				break;
  			}
--- 1994,2000 ----
  			    optinfo->delayedauth_realmlen != key->realmlen ||
  			    memcmp(optinfo->delayedauth_realmval, key->realm,
  			    key->realmlen) != 0) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "authentication key mismatch");
  				break;
  			}
***************
*** 2003,2014 ****
  			    optinfo->delayedauth_realmlen,
  			    optinfo->delayedauth_keyid);
  			if (key == NULL) {
! 				dprintf(LOG_INFO, FNAME, "failed to find key "
  				    "provided by the server (ID: %x)",
  				    optinfo->delayedauth_keyid);
  				break;
  			} else {
! 				dprintf(LOG_DEBUG, FNAME, "found key for "
  				    "authentication: %s", key->name);
  			}
  			authparam->key = key;
--- 2003,2014 ----
  			    optinfo->delayedauth_realmlen,
  			    optinfo->delayedauth_keyid);
  			if (key == NULL) {
! 				debug_printf(LOG_INFO, FNAME, "failed to find key "
  				    "provided by the server (ID: %x)",
  				    optinfo->delayedauth_keyid);
  				break;
  			} else {
! 				debug_printf(LOG_DEBUG, FNAME, "found key for "
  				    "authentication: %s", key->name);
  			}
  			authparam->key = key;
***************
*** 2016,2022 ****
  
  		/* check for the key lifetime */
  		if (dhcp6_validate_key(key)) {
! 			dprintf(LOG_INFO, FNAME, "key %s has expired",
  			    key->name);
  			break;
  		}
--- 2016,2022 ----
  
  		/* check for the key lifetime */
  		if (dhcp6_validate_key(key)) {
! 			debug_printf(LOG_INFO, FNAME, "key %s has expired",
  			    key->name);
  			break;
  		}
***************
*** 2025,2048 ****
  		if (dhcp6_verify_mac((char *)dh6, len, optinfo->authproto,
  		    optinfo->authalgorithm,
  		    optinfo->delayedauth_offset + sizeof(*dh6), key) == 0) {
! 			dprintf(LOG_DEBUG, FNAME, "message authentication "
  			    "validated");
  			authenticated = 1;
  		} else {
! 			dprintf(LOG_INFO, FNAME, "invalid message "
  			    "authentication");
  		}
  
  		break;
  	default:
! 		dprintf(LOG_INFO, FNAME, "server sent unsupported "
  		    "authentication protocol (%d)", optinfo->authproto);
  		break;
  	}
  
  	if (authenticated == 0) {
  		if (authparam->authproto != DHCP6_AUTHPROTO_UNDEF) {
! 			dprintf(LOG_INFO, FNAME, "message not authenticated "
  			    "while authentication required");
  
  			/*
--- 2025,2048 ----
  		if (dhcp6_verify_mac((char *)dh6, len, optinfo->authproto,
  		    optinfo->authalgorithm,
  		    optinfo->delayedauth_offset + sizeof(*dh6), key) == 0) {
! 			debug_printf(LOG_DEBUG, FNAME, "message authentication "
  			    "validated");
  			authenticated = 1;
  		} else {
! 			debug_printf(LOG_INFO, FNAME, "invalid message "
  			    "authentication");
  		}
  
  		break;
  	default:
! 		debug_printf(LOG_INFO, FNAME, "server sent unsupported "
  		    "authentication protocol (%d)", optinfo->authproto);
  		break;
  	}
  
  	if (authenticated == 0) {
  		if (authparam->authproto != DHCP6_AUTHPROTO_UNDEF) {
! 			debug_printf(LOG_INFO, FNAME, "message not authenticated "
  			    "while authentication required");
  
  			/*
***************
*** 2085,2091 ****
  			 * exchanges doesn't work.  Specification is also
  			 * unclear on this usage.
  			 */
! 			dprintf(LOG_WARNING, FNAME, "delayed authentication "
  			    "cannot be used for Information-request yet");
  			return (-1);
  		}
--- 2085,2091 ----
  			 * exchanges doesn't work.  Specification is also
  			 * unclear on this usage.
  			 */
! 			debug_printf(LOG_WARNING, FNAME, "delayed authentication "
  			    "cannot be used for Information-request yet");
  			return (-1);
  		}
***************
*** 2096,2116 ****
  		}
  
  		if (authparam->key == NULL) {
! 			dprintf(LOG_INFO, FNAME,
  			    "no authentication key for %s",
  			    dhcp6_event_statestr(ev));
  			return (-1);
  		}
  
  		if (dhcp6_validate_key(authparam->key)) {
! 			dprintf(LOG_INFO, FNAME, "key %s is invalid",
  			    authparam->key->name);
  			return (-1);
  		}
  
  		if (get_rdvalue(optinfo->authrdm, &optinfo->authrd,
  		    sizeof(optinfo->authrd))) {
! 			dprintf(LOG_ERR, FNAME, "failed to get a replay "
  			    "detection value");
  			return (-1);
  		}
--- 2096,2116 ----
  		}
  
  		if (authparam->key == NULL) {
! 			debug_printf(LOG_INFO, FNAME,
  			    "no authentication key for %s",
  			    dhcp6_event_statestr(ev));
  			return (-1);
  		}
  
  		if (dhcp6_validate_key(authparam->key)) {
! 			debug_printf(LOG_INFO, FNAME, "key %s is invalid",
  			    authparam->key->name);
  			return (-1);
  		}
  
  		if (get_rdvalue(optinfo->authrdm, &optinfo->authrd,
  		    sizeof(optinfo->authrd))) {
! 			debug_printf(LOG_ERR, FNAME, "failed to get a replay "
  			    "detection value");
  			return (-1);
  		}
***************
*** 2120,2126 ****
  		optinfo->delayedauth_realmval =
  		    malloc(optinfo->delayedauth_realmlen);
  		if (optinfo->delayedauth_realmval == NULL) {
! 			dprintf(LOG_ERR, FNAME, "failed to allocate memory "
  			    "for authentication realm");
  			return (-1);
  		}
--- 2120,2126 ----
  		optinfo->delayedauth_realmval =
  		    malloc(optinfo->delayedauth_realmlen);
  		if (optinfo->delayedauth_realmval == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "failed to allocate memory "
  			    "for authentication realm");
  			return (-1);
  		}
***************
*** 2129,2135 ****
  
  		break;
  	default:
! 		dprintf(LOG_ERR, FNAME, "unsupported authentication protocol "
  		    "%d", authparam->authproto);
  		return (-1);
  	}
--- 2129,2135 ----
  
  		break;
  	default:
! 		debug_printf(LOG_ERR, FNAME, "unsupported authentication protocol "
  		    "%d", authparam->authproto);
  		return (-1);
  	}
***************
*** 2146,2152 ****
  	va_start(ap, fmt);
  	vsnprintf(logbuf, sizeof(logbuf), fmt, ap);
  
! 	dprintf(LOG_DEBUG, FNAME, "%s", logbuf);
  	if (infreq_mode)
  		printf("%s\n", logbuf);
  
--- 2146,2152 ----
  	va_start(ap, fmt);
  	vsnprintf(logbuf, sizeof(logbuf), fmt, ap);
  
! 	debug_printf(LOG_DEBUG, FNAME, "%s", logbuf);
  	if (infreq_mode)
  		printf("%s\n", logbuf);
  
diff -crB wide-dhcpv6-20080615/dhcp6c_ia.c wide-dhcpv6-20080615-ltrx/dhcp6c_ia.c
*** wide-dhcpv6-20080615/dhcp6c_ia.c	2007-03-21 15:22:55.000000000 +0530
--- wide-dhcpv6-20080615-ltrx/dhcp6c_ia.c	2015-04-22 16:17:46.332966838 +0530
***************
*** 122,128 ****
  		 * We apply the same rule to IA_PD as well.
  		 */
  		if (iav->val_ia.t2 != 0 && iav->val_ia.t1 > iav->val_ia.t2) {
! 			dprintf(LOG_INFO, FNAME,
  			    "invalid IA: T1(%lu) > T2(%lu)",
  			    iav->val_ia.t1, iav->val_ia.t2);
  			continue;
--- 122,128 ----
  		 * We apply the same rule to IA_PD as well.
  		 */
  		if (iav->val_ia.t2 != 0 && iav->val_ia.t1 > iav->val_ia.t2) {
! 			debug_printf(LOG_INFO, FNAME,
  			    "invalid IA: T1(%lu) > T2(%lu)",
  			    iav->val_ia.t1, iav->val_ia.t2);
  			continue;
***************
*** 131,144 ****
  		/* locate the local IA or make a new one */
  		ia = get_ia(iatype, ifp, iac, iav, serverid);
  		if (ia == NULL) {
! 			dprintf(LOG_WARNING, FNAME, "failed to get an IA "
  			    "type: %s, ID: %u", iastr(iac->type), iac->iaid);
  			continue;
  		}
  
  		/* update authentication parameters */
  		if (update_authparam(ia, authparam)) {
! 			dprintf(LOG_WARNING, FNAME, "failed to update "
  			    "authentication param for IA "
  			    "type: %s, ID: %u", iastr(iac->type), iac->iaid);
  			remove_ia(ia);
--- 131,144 ----
  		/* locate the local IA or make a new one */
  		ia = get_ia(iatype, ifp, iac, iav, serverid);
  		if (ia == NULL) {
! 			debug_printf(LOG_WARNING, FNAME, "failed to get an IA "
  			    "type: %s, ID: %u", iastr(iac->type), iac->iaid);
  			continue;
  		}
  
  		/* update authentication parameters */
  		if (update_authparam(ia, authparam)) {
! 			debug_printf(LOG_WARNING, FNAME, "failed to update "
  			    "authentication param for IA "
  			    "type: %s, ID: %u", iastr(iac->type), iac->iaid);
  			remove_ia(ia);
***************
*** 155,161 ****
  				if (update_prefix(ia, &siav->val_prefix6,
  				    &iapdc->iapd_pif_list, ifp, &ia->ctl,
  				    callback)) {
! 					dprintf(LOG_NOTICE, FNAME,
  					    "failed to update a prefix %s/%d",
  					    in6addr2str(&siav->val_prefix6.addr, 0),
  					    siav->val_prefix6.plen);
--- 155,161 ----
  				if (update_prefix(ia, &siav->val_prefix6,
  				    &iapdc->iapd_pif_list, ifp, &ia->ctl,
  				    callback)) {
! 					debug_printf(LOG_NOTICE, FNAME,
  					    "failed to update a prefix %s/%d",
  					    in6addr2str(&siav->val_prefix6.addr, 0),
  					    siav->val_prefix6.plen);
***************
*** 165,177 ****
  				ianac = (struct iana_conf *)iac;
  				if (update_address(ia, &siav->val_statefuladdr6,
  				    ifp, &ia->ctl, callback)) {
! 					dprintf(LOG_NOTICE, FNAME,
  					    "failed to update an address %s",
  					    in6addr2str(&siav->val_statefuladdr6.addr, 0));
  				}
  				break;
  			case DHCP6_LISTVAL_STCODE:
! 				dprintf(LOG_INFO, FNAME,
  				    "status code for %s-%lu: %s",
  				    iastr(iatype), iav->val_ia.iaid,
  				    dhcp6_stcodestr(siav->val_num16));
--- 165,177 ----
  				ianac = (struct iana_conf *)iac;
  				if (update_address(ia, &siav->val_statefuladdr6,
  				    ifp, &ia->ctl, callback)) {
! 					debug_printf(LOG_NOTICE, FNAME,
  					    "failed to update an address %s",
  					    in6addr2str(&siav->val_statefuladdr6.addr, 0));
  				}
  				break;
  			case DHCP6_LISTVAL_STCODE:
! 				debug_printf(LOG_INFO, FNAME,
  				    "status code for %s-%lu: %s",
  				    iastr(iatype), iav->val_ia.iaid,
  				    dhcp6_stcodestr(siav->val_num16));
***************
*** 187,193 ****
  					 * [RFC3315 18.1.8]
  					 * XXX: what about the PD case?
  					 */
! 					dprintf(LOG_INFO, FNAME,
  					    "receive NoBinding against "
  					    "renew/rebind for %s-%lu",
  					    iastr(ia->conf->type),
--- 187,193 ----
  					 * [RFC3315 18.1.8]
  					 * XXX: what about the PD case?
  					 */
! 					debug_printf(LOG_INFO, FNAME,
  					    "receive NoBinding against "
  					    "renew/rebind for %s-%lu",
  					    iastr(ia->conf->type),
***************
*** 197,210 ****
  				}
  				break;
  			default:
! 				dprintf(LOG_ERR, FNAME, "impossible case");
  				goto nextia;
  			}
  		}
  
  		/* see if this IA is still valid.  if not, remove it. */
  		if (ia->ctl == NULL || !(*ia->ctl->isvalid)(ia->ctl)) {
! 			dprintf(LOG_DEBUG, FNAME, "IA %s-%lu is invalidated",
  			    iastr(ia->conf->type), ia->conf->iaid);
  			remove_ia(ia);
  			continue;
--- 197,210 ----
  				}
  				break;
  			default:
! 				debug_printf(LOG_ERR, FNAME, "impossible case");
  				goto nextia;
  			}
  		}
  
  		/* see if this IA is still valid.  if not, remove it. */
  		if (ia->ctl == NULL || !(*ia->ctl->isvalid)(ia->ctl)) {
! 			debug_printf(LOG_DEBUG, FNAME, "IA %s-%lu is invalidated",
  			    iastr(ia->conf->type), ia->conf->iaid);
  			remove_ia(ia);
  			continue;
***************
*** 236,242 ****
  			if (ia->t1 > ia->t2)
  				ia->t1 = ia->t2 * 5 / 8;
  
! 			dprintf(LOG_INFO, FNAME, "T1(%lu) and/or T2(%lu) "
  			    "is locally determined",  ia->t1, ia->t2);
  		}
  
--- 236,242 ----
  			if (ia->t1 > ia->t2)
  				ia->t1 = ia->t2 * 5 / 8;
  
! 			debug_printf(LOG_INFO, FNAME, "T1(%lu) and/or T2(%lu) "
  			    "is locally determined",  ia->t1, ia->t2);
  		}
  
***************
*** 246,256 ****
  		 * without renewal.
  		 */
  		if (ia->t2 < DHCP6_DURATION_MIN) {
! 			dprintf(LOG_INFO, FNAME, "T1 (%lu) or T2 (%lu) "
  			    "is too small", ia->t1, ia->t2);
  			ia->t2 = DHCP6_DURATION_MIN;
  			ia->t1 = ia->t2 * 5 / 8;
! 			dprintf(LOG_INFO, "", "  adjusted to %lu and %lu",
  			    ia->t1, ia->t2);
  		}
  
--- 246,256 ----
  		 * without renewal.
  		 */
  		if (ia->t2 < DHCP6_DURATION_MIN) {
! 			debug_printf(LOG_INFO, FNAME, "T1 (%lu) or T2 (%lu) "
  			    "is too small", ia->t1, ia->t2);
  			ia->t2 = DHCP6_DURATION_MIN;
  			ia->t1 = ia->t2 * 5 / 8;
! 			debug_printf(LOG_INFO, "", "  adjusted to %lu and %lu",
  			    ia->t1, ia->t2);
  		}
  
***************
*** 262,268 ****
  			if (ia->timer == NULL)
  				ia->timer = dhcp6_add_timer(ia_timo, ia);
  			if (ia->timer == NULL) {
! 				dprintf(LOG_ERR, FNAME,
  				    "failed to add IA timer");
  				remove_ia(ia); /* XXX */
  				continue;
--- 262,268 ----
  			if (ia->timer == NULL)
  				ia->timer = dhcp6_add_timer(ia_timo, ia);
  			if (ia->timer == NULL) {
! 				debug_printf(LOG_ERR, FNAME,
  				    "failed to add IA timer");
  				remove_ia(ia); /* XXX */
  				continue;
***************
*** 289,295 ****
  
  	if (ia->authparam == NULL) {
  		if ((ia->authparam = copy_authparam(authparam)) == NULL) {
! 			dprintf(LOG_WARNING, FNAME,
  			    "failed to copy authparam");
  			return (-1);
  		}
--- 289,295 ----
  
  	if (ia->authparam == NULL) {
  		if ((ia->authparam = copy_authparam(authparam)) == NULL) {
! 			debug_printf(LOG_WARNING, FNAME,
  			    "failed to copy authparam");
  			return (-1);
  		}
***************
*** 311,321 ****
  	struct dhcp6_event *ev;
  	struct dhcp6_eventdata *evd;
  
! 	dprintf(LOG_DEBUG, FNAME, "re-establishing IA: %s-%lu", 
  	    iastr(ia->conf->type), ia->conf->iaid);
  
  	if (ia->state != IAS_RENEW && ia->state != IAS_REBIND) {
! 		dprintf(LOG_ERR, FNAME, "internal error (invalid IA status)");
  		exit(1);	/* XXX */
  	}
  
--- 311,321 ----
  	struct dhcp6_event *ev;
  	struct dhcp6_eventdata *evd;
  
! 	debug_printf(LOG_DEBUG, FNAME, "re-establishing IA: %s-%lu", 
  	    iastr(ia->conf->type), ia->conf->iaid);
  
  	if (ia->state != IAS_RENEW && ia->state != IAS_REBIND) {
! 		debug_printf(LOG_ERR, FNAME, "internal error (invalid IA status)");
  		exit(1);	/* XXX */
  	}
  
***************
*** 333,351 ****
  		dhcp6_remove_timer(&ia->timer);
  
  	if ((ev = dhcp6_create_event(ia->ifp, DHCP6S_REQUEST)) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to create a new event");
  		goto fail;
  	}
  	TAILQ_INSERT_TAIL(&ia->ifp->event_list, ev, link);
  
  	if ((ev->timer = dhcp6_add_timer(client6_timo, ev)) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to create a new event timer");
  		goto fail;
  	}
  
  	if ((evd = malloc(sizeof(*evd))) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to create a new event data");
  		goto fail;
  	}
--- 333,351 ----
  		dhcp6_remove_timer(&ia->timer);
  
  	if ((ev = dhcp6_create_event(ia->ifp, DHCP6S_REQUEST)) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to create a new event");
  		goto fail;
  	}
  	TAILQ_INSERT_TAIL(&ia->ifp->event_list, ev, link);
  
  	if ((ev->timer = dhcp6_add_timer(client6_timo, ev)) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to create a new event timer");
  		goto fail;
  	}
  
  	if ((evd = malloc(sizeof(*evd))) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to create a new event data");
  		goto fail;
  	}
***************
*** 354,360 ****
  	TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
  
  	if (duidcpy(&ev->serverid, &ia->serverid)) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  
--- 354,360 ----
  	TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
  
  	if (duidcpy(&ev->serverid, &ia->serverid)) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  
***************
*** 365,371 ****
  	if (ia->ctl && ia->ctl->reestablish_data) {
  		if ((*ia->ctl->reestablish_data)(ia->ctl, &iaparam,
  		    &ia->evdata, evd)) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to make reestablish data");
  			goto fail;
  		}
--- 365,371 ----
  	if (ia->ctl && ia->ctl->reestablish_data) {
  		if ((*ia->ctl->reestablish_data)(ia->ctl, &iaparam,
  		    &ia->evdata, evd)) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to make reestablish data");
  			goto fail;
  		}
***************
*** 373,379 ****
  
  	if (ia->authparam != NULL) {
  		if ((ev->authparam = copy_authparam(ia->authparam)) == NULL) {
! 			dprintf(LOG_WARNING, FNAME,
  			    "failed to copy authparam");
  			goto fail;
  		}
--- 373,379 ----
  
  	if (ia->authparam != NULL) {
  		if ((ev->authparam = copy_authparam(ia->authparam)) == NULL) {
! 			debug_printf(LOG_WARNING, FNAME,
  			    "failed to copy authparam");
  			goto fail;
  		}
***************
*** 402,408 ****
  {
  	/* see if this IA is still valid.  if not, remove it. */
  	if (ia->ctl == NULL || !(*ia->ctl->isvalid)(ia->ctl)) {
! 		dprintf(LOG_DEBUG, FNAME, "IA %s-%lu is invalidated",
  		    iastr(ia->conf->type), ia->conf->iaid);
  		remove_ia(ia);
  	}
--- 402,408 ----
  {
  	/* see if this IA is still valid.  if not, remove it. */
  	if (ia->ctl == NULL || !(*ia->ctl->isvalid)(ia->ctl)) {
! 		debug_printf(LOG_DEBUG, FNAME, "IA %s-%lu is invalidated",
  		    iastr(ia->conf->type), ia->conf->iaid);
  		remove_ia(ia);
  	}
***************
*** 441,470 ****
  	struct dhcp6_event *ev;
  	struct dhcp6_eventdata *evd;
  
! 	dprintf(LOG_DEBUG, FNAME, "release an IA: %s-%lu",
  	    iastr(ia->conf->type), ia->conf->iaid);
  
  	if ((ev = dhcp6_create_event(ia->ifp, DHCP6S_RELEASE))
  	    == NULL) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to create a new event");
  		goto fail;
  	}
  	TAILQ_INSERT_TAIL(&ia->ifp->event_list, ev, link);
  
  
  	if ((ev->timer = dhcp6_add_timer(client6_timo, ev)) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to create a new event timer");
  		goto fail;
  	}
  
  	if (duidcpy(&ev->serverid, &ia->serverid)) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  
  	if ((evd = malloc(sizeof(*evd))) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to create a new event data");
  		goto fail;
  	}
--- 441,470 ----
  	struct dhcp6_event *ev;
  	struct dhcp6_eventdata *evd;
  
! 	debug_printf(LOG_DEBUG, FNAME, "release an IA: %s-%lu",
  	    iastr(ia->conf->type), ia->conf->iaid);
  
  	if ((ev = dhcp6_create_event(ia->ifp, DHCP6S_RELEASE))
  	    == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to create a new event");
  		goto fail;
  	}
  	TAILQ_INSERT_TAIL(&ia->ifp->event_list, ev, link);
  
  
  	if ((ev->timer = dhcp6_add_timer(client6_timo, ev)) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to create a new event timer");
  		goto fail;
  	}
  
  	if (duidcpy(&ev->serverid, &ia->serverid)) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  
  	if ((evd = malloc(sizeof(*evd))) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to create a new event data");
  		goto fail;
  	}
***************
*** 476,482 ****
  
  	if (ia->ctl && ia->ctl->release_data) {
  		if ((*ia->ctl->release_data)(ia->ctl, &iaparam, NULL, evd)) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to make release data");
  			goto fail;
  		}
--- 476,482 ----
  
  	if (ia->ctl && ia->ctl->release_data) {
  		if ((*ia->ctl->release_data)(ia->ctl, &iaparam, NULL, evd)) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to make release data");
  			goto fail;
  		}
***************
*** 489,495 ****
  
  	if (ia->authparam != NULL) {
  		if ((ev->authparam = copy_authparam(ia->authparam)) == NULL) {
! 			dprintf(LOG_WARNING, FNAME,
  			    "failed to copy authparam");
  			goto fail;
  		}
--- 489,495 ----
  
  	if (ia->authparam != NULL) {
  		if ((ev->authparam = copy_authparam(ia->authparam)) == NULL) {
! 			debug_printf(LOG_WARNING, FNAME,
  			    "failed to copy authparam");
  			goto fail;
  		}
***************
*** 513,519 ****
  	struct ia_conf *iac = ia->conf;
  	struct dhcp6_if *ifp = ia->ifp;
  
! 	dprintf(LOG_DEBUG, FNAME, "remove an IA: %s-%lu",
  	    iastr(ia->conf->type), ia->conf->iaid);
  
  	TAILQ_REMOVE(&iac->iadata, ia, link);
--- 513,519 ----
  	struct ia_conf *iac = ia->conf;
  	struct dhcp6_if *ifp = ia->ifp;
  
! 	debug_printf(LOG_DEBUG, FNAME, "remove an IA: %s-%lu",
  	    iastr(ia->conf->type), ia->conf->iaid);
  
  	TAILQ_REMOVE(&iac->iadata, ia, link);
***************
*** 553,559 ****
  	struct timeval timo;
  	int dhcpstate;
  
! 	dprintf(LOG_DEBUG, FNAME, "IA timeout for %s-%lu, state=%s",
  	    iastr(ia->conf->type), ia->conf->iaid, statestr(ia->state));
  
  	/* cancel the current event for the prefix. */
--- 553,559 ----
  	struct timeval timo;
  	int dhcpstate;
  
! 	debug_printf(LOG_DEBUG, FNAME, "IA timeout for %s-%lu, state=%s",
  	    iastr(ia->conf->type), ia->conf->iaid, statestr(ia->state));
  
  	/* cancel the current event for the prefix. */
***************
*** 586,610 ****
  		dhcp6_remove_timer(&ia->timer);
  		break;
  	default:
! 		dprintf(LOG_ERR, FNAME, "invalid IA state (%d)",
  		    (int)ia->state);
  		return (NULL);	/* XXX */
  	}
  
  	if ((ev = dhcp6_create_event(ia->ifp, dhcpstate)) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to create a new event");
  		goto fail;
  	}
  	TAILQ_INSERT_TAIL(&ia->ifp->event_list, ev, link);
  
  	if ((ev->timer = dhcp6_add_timer(client6_timo, ev)) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to create a new event timer");
  		goto fail;
  	}
  
  	if ((evd = malloc(sizeof(*evd))) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to create a new event data");
  		goto fail;
  	}
--- 586,610 ----
  		dhcp6_remove_timer(&ia->timer);
  		break;
  	default:
! 		debug_printf(LOG_ERR, FNAME, "invalid IA state (%d)",
  		    (int)ia->state);
  		return (NULL);	/* XXX */
  	}
  
  	if ((ev = dhcp6_create_event(ia->ifp, dhcpstate)) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to create a new event");
  		goto fail;
  	}
  	TAILQ_INSERT_TAIL(&ia->ifp->event_list, ev, link);
  
  	if ((ev->timer = dhcp6_add_timer(client6_timo, ev)) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to create a new event timer");
  		goto fail;
  	}
  
  	if ((evd = malloc(sizeof(*evd))) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to create a new event data");
  		goto fail;
  	}
***************
*** 614,620 ****
  
  	if (ia->state == IAS_RENEW) {
  		if (duidcpy(&ev->serverid, &ia->serverid)) {
! 			dprintf(LOG_NOTICE, FNAME, "failed to copy server ID");
  			goto fail;
  		}
  	}
--- 614,620 ----
  
  	if (ia->state == IAS_RENEW) {
  		if (duidcpy(&ev->serverid, &ia->serverid)) {
! 			debug_printf(LOG_NOTICE, FNAME, "failed to copy server ID");
  			goto fail;
  		}
  	}
***************
*** 627,633 ****
  		if (ia->ctl && ia->ctl->renew_data) {
  			if ((*ia->ctl->renew_data)(ia->ctl, &iaparam,
  			    &ia->evdata, evd)) {
! 				dprintf(LOG_NOTICE, FNAME,
  				    "failed to make renew data");
  				goto fail;
  			}
--- 627,633 ----
  		if (ia->ctl && ia->ctl->renew_data) {
  			if ((*ia->ctl->renew_data)(ia->ctl, &iaparam,
  			    &ia->evdata, evd)) {
! 				debug_printf(LOG_NOTICE, FNAME,
  				    "failed to make renew data");
  				goto fail;
  			}
***************
*** 637,643 ****
  		if (ia->ctl && ia->ctl->rebind_data) {
  			if ((*ia->ctl->rebind_data)(ia->ctl, &iaparam,
  			    &ia->evdata, evd)) {
! 				dprintf(LOG_NOTICE, FNAME,
  				    "failed to make rebind data");
  				goto fail;
  			}
--- 637,643 ----
  		if (ia->ctl && ia->ctl->rebind_data) {
  			if ((*ia->ctl->rebind_data)(ia->ctl, &iaparam,
  			    &ia->evdata, evd)) {
! 				debug_printf(LOG_NOTICE, FNAME,
  				    "failed to make rebind data");
  				goto fail;
  			}
***************
*** 653,659 ****
  
  	if (ia->authparam != NULL) {
  		if ((ev->authparam = copy_authparam(ia->authparam)) == NULL) {
! 			dprintf(LOG_WARNING, FNAME,
  			    "failed to copy authparam");
  			goto fail;
  		}
--- 653,659 ----
  
  	if (ia->authparam != NULL) {
  		if ((ev->authparam = copy_authparam(ia->authparam)) == NULL) {
! 			debug_printf(LOG_WARNING, FNAME,
  			    "failed to copy authparam");
  			goto fail;
  		}
***************
*** 693,705 ****
  	int create = 0;
  
  	if (duidcpy(&newserver, serverid)) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to copy server ID");
  		return (NULL);
  	}
  
  	if ((ia = find_ia(iac, type, iaparam->val_ia.iaid)) == NULL) {
  		if ((ia = malloc(sizeof(*ia))) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME, "memory allocation failed");
  			duidfree(&newserver); /* XXX */
  			return (NULL);
  		}
--- 693,705 ----
  	int create = 0;
  
  	if (duidcpy(&newserver, serverid)) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to copy server ID");
  		return (NULL);
  	}
  
  	if ((ia = find_ia(iac, type, iaparam->val_ia.iaid)) == NULL) {
  		if ((ia = malloc(sizeof(*ia))) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME, "memory allocation failed");
  			duidfree(&newserver); /* XXX */
  			return (NULL);
  		}
***************
*** 718,724 ****
  	ia->ifp = ifp;
  	ia->serverid = newserver;
  
! 	dprintf(LOG_DEBUG, FNAME, "%s an IA: %s-%lu",
  	    create ? "make" : "update", iastr(type), ia->conf->iaid);
  
  	return (ia);
--- 718,724 ----
  	ia->ifp = ifp;
  	ia->serverid = newserver;
  
! 	debug_printf(LOG_DEBUG, FNAME, "%s an IA: %s-%lu",
  	    create ? "make" : "update", iastr(type), ia->conf->iaid);
  
  	return (ia);
diff -crB wide-dhcpv6-20080615/dhcp6c_script.c wide-dhcpv6-20080615-ltrx/dhcp6c_script.c
*** wide-dhcpv6-20080615/dhcp6c_script.c	2015-04-22 16:16:38.356482549 +0530
--- wide-dhcpv6-20080615-ltrx/dhcp6c_script.c	2015-04-22 16:17:46.336966867 +0530
***************
*** 156,162 ****
  
  	/* allocate an environments array */
  	if ((envp = malloc(sizeof (char *) * envc)) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to allocate environment buffer");
  		return -1;
  	}
--- 156,162 ----
  
  	/* allocate an environments array */
  	if ((envp = malloc(sizeof (char *) * envc)) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to allocate environment buffer");
  		return -1;
  	}
***************
*** 168,174 ****
  	i = 0;
  	/* reason */
  	if ((envp[i++] = strdup(reason)) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to allocate reason strings");
  		ret = -1;
  		goto clean;
--- 168,174 ----
  	i = 0;
  	/* reason */
  	if ((envp[i++] = strdup(reason)) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to allocate reason strings");
  		ret = -1;
  		goto clean;
***************
*** 178,184 ****
  		elen = sizeof (dnsserver_str) +
  		    (INET6_ADDRSTRLEN + 1) * dnsservers + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for DNS servers");
  			ret = -1;
  			goto clean;
--- 178,184 ----
  		elen = sizeof (dnsserver_str) +
  		    (INET6_ADDRSTRLEN + 1) * dnsservers + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for DNS servers");
  			ret = -1;
  			goto clean;
***************
*** 198,204 ****
  		elen = sizeof (ntpserver_str) +
  		    (INET6_ADDRSTRLEN + 1) * ntpservers + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for NTP servers");
  			ret = -1;
  			goto clean;
--- 198,204 ----
  		elen = sizeof (ntpserver_str) +
  		    (INET6_ADDRSTRLEN + 1) * ntpservers + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for NTP servers");
  			ret = -1;
  			goto clean;
***************
*** 218,224 ****
  	if (dnsnamelen) {
  		elen = sizeof (dnsname_str) + dnsnamelen + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for DNS name");
  			ret = -1;
  			goto clean;
--- 218,224 ----
  	if (dnsnamelen) {
  		elen = sizeof (dnsname_str) + dnsnamelen + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for DNS name");
  			ret = -1;
  			goto clean;
***************
*** 250,256 ****
  		elen = sizeof (sipserver_str) +
  		    (INET6_ADDRSTRLEN + 1) * sipservers + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for SIP servers");
  			ret = -1;
  			goto clean;
--- 250,256 ----
  		elen = sizeof (sipserver_str) +
  		    (INET6_ADDRSTRLEN + 1) * sipservers + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for SIP servers");
  			ret = -1;
  			goto clean;
***************
*** 269,275 ****
  	if (sipnamelen) {
  		elen = sizeof (sipname_str) + sipnamelen + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for SIP domain name");
  			ret = -1;
  			goto clean;
--- 269,275 ----
  	if (sipnamelen) {
  		elen = sizeof (sipname_str) + sipnamelen + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for SIP domain name");
  			ret = -1;
  			goto clean;
***************
*** 287,293 ****
  		elen = sizeof (nisserver_str) +
  		    (INET6_ADDRSTRLEN + 1) * nisservers + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for NIS servers");
  			ret = -1;
  			goto clean;
--- 287,293 ----
  		elen = sizeof (nisserver_str) +
  		    (INET6_ADDRSTRLEN + 1) * nisservers + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for NIS servers");
  			ret = -1;
  			goto clean;
***************
*** 306,312 ****
  	if (nisnamelen) {
  		elen = sizeof (nisname_str) + nisnamelen + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for NIS domain name");
  			ret = -1;
  			goto clean;
--- 306,312 ----
  	if (nisnamelen) {
  		elen = sizeof (nisname_str) + nisnamelen + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for NIS domain name");
  			ret = -1;
  			goto clean;
***************
*** 324,330 ****
  		elen = sizeof (nispserver_str) +
  		    (INET6_ADDRSTRLEN + 1) * nispservers + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for NIS+ servers");
  			ret = -1;
  			goto clean;
--- 324,330 ----
  		elen = sizeof (nispserver_str) +
  		    (INET6_ADDRSTRLEN + 1) * nispservers + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for NIS+ servers");
  			ret = -1;
  			goto clean;
***************
*** 343,349 ****
  	if (nispnamelen) {
  		elen = sizeof (nispname_str) + nispnamelen + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for NIS+ domain name");
  			ret = -1;
  			goto clean;
--- 343,349 ----
  	if (nispnamelen) {
  		elen = sizeof (nispname_str) + nispnamelen + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for NIS+ domain name");
  			ret = -1;
  			goto clean;
***************
*** 361,367 ****
  		elen = sizeof (bcmcsserver_str) +
  		    (INET6_ADDRSTRLEN + 1) * bcmcsservers + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for BCMC servers");
  			ret = -1;
  			goto clean;
--- 361,367 ----
  		elen = sizeof (bcmcsserver_str) +
  		    (INET6_ADDRSTRLEN + 1) * bcmcsservers + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for BCMC servers");
  			ret = -1;
  			goto clean;
***************
*** 380,386 ****
  	if (bcmcsnamelen) {
  		elen = sizeof (bcmcsname_str) + bcmcsnamelen + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for BCMC domain name");
  			ret = -1;
  			goto clean;
--- 380,386 ----
  	if (bcmcsnamelen) {
  		elen = sizeof (bcmcsname_str) + bcmcsnamelen + 1;
  		if ((s = envp[i++] = malloc(elen)) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to allocate strings for BCMC domain name");
  			ret = -1;
  			goto clean;
***************
*** 397,403 ****
  	/* launch the script */
  	pid = fork();
  	if (pid < 0) {
! 		dprintf(LOG_ERR, FNAME, "failed to fork: %s", strerror(errno));
  		ret = -1;
  		goto clean;
  	} else if (pid) {
--- 397,403 ----
  	/* launch the script */
  	pid = fork();
  	if (pid < 0) {
! 		debug_printf(LOG_ERR, FNAME, "failed to fork: %s", strerror(errno));
  		ret = -1;
  		goto clean;
  	} else if (pid) {
***************
*** 408,416 ****
  		} while (wpid != pid && wpid > 0);
  
  		if (wpid < 0)
! 			dprintf(LOG_ERR, FNAME, "wait: %s", strerror(errno));
  		else {
! 			dprintf(LOG_DEBUG, FNAME,
  			    "script \"%s\" terminated", scriptpath);
  		}
  	} else {
--- 408,416 ----
  		} while (wpid != pid && wpid > 0);
  
  		if (wpid < 0)
! 			debug_printf(LOG_ERR, FNAME, "wait: %s", strerror(errno));
  		else {
! 			debug_printf(LOG_DEBUG, FNAME,
  			    "script \"%s\" terminated", scriptpath);
  		}
  	} else {
***************
*** 421,427 ****
  		argv[1] = NULL;
  
  		if (safefile(scriptpath)) {
! 			dprintf(LOG_ERR, FNAME,
  			    "script \"%s\" cannot be executed safely",
  			    scriptpath);
  			exit(1);
--- 421,427 ----
  		argv[1] = NULL;
  
  		if (safefile(scriptpath)) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "script \"%s\" cannot be executed safely",
  			    scriptpath);
  			exit(1);
***************
*** 437,443 ****
  
  		execve(scriptpath, argv, envp);
  
! 		dprintf(LOG_ERR, FNAME, "child: exec failed: %s",
  		    strerror(errno));
  		exit(0);
  	}
--- 437,443 ----
  
  		execve(scriptpath, argv, envp);
  
! 		debug_printf(LOG_ERR, FNAME, "child: exec failed: %s",
  		    strerror(errno));
  		exit(0);
  	}
diff -crB wide-dhcpv6-20080615/dhcp6_ctl.c wide-dhcpv6-20080615-ltrx/dhcp6_ctl.c
*** wide-dhcpv6-20080615/dhcp6_ctl.c	2007-03-21 15:22:53.000000000 +0530
--- wide-dhcpv6-20080615-ltrx/dhcp6_ctl.c	2015-04-22 16:17:46.304966640 +0530
***************
*** 93,124 ****
  	hints.ai_protocol = IPPROTO_TCP;
  	error = getaddrinfo(addr, port, &hints, &res);
  	if (error) {
! 		dprintf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		return (-1);
  	}
  	ctlsock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  	if (ctlsock < 0) {
! 		dprintf(LOG_ERR, FNAME, "socket(control sock): %s",
  		    strerror(errno));
  		goto fail;
  	}
  	on = 1;
  	if (setsockopt(ctlsock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on))
  	    < 0) {
! 		dprintf(LOG_ERR, FNAME,
  		    "setsockopt(control sock, SO_REUSEADDR: %s",
  		    strerror(errno));
  		goto fail;
  	}
  	if (bind(ctlsock, res->ai_addr, res->ai_addrlen) < 0) {
! 		dprintf(LOG_ERR, FNAME, "bind(control sock): %s",
  		    strerror(errno));
  		goto fail;
  	}
  	freeaddrinfo(res);
  	if (listen(ctlsock, 1)) {
! 		dprintf(LOG_ERR, FNAME, "listen(control sock): %s",
  		    strerror(errno));
  		goto fail;
  	}
--- 93,124 ----
  	hints.ai_protocol = IPPROTO_TCP;
  	error = getaddrinfo(addr, port, &hints, &res);
  	if (error) {
! 		debug_printf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		return (-1);
  	}
  	ctlsock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  	if (ctlsock < 0) {
! 		debug_printf(LOG_ERR, FNAME, "socket(control sock): %s",
  		    strerror(errno));
  		goto fail;
  	}
  	on = 1;
  	if (setsockopt(ctlsock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on))
  	    < 0) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "setsockopt(control sock, SO_REUSEADDR: %s",
  		    strerror(errno));
  		goto fail;
  	}
  	if (bind(ctlsock, res->ai_addr, res->ai_addrlen) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "bind(control sock): %s",
  		    strerror(errno));
  		goto fail;
  	}
  	freeaddrinfo(res);
  	if (listen(ctlsock, 1)) {
! 		debug_printf(LOG_ERR, FNAME, "listen(control sock): %s",
  		    strerror(errno));
  		goto fail;
  	}
***************
*** 126,132 ****
  	TAILQ_INIT(&commandqueue_head);
  
  	if (max <= 0) {
! 		dprintf(LOG_ERR, FNAME,
  		    "invalid maximum number of commands (%d)", max_commands);
  		goto fail;
  	}
--- 126,132 ----
  	TAILQ_INIT(&commandqueue_head);
  
  	if (max <= 0) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "invalid maximum number of commands (%d)", max_commands);
  		goto fail;
  	}
***************
*** 159,185 ****
  	*digestlenp = MD5_DIGESTLENGTH;
  
  	if ((fp = fopen(keyfile, "r")) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "failed to open %s: %s", keyfile,
  		    strerror(errno));
  		return (-1);
  	}
  	if (fgets(line, sizeof(line), fp) == NULL && ferror(fp)) {
! 		dprintf(LOG_ERR, FNAME, "failed to read key file: %s",
  		    strerror(errno));
  		goto fail;
  	}
  	if ((secretlen = base64_decodestring(line, secret, sizeof(secret)))
  	    < 0) {
! 		dprintf(LOG_ERR, FNAME, "failed to decode base64 string");
  		goto fail;
  	}
  	if ((ctlkey = malloc(sizeof(*ctlkey))) == NULL) {
! 		dprintf(LOG_WARNING, FNAME, "failed to allocate control key");
  		goto fail;
  	}
  	memset(ctlkey, 0, sizeof(*ctlkey));
  	if ((ctlkey->secret = malloc(secretlen)) == NULL) {
! 		dprintf(LOG_WARNING, FNAME, "failed to allocate secret key");
  		goto fail;
  	}
  	ctlkey->secretlen = (size_t)secretlen;
--- 159,185 ----
  	*digestlenp = MD5_DIGESTLENGTH;
  
  	if ((fp = fopen(keyfile, "r")) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "failed to open %s: %s", keyfile,
  		    strerror(errno));
  		return (-1);
  	}
  	if (fgets(line, sizeof(line), fp) == NULL && ferror(fp)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to read key file: %s",
  		    strerror(errno));
  		goto fail;
  	}
  	if ((secretlen = base64_decodestring(line, secret, sizeof(secret)))
  	    < 0) {
! 		debug_printf(LOG_ERR, FNAME, "failed to decode base64 string");
  		goto fail;
  	}
  	if ((ctlkey = malloc(sizeof(*ctlkey))) == NULL) {
! 		debug_printf(LOG_WARNING, FNAME, "failed to allocate control key");
  		goto fail;
  	}
  	memset(ctlkey, 0, sizeof(*ctlkey));
  	if ((ctlkey->secret = malloc(secretlen)) == NULL) {
! 		debug_printf(LOG_WARNING, FNAME, "failed to allocate secret key");
  		goto fail;
  	}
  	ctlkey->secretlen = (size_t)secretlen;
***************
*** 214,237 ****
  
  	fromlen = sizeof(from_ss);
  	if ((s = accept(sl, from, &fromlen)) < 0) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "failed to accept control connection: %s",
  		    strerror(errno));
  		return (-1);
  	}
  
! 	dprintf(LOG_DEBUG, FNAME, "accept control connection from %s",
  	    addr2str(from));
  
  	if (max_commands <= 0) {
! 		dprintf(LOG_ERR, FNAME, "command queue is not initialized");
  		close(s);
  		return (-1);
  	}
  
  	new = malloc(sizeof(*new));
  	if (new == NULL) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "failed to allocate new command context");
  		goto fail;
  	}
--- 214,237 ----
  
  	fromlen = sizeof(from_ss);
  	if ((s = accept(sl, from, &fromlen)) < 0) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "failed to accept control connection: %s",
  		    strerror(errno));
  		return (-1);
  	}
  
! 	debug_printf(LOG_DEBUG, FNAME, "accept control connection from %s",
  	    addr2str(from));
  
  	if (max_commands <= 0) {
! 		debug_printf(LOG_ERR, FNAME, "command queue is not initialized");
  		close(s);
  		return (-1);
  	}
  
  	new = malloc(sizeof(*new));
  	if (new == NULL) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "failed to allocate new command context");
  		goto fail;
  	}
***************
*** 240,246 ****
  	if (commands == max_commands) {
  		ctx = TAILQ_FIRST(&commandqueue_head);
  
! 		dprintf(LOG_INFO, FNAME, "command queue is full. "
  		    "drop the oldest one (fd=%d)", ctx->s);
  
  		TAILQ_REMOVE(&commandqueue_head, ctx, link);
--- 240,246 ----
  	if (commands == max_commands) {
  		ctx = TAILQ_FIRST(&commandqueue_head);
  
! 		debug_printf(LOG_INFO, FNAME, "command queue is full. "
  		    "drop the oldest one (fd=%d)", ctx->s);
  
  		TAILQ_REMOVE(&commandqueue_head, ctx, link);
***************
*** 271,277 ****
  	free(ctx);
  
  	if (commands == 0) {
! 		dprintf(LOG_ERR, FNAME, "assumption error: "
  		    "command queue is empty?");
  		exit(1);	/* XXX */
  	}
--- 271,277 ----
  	free(ctx);
  
  	if (commands == 0) {
! 		debug_printf(LOG_ERR, FNAME, "assumption error: "
  		    "command queue is empty?");
  		exit(1);	/* XXX */
  	}
***************
*** 299,310 ****
  
  			cc = read(ctx->s, cp, resid);
  			if (cc < 0) {
! 				dprintf(LOG_WARNING, FNAME, "read failed: %s",
  				    strerror(errno));
  				goto closecommand;
  			}
  			if (cc == 0) {
! 				dprintf(LOG_INFO, FNAME,
  				    "control channel was reset by peer");
  				goto closecommand;
  			}
--- 299,310 ----
  
  			cc = read(ctx->s, cp, resid);
  			if (cc < 0) {
! 				debug_printf(LOG_WARNING, FNAME, "read failed: %s",
  				    strerror(errno));
  				goto closecommand;
  			}
  			if (cc == 0) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "control channel was reset by peer");
  				goto closecommand;
  			}
***************
*** 330,336 ****
  					break;
  				}
  			} else if (ctx->input_len > sizeof(ctx->inputbuf)) {
! 				dprintf(LOG_INFO, FNAME,
  				    "too large command (%d bytes)",
  				    ctx->input_len);
  				goto closecommand;
--- 330,336 ----
  					break;
  				}
  			} else if (ctx->input_len > sizeof(ctx->inputbuf)) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "too large command (%d bytes)",
  				    ctx->input_len);
  				goto closecommand;
diff -crB wide-dhcpv6-20080615/dhcp6relay.c wide-dhcpv6-20080615-ltrx/dhcp6relay.c
*** wide-dhcpv6-20080615/dhcp6relay.c	2008-06-15 13:18:41.000000000 +0530
--- wide-dhcpv6-20080615-ltrx/dhcp6relay.c	2015-04-22 16:17:46.332966838 +0530
***************
*** 222,228 ****
  
  	relay6_init(argc, argv);
  
! 	dprintf(LOG_INFO, FNAME, "dhcp6relay started");
  	relay6_loop();
  
  	exit(0);
--- 222,228 ----
  
  	relay6_init(argc, argv);
  
! 	debug_printf(LOG_INFO, FNAME, "dhcp6relay started");
  	relay6_loop();
  
  	exit(0);
***************
*** 240,246 ****
  
  	/* make a local copy for safety */
  	if (strlcpy(pstr, pstr0, sizeof (pstr)) >= sizeof (pstr)) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "prefix string too long (maybe bogus): %s", pstr0);
  		return (NULL);
  	}
--- 240,246 ----
  
  	/* make a local copy for safety */
  	if (strlcpy(pstr, pstr0, sizeof (pstr)) >= sizeof (pstr)) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "prefix string too long (maybe bogus): %s", pstr0);
  		return (NULL);
  	}
***************
*** 250,276 ****
  		plen = 128; /* assumes it as a host prefix */
  	else {
  		if (p[1] == '\0') {
! 			dprintf(LOG_WARNING, FNAME,
  			    "no prefix length (ignored): %s", p + 1);
  			return (NULL);
  		}
  		plen = (int)strtoul(p + 1, &ep, 10);
  		if (*ep != '\0') {
! 			dprintf(LOG_WARNING, FNAME,
  			    "illegal prefix length (ignored): %s", p + 1);
  			return (NULL);
  		}
  		*p = '\0';
  	}
  	if (inet_pton(AF_INET6, pstr, &paddr) != 1) {
! 		dprintf(LOG_ERR, FNAME,
  		    "inet_pton failed for %s", pstr);
  		return (NULL);
  	}
  
  	/* allocate a new entry */
  	if ((pent = (struct prefix_list *)malloc(sizeof (*pent))) == NULL) {
! 		dprintf(LOG_WARNING, FNAME, "memory allocation failed");
  		return (NULL);	/* or abort? */
  	}
  
--- 250,276 ----
  		plen = 128; /* assumes it as a host prefix */
  	else {
  		if (p[1] == '\0') {
! 			debug_printf(LOG_WARNING, FNAME,
  			    "no prefix length (ignored): %s", p + 1);
  			return (NULL);
  		}
  		plen = (int)strtoul(p + 1, &ep, 10);
  		if (*ep != '\0') {
! 			debug_printf(LOG_WARNING, FNAME,
  			    "illegal prefix length (ignored): %s", p + 1);
  			return (NULL);
  		}
  		*p = '\0';
  	}
  	if (inet_pton(AF_INET6, pstr, &paddr) != 1) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "inet_pton failed for %s", pstr);
  		return (NULL);
  	}
  
  	/* allocate a new entry */
  	if ((pent = (struct prefix_list *)malloc(sizeof (*pent))) == NULL) {
! 		debug_printf(LOG_WARNING, FNAME, "memory allocation failed");
  		return (NULL);	/* or abort? */
  	}
  
***************
*** 312,325 ****
  	hints.ai_flags = AI_PASSIVE;
  	error = getaddrinfo(serveraddr, DH6PORT_UPSTREAM, &hints, &res);
  	if (error) {
! 		dprintf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		goto failexit;
  	}
  	if (res->ai_family != PF_INET6 ||
  	    res->ai_addrlen < sizeof (sa6_server)) {
  		/* this should be impossible, but check for safety */
! 		dprintf(LOG_ERR, FNAME,
  		    "getaddrinfo returned a bogus address: %s",
  		    strerror(errno));
  		goto failexit;
--- 312,325 ----
  	hints.ai_flags = AI_PASSIVE;
  	error = getaddrinfo(serveraddr, DH6PORT_UPSTREAM, &hints, &res);
  	if (error) {
! 		debug_printf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		goto failexit;
  	}
  	if (res->ai_family != PF_INET6 ||
  	    res->ai_addrlen < sizeof (sa6_server)) {
  		/* this should be impossible, but check for safety */
! 		debug_printf(LOG_ERR, FNAME,
  		    "getaddrinfo returned a bogus address: %s",
  		    strerror(errno));
  		goto failexit;
***************
*** 335,341 ****
  	rmh.msg_iovlen = 1;
  	rmsgctllen = CMSG_SPACE(sizeof (struct in6_pktinfo));
  	if ((rmsgctlbuf = (char *)malloc(rmsgctllen)) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "memory allocation failed");
  		goto failexit;
  	}
  
--- 335,341 ----
  	rmh.msg_iovlen = 1;
  	rmsgctllen = CMSG_SPACE(sizeof (struct in6_pktinfo));
  	if ((rmsgctlbuf = (char *)malloc(rmsgctllen)) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "memory allocation failed");
  		goto failexit;
  	}
  
***************
*** 349,361 ****
  	hints.ai_flags = AI_PASSIVE;
  	error = getaddrinfo(NULL, DH6PORT_UPSTREAM, &hints, &res);
  	if (error) {
! 		dprintf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		goto failexit;
  	}
  	csock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  	if (csock < 0) {
! 		dprintf(LOG_ERR, FNAME, "socket(csock): %s", strerror(errno));
  		goto failexit;
  	}
  	if (csock > maxfd)
--- 349,361 ----
  	hints.ai_flags = AI_PASSIVE;
  	error = getaddrinfo(NULL, DH6PORT_UPSTREAM, &hints, &res);
  	if (error) {
! 		debug_printf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		goto failexit;
  	}
  	csock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  	if (csock < 0) {
! 		debug_printf(LOG_ERR, FNAME, "socket(csock): %s", strerror(errno));
  		goto failexit;
  	}
  	if (csock > maxfd)
***************
*** 363,382 ****
  	on = 1;
  	if (setsockopt(csock, SOL_SOCKET, SO_REUSEPORT,
  	    &on, sizeof(on)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "setsockopt(csock, SO_REUSEPORT): %s",
  		    strerror(errno));
  		goto failexit;
  	}
  #ifdef IPV6_V6ONLY
  	if (setsockopt(csock, IPPROTO_IPV6, IPV6_V6ONLY,
  	    &on, sizeof (on)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "setsockopt(csock, IPV6_V6ONLY): %s",
  		    strerror(errno));
  		goto failexit;
  	}
  #endif
  	if (bind(csock, res->ai_addr, res->ai_addrlen) < 0) {
! 		dprintf(LOG_ERR, FNAME, "bind(csock): %s", strerror(errno));
  		goto failexit;
  	}
  	freeaddrinfo(res);
--- 363,382 ----
  	on = 1;
  	if (setsockopt(csock, SOL_SOCKET, SO_REUSEPORT,
  	    &on, sizeof(on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "setsockopt(csock, SO_REUSEPORT): %s",
  		    strerror(errno));
  		goto failexit;
  	}
  #ifdef IPV6_V6ONLY
  	if (setsockopt(csock, IPPROTO_IPV6, IPV6_V6ONLY,
  	    &on, sizeof (on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "setsockopt(csock, IPV6_V6ONLY): %s",
  		    strerror(errno));
  		goto failexit;
  	}
  #endif
  	if (bind(csock, res->ai_addr, res->ai_addrlen) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "bind(csock): %s", strerror(errno));
  		goto failexit;
  	}
  	freeaddrinfo(res);
***************
*** 384,397 ****
  #ifdef IPV6_RECVPKTINFO
  	if (setsockopt(csock, IPPROTO_IPV6, IPV6_RECVPKTINFO,
  	    &on, sizeof (on)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "setsockopt(IPV6_RECVPKTINFO): %s",
  		    strerror(errno));
  		goto failexit;
  	}
  #else
  	if (setsockopt(csock, IPPROTO_IPV6, IPV6_PKTINFO,
  	    &on, sizeof (on)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "setsockopt(IPV6_PKTINFO): %s",
  		    strerror(errno));
  		goto failexit;
  	}
--- 384,397 ----
  #ifdef IPV6_RECVPKTINFO
  	if (setsockopt(csock, IPPROTO_IPV6, IPV6_RECVPKTINFO,
  	    &on, sizeof (on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "setsockopt(IPV6_RECVPKTINFO): %s",
  		    strerror(errno));
  		goto failexit;
  	}
  #else
  	if (setsockopt(csock, IPPROTO_IPV6, IPV6_PKTINFO,
  	    &on, sizeof (on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "setsockopt(IPV6_PKTINFO): %s",
  		    strerror(errno));
  		goto failexit;
  	}
***************
*** 400,406 ****
  	hints.ai_flags = 0;
  	error = getaddrinfo(DH6ADDR_ALLAGENT, 0, &hints, &res2);
  	if (error) {
! 		dprintf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		goto failexit;
  	}
--- 400,406 ----
  	hints.ai_flags = 0;
  	error = getaddrinfo(DH6ADDR_ALLAGENT, 0, &hints, &res2);
  	if (error) {
! 		debug_printf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		goto failexit;
  	}
***************
*** 416,436 ****
  
  		ifd = (struct ifid_list *)malloc(sizeof (*ifd));
  		if (ifd == NULL) {
! 			dprintf(LOG_WARNING, FNAME,
  			    "memory allocation failed");
  			goto failexit;
  		}
  		memset(ifd, 0, sizeof (*ifd));
  		ifd->ifid = if_nametoindex(ifp);
  		if (ifd->ifid == 0) {
! 			dprintf(LOG_ERR, FNAME, "invalid interface %s", ifp);
  			goto failexit;
  		}
  		mreq6.ipv6mr_interface = ifd->ifid;
  
  		if (setsockopt(csock, IPPROTO_IPV6, IPV6_JOIN_GROUP,
  		    &mreq6, sizeof (mreq6))) {
! 			dprintf(LOG_ERR, FNAME,
  			    "setsockopt(csock, IPV6_JOIN_GROUP): %s",
  			     strerror(errno));
  			goto failexit;
--- 416,436 ----
  
  		ifd = (struct ifid_list *)malloc(sizeof (*ifd));
  		if (ifd == NULL) {
! 			debug_printf(LOG_WARNING, FNAME,
  			    "memory allocation failed");
  			goto failexit;
  		}
  		memset(ifd, 0, sizeof (*ifd));
  		ifd->ifid = if_nametoindex(ifp);
  		if (ifd->ifid == 0) {
! 			debug_printf(LOG_ERR, FNAME, "invalid interface %s", ifp);
  			goto failexit;
  		}
  		mreq6.ipv6mr_interface = ifd->ifid;
  
  		if (setsockopt(csock, IPPROTO_IPV6, IPV6_JOIN_GROUP,
  		    &mreq6, sizeof (mreq6))) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "setsockopt(csock, IPV6_JOIN_GROUP): %s",
  			     strerror(errno));
  			goto failexit;
***************
*** 445,451 ****
  	 */
  	relayifid = if_nametoindex(relaydevice);
  	if (relayifid == 0)
! 		dprintf(LOG_ERR, FNAME, "invalid interface %s", relaydevice);
  	/*
  	 * We are not really sure if we need to listen on the downstream
  	 * port to receive packets from servers.  We'll need to clarify the
--- 445,451 ----
  	 */
  	relayifid = if_nametoindex(relaydevice);
  	if (relayifid == 0)
! 		debug_printf(LOG_ERR, FNAME, "invalid interface %s", relaydevice);
  	/*
  	 * We are not really sure if we need to listen on the downstream
  	 * port to receive packets from servers.  We'll need to clarify the
***************
*** 454,467 ****
  	hints.ai_flags = AI_PASSIVE;
  	error = getaddrinfo(boundaddr, DH6PORT_DOWNSTREAM, &hints, &res);
  	if (error) {
! 		dprintf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		goto failexit;
  	}
  	memcpy(&sa6_client, res->ai_addr, sizeof (sa6_client));
  	ssock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  	if (ssock < 0) {
! 		dprintf(LOG_ERR, FNAME, "socket(outsock): %s",
  		    strerror(error));
  		goto failexit;
  	}
--- 454,467 ----
  	hints.ai_flags = AI_PASSIVE;
  	error = getaddrinfo(boundaddr, DH6PORT_DOWNSTREAM, &hints, &res);
  	if (error) {
! 		debug_printf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		goto failexit;
  	}
  	memcpy(&sa6_client, res->ai_addr, sizeof (sa6_client));
  	ssock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  	if (ssock < 0) {
! 		debug_printf(LOG_ERR, FNAME, "socket(outsock): %s",
  		    strerror(error));
  		goto failexit;
  	}
***************
*** 474,480 ****
  	 */
  	if (setsockopt(ssock, SOL_SOCKET, SO_REUSEPORT,
  	    &on, sizeof (on)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "setsockopt(ssock, SO_REUSEPORT): %s",
  		    strerror(errno));
  		goto failexit;
  	}
--- 474,480 ----
  	 */
  	if (setsockopt(ssock, SOL_SOCKET, SO_REUSEPORT,
  	    &on, sizeof (on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "setsockopt(ssock, SO_REUSEPORT): %s",
  		    strerror(errno));
  		goto failexit;
  	}
***************
*** 482,494 ****
  #ifdef IPV6_V6ONLY
  	if (setsockopt(ssock, IPPROTO_IPV6, IPV6_V6ONLY,
  	    &on, sizeof (on)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "setsockopt(ssock, IPV6_V6ONLY): %s",
  		    strerror(errno));
  		goto failexit;
  	}
  #endif
  	if (bind(ssock, res->ai_addr, res->ai_addrlen) < 0) {
! 		dprintf(LOG_ERR, FNAME, "bind(ssock): %s", strerror(errno));
  		goto failexit;
  	}
  	freeaddrinfo(res);
--- 482,494 ----
  #ifdef IPV6_V6ONLY
  	if (setsockopt(ssock, IPPROTO_IPV6, IPV6_V6ONLY,
  	    &on, sizeof (on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "setsockopt(ssock, IPV6_V6ONLY): %s",
  		    strerror(errno));
  		goto failexit;
  	}
  #endif
  	if (bind(ssock, res->ai_addr, res->ai_addrlen) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "bind(ssock): %s", strerror(errno));
  		goto failexit;
  	}
  	freeaddrinfo(res);
***************
*** 497,517 ****
  #ifdef IPV6_RECVPKTINFO
  	if (setsockopt(ssock, IPPROTO_IPV6, IPV6_RECVPKTINFO,
  	    &on, sizeof (on)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "setsockopt(IPV6_RECVPKTINFO): %s",
  		    strerror(errno));
  		goto failexit;
  	}
  #else
  	if (setsockopt(ssock, IPPROTO_IPV6, IPV6_PKTINFO,
  	    &on, sizeof (on)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "setsockopt(IPV6_PKTINFO): %s",
  		    strerror(errno));
  		goto failexit;
  	}
  #endif
  
  	if (signal(SIGTERM, relay6_signal) == SIG_ERR) {
! 		dprintf(LOG_WARNING, FNAME, "failed to set signal: %s",
  		    strerror(errno));
  		exit(1);
  	}
--- 497,517 ----
  #ifdef IPV6_RECVPKTINFO
  	if (setsockopt(ssock, IPPROTO_IPV6, IPV6_RECVPKTINFO,
  	    &on, sizeof (on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "setsockopt(IPV6_RECVPKTINFO): %s",
  		    strerror(errno));
  		goto failexit;
  	}
  #else
  	if (setsockopt(ssock, IPPROTO_IPV6, IPV6_PKTINFO,
  	    &on, sizeof (on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "setsockopt(IPV6_PKTINFO): %s",
  		    strerror(errno));
  		goto failexit;
  	}
  #endif
  
  	if (signal(SIGTERM, relay6_signal) == SIG_ERR) {
! 		debug_printf(LOG_WARNING, FNAME, "failed to set signal: %s",
  		    strerror(errno));
  		exit(1);
  	}
***************
*** 599,613 ****
  	rmh.msg_namelen = sizeof (from);
  
  	if ((len = recvmsg(s, &rmh, 0)) < 0) {
! 		dprintf(LOG_WARNING, FNAME, "recvmsg: %s", strerror(errno));
  		return;
  	}
  
! 	dprintf(LOG_DEBUG, FNAME, "from %s, size %d",
  	    addr2str((struct sockaddr *)&from), len);
  
  	if (((struct sockaddr *)&from)->sa_family != AF_INET6) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "non-IPv6 packet is received (AF %d) ",
  		    ((struct sockaddr *)&from)->sa_family);
  		return;
--- 599,613 ----
  	rmh.msg_namelen = sizeof (from);
  
  	if ((len = recvmsg(s, &rmh, 0)) < 0) {
! 		debug_printf(LOG_WARNING, FNAME, "recvmsg: %s", strerror(errno));
  		return;
  	}
  
! 	debug_printf(LOG_DEBUG, FNAME, "from %s, size %d",
  	    addr2str((struct sockaddr *)&from), len);
  
  	if (((struct sockaddr *)&from)->sa_family != AF_INET6) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "non-IPv6 packet is received (AF %d) ",
  		    ((struct sockaddr *)&from)->sa_family);
  		return;
***************
*** 626,632 ****
  		}
  	}
  	if (pi == NULL) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "failed to get the arrival interface");
  		return;
  	}
--- 626,632 ----
  		}
  	}
  	if (pi == NULL) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "failed to get the arrival interface");
  		return;
  	}
***************
*** 643,649 ****
  	if (ifd == NULL && pi->ipi6_ifindex != relayifid)
  		return;
  	if (if_indextoname(pi->ipi6_ifindex, ifname) == NULL) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "if_indextoname(id = %d): %s",
  		    pi->ipi6_ifindex, strerror(errno));
  		return;
--- 643,649 ----
  	if (ifd == NULL && pi->ipi6_ifindex != relayifid)
  		return;
  	if (if_indextoname(pi->ipi6_ifindex, ifname) == NULL) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "if_indextoname(id = %d): %s",
  		    pi->ipi6_ifindex, strerror(errno));
  		return;
***************
*** 651,662 ****
  
  	/* packet validation */
  	if (len < sizeof (*dh6)) {
! 		dprintf(LOG_INFO, FNAME, "short packet (%d bytes)", len);
  		return;
  	}
  
  	dh6 = (struct dhcp6 *)rdatabuf;
! 	dprintf(LOG_DEBUG, FNAME, "received %s from %s",
  	    dhcp6msgstr(dh6->dh6_msgtype), addr2str((struct sockaddr *)&from));
  
  	/*
--- 651,662 ----
  
  	/* packet validation */
  	if (len < sizeof (*dh6)) {
! 		debug_printf(LOG_INFO, FNAME, "short packet (%d bytes)", len);
  		return;
  	}
  
  	dh6 = (struct dhcp6 *)rdatabuf;
! 	debug_printf(LOG_DEBUG, FNAME, "received %s from %s",
  	    dhcp6msgstr(dh6->dh6_msgtype), addr2str((struct sockaddr *)&from));
  
  	/*
***************
*** 688,694 ****
  			    (struct sockaddr *)&from);
  			break;
  		default:
! 			dprintf(LOG_INFO, FNAME,
  			    "unexpected message (%s) on the client side "
  			    "from %s", dhcp6msgstr(dh6->dh6_msgtype),
  			    addr2str((struct sockaddr *)&from));
--- 688,694 ----
  			    (struct sockaddr *)&from);
  			break;
  		default:
! 			debug_printf(LOG_INFO, FNAME,
  			    "unexpected message (%s) on the client side "
  			    "from %s", dhcp6msgstr(dh6->dh6_msgtype),
  			    addr2str((struct sockaddr *)&from));
***************
*** 696,702 ****
  		}
  	} else {
  		if (dh6->dh6_msgtype != DH6_RELAY_REPLY) {
! 			dprintf(LOG_INFO, FNAME,
  			    "unexpected message (%s) on the server side"
  			    "from %s", dhcp6msgstr(dh6->dh6_msgtype),
  			    addr2str((struct sockaddr *)&from));
--- 696,702 ----
  		}
  	} else {
  		if (dh6->dh6_msgtype != DH6_RELAY_REPLY) {
! 			debug_printf(LOG_INFO, FNAME,
  			    "unexpected message (%s) on the server side"
  			    "from %s", dhcp6msgstr(dh6->dh6_msgtype),
  			    addr2str((struct sockaddr *)&from));
***************
*** 781,787 ****
  
  	/* Relay message */
  	if ((optinfo.relaymsg_msg = malloc(len)) == NULL) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "failed to allocate memory to copy the original packet: "
  		    "%s", strerror(errno));
  		goto out;
--- 781,787 ----
  
  	/* Relay message */
  	if ((optinfo.relaymsg_msg = malloc(len)) == NULL) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "failed to allocate memory to copy the original packet: "
  		    "%s", strerror(errno));
  		goto out;
***************
*** 791,797 ****
  
  	/* Interface-id.  We always use this option. */
  	if ((optinfo.ifidopt_id = malloc(sizeof (ifid))) == NULL) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "failed to allocate memory for IFID: %s", strerror(errno));
  		goto out;
  	}
--- 791,797 ----
  
  	/* Interface-id.  We always use this option. */
  	if ((optinfo.ifidopt_id = malloc(sizeof (ifid))) == NULL) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "failed to allocate memory for IFID: %s", strerror(errno));
  		goto out;
  	}
***************
*** 817,823 ****
  			break;
  	}
  	if (p == NULL) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to find a global address on %s", ifname);
  
  		/*
--- 817,823 ----
  			break;
  	}
  	if (p == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to find a global address on %s", ifname);
  
  		/*
***************
*** 842,848 ****
  		 * [RFC3315 Section 20.1.2]
  		 */
  		if (dh6relay0->dh6relay_hcnt >= DHCP6_RELAY_HOP_COUNT_LIMIT) {
! 			dprintf(LOG_INFO, FNAME, "too many relay forwardings");
  			goto out;
  		}
  
--- 842,848 ----
  		 * [RFC3315 Section 20.1.2]
  		 */
  		if (dh6relay0->dh6relay_hcnt >= DHCP6_RELAY_HOP_COUNT_LIMIT) {
! 			debug_printf(LOG_INFO, FNAME, "too many relay forwardings");
  			goto out;
  		}
  
***************
*** 865,871 ****
  	    (struct dhcp6opt *)(dh6relay + 1),
  	    (struct dhcp6opt *)(relaybuf + sizeof (relaybuf)),
  	    &optinfo)) < 0) {
! 		dprintf(LOG_INFO, FNAME,
  		    "failed to construct relay options");
  		goto out;
  	}
--- 865,871 ----
  	    (struct dhcp6opt *)(dh6relay + 1),
  	    (struct dhcp6opt *)(relaybuf + sizeof (relaybuf)),
  	    &optinfo)) < 0) {
! 		debug_printf(LOG_INFO, FNAME,
  		    "failed to construct relay options");
  		goto out;
  	}
***************
*** 886,907 ****
  		pktinfo.ipi6_ifindex = relayifid;
  		if (make_msgcontrol(&mh, ctlbuf, sizeof (ctlbuf),
  		    &pktinfo, mhops)) {
! 			dprintf(LOG_WARNING, FNAME,
  			    "failed to make message control data");
  			goto out;
  		}
  	}
  
  	if ((cc = sendmsg(ssock, &mh, 0)) < 0) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "sendmsg %s failed: %s",
  		    addr2str((struct sockaddr *)&sa6_server), strerror(errno));
  	} else if (cc != relaylen) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "failed to send a complete packet to %s",
  		    addr2str((struct sockaddr *)&sa6_server));
  	} else {
! 		dprintf(LOG_DEBUG, FNAME,
  		    "relay a message to a server %s",
  		    addr2str((struct sockaddr *)&sa6_server));
  	}
--- 886,907 ----
  		pktinfo.ipi6_ifindex = relayifid;
  		if (make_msgcontrol(&mh, ctlbuf, sizeof (ctlbuf),
  		    &pktinfo, mhops)) {
! 			debug_printf(LOG_WARNING, FNAME,
  			    "failed to make message control data");
  			goto out;
  		}
  	}
  
  	if ((cc = sendmsg(ssock, &mh, 0)) < 0) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "sendmsg %s failed: %s",
  		    addr2str((struct sockaddr *)&sa6_server), strerror(errno));
  	} else if (cc != relaylen) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "failed to send a complete packet to %s",
  		    addr2str((struct sockaddr *)&sa6_server));
  	} else {
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "relay a message to a server %s",
  		    addr2str((struct sockaddr *)&sa6_server));
  	}
***************
*** 928,934 ****
  	static struct iovec iov[2];
  	char ctlbuf[CMSG_SPACE(sizeof (struct in6_pktinfo))];
  
! 	dprintf(LOG_DEBUG, FNAME,
  	    "dhcp6 relay reply: hop=%d, linkaddr=%s, peeraddr=%s",
  	    dh6relay->dh6relay_hcnt,
  	    in6addr2str(&dh6relay->dh6relay_linkaddr, 0),
--- 928,934 ----
  	static struct iovec iov[2];
  	char ctlbuf[CMSG_SPACE(sizeof (struct in6_pktinfo))];
  
! 	debug_printf(LOG_DEBUG, FNAME,
  	    "dhcp6 relay reply: hop=%d, linkaddr=%s, peeraddr=%s",
  	    dh6relay->dh6relay_hcnt,
  	    in6addr2str(&dh6relay->dh6relay_linkaddr, 0),
***************
*** 940,959 ****
  	dhcp6_init_options(&optinfo);
  	if (dhcp6_get_options((struct dhcp6opt *)(dh6relay + 1),
  	    (struct dhcp6opt *)((char *)dh6relay + len), &optinfo) < 0) {
! 		dprintf(LOG_INFO, FNAME, "failed to parse options");
  		return;
  	}
  
  	/* A relay reply message must include a relay message option */
  	if (optinfo.relaymsg_msg == NULL) {
! 		dprintf(LOG_INFO, FNAME, "relay reply message from %s "
  		    "without a relay message", addr2str(from));
  		goto out;
  	}
  
  	/* minimum validation for the inner message */
  	if (optinfo.relaymsg_len < sizeof (struct dhcp6)) {
! 		dprintf(LOG_INFO, FNAME, "short relay message from %s",
  		    addr2str(from));
  		goto out;
  	}
--- 940,959 ----
  	dhcp6_init_options(&optinfo);
  	if (dhcp6_get_options((struct dhcp6opt *)(dh6relay + 1),
  	    (struct dhcp6opt *)((char *)dh6relay + len), &optinfo) < 0) {
! 		debug_printf(LOG_INFO, FNAME, "failed to parse options");
  		return;
  	}
  
  	/* A relay reply message must include a relay message option */
  	if (optinfo.relaymsg_msg == NULL) {
! 		debug_printf(LOG_INFO, FNAME, "relay reply message from %s "
  		    "without a relay message", addr2str(from));
  		goto out;
  	}
  
  	/* minimum validation for the inner message */
  	if (optinfo.relaymsg_len < sizeof (struct dhcp6)) {
! 		debug_printf(LOG_INFO, FNAME, "short relay message from %s",
  		    addr2str(from));
  		goto out;
  	}
***************
*** 965,971 ****
  	ifid = 0;
  	if (optinfo.ifidopt_id) {
  		if (optinfo.ifidopt_len != sizeof (ifid)) {
! 			dprintf(LOG_INFO, FNAME,
  			    "unexpected length (%d) for Interface ID from %s",
  			    optinfo.ifidopt_len, addr2str(from));
  			goto out;
--- 965,971 ----
  	ifid = 0;
  	if (optinfo.ifidopt_id) {
  		if (optinfo.ifidopt_len != sizeof (ifid)) {
! 			debug_printf(LOG_INFO, FNAME,
  			    "unexpected length (%d) for Interface ID from %s",
  			    optinfo.ifidopt_len, addr2str(from));
  			goto out;
***************
*** 975,987 ****
  
  			/* validation for ID */
  			if ((if_indextoname(ifid, ifnamebuf)) == NULL) {
! 				dprintf(LOG_INFO, FNAME,
  				    "invalid interface ID: %x", ifid);
  				goto out;
  			}
  		}
  	} else {
! 		dprintf(LOG_INFO, FNAME,
  		    "Interface ID is not included from %s", addr2str(from));
  		/*
  		 * the responding server should be buggy, but we deal with it.
--- 975,987 ----
  
  			/* validation for ID */
  			if ((if_indextoname(ifid, ifnamebuf)) == NULL) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "invalid interface ID: %x", ifid);
  				goto out;
  			}
  		}
  	} else {
! 		debug_printf(LOG_INFO, FNAME,
  		    "Interface ID is not included from %s", addr2str(from));
  		/*
  		 * the responding server should be buggy, but we deal with it.
***************
*** 999,1005 ****
  	}
  
  	if (ifid == 0) {
! 		dprintf(LOG_INFO, FNAME, "failed to determine relay link");
  		goto out;
  	}
  
--- 999,1005 ----
  	}
  
  	if (ifid == 0) {
! 		debug_printf(LOG_INFO, FNAME, "failed to determine relay link");
  		goto out;
  	}
  
***************
*** 1030,1051 ****
  	memset(&pktinfo, 0, sizeof (pktinfo));
  	pktinfo.ipi6_ifindex = ifid;
  	if (make_msgcontrol(&mh, ctlbuf, sizeof (ctlbuf), &pktinfo, 0)) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "failed to make message control data");
  		goto out;
  	}
  
  	/* send packet */
  	if ((cc = sendmsg(csock, &mh, 0)) < 0) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "sendmsg to %s failed: %s",
  		    addr2str((struct sockaddr *)&peer), strerror(errno));
  	} else if (cc != optinfo.relaymsg_len) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "failed to send a complete packet to %s",
  		    addr2str((struct sockaddr *)&peer));
  	} else {
! 		dprintf(LOG_DEBUG, FNAME,
  		    "relay a message to a client %s",
  		    addr2str((struct sockaddr *)&peer));
  	}
--- 1030,1051 ----
  	memset(&pktinfo, 0, sizeof (pktinfo));
  	pktinfo.ipi6_ifindex = ifid;
  	if (make_msgcontrol(&mh, ctlbuf, sizeof (ctlbuf), &pktinfo, 0)) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "failed to make message control data");
  		goto out;
  	}
  
  	/* send packet */
  	if ((cc = sendmsg(csock, &mh, 0)) < 0) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "sendmsg to %s failed: %s",
  		    addr2str((struct sockaddr *)&peer), strerror(errno));
  	} else if (cc != optinfo.relaymsg_len) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "failed to send a complete packet to %s",
  		    addr2str((struct sockaddr *)&peer));
  	} else {
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "relay a message to a client %s",
  		    addr2str((struct sockaddr *)&peer));
  	}
diff -crB wide-dhcpv6-20080615/dhcp6relay_script.c wide-dhcpv6-20080615-ltrx/dhcp6relay_script.c
*** wide-dhcpv6-20080615/dhcp6relay_script.c	2007-03-21 15:22:55.000000000 +0530
--- wide-dhcpv6-20080615-ltrx/dhcp6relay_script.c	2015-04-22 16:17:46.384967205 +0530
***************
*** 87,93 ****
  	/* only replies are interesting */
  	if (dh6->dh6_msgtype != DH6_REPLY) {
  		if (dh6->dh6_msgtype != DH6_ADVERTISE) {
! 			dprintf(LOG_INFO, FNAME, "forward msg#%d to client?",
  			    dh6->dh6_msgtype);
  			return -1;
  		}
--- 87,93 ----
  	/* only replies are interesting */
  	if (dh6->dh6_msgtype != DH6_REPLY) {
  		if (dh6->dh6_msgtype != DH6_ADVERTISE) {
! 			debug_printf(LOG_INFO, FNAME, "forward msg#%d to client?",
  			    dh6->dh6_msgtype);
  			return -1;
  		}
***************
*** 99,105 ****
  	dhcp6_init_options(&optinfo);
  	if (dhcp6_get_options((struct dhcp6opt *)(dh6 + 1), optend,
  	    &optinfo) < 0) {
! 		dprintf(LOG_INFO, FNAME, "failed to parse options");
  		return -1;
  	}
  
--- 99,105 ----
  	dhcp6_init_options(&optinfo);
  	if (dhcp6_get_options((struct dhcp6opt *)(dh6 + 1), optend,
  	    &optinfo) < 0) {
! 		debug_printf(LOG_INFO, FNAME, "failed to parse options");
  		return -1;
  	}
  
***************
*** 118,124 ****
  
  	/* allocate an environments array */
  	if ((envp = malloc(sizeof (char *) * envc)) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to allocate environment buffer");
  		dhcp6_clear_options(&optinfo);
  		return -1;
--- 118,124 ----
  
  	/* allocate an environments array */
  	if ((envp = malloc(sizeof (char *) * envc)) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to allocate environment buffer");
  		dhcp6_clear_options(&optinfo);
  		return -1;
***************
*** 132,145 ****
  	/* address */
  	t = addr2str((struct sockaddr *) client);
  	if (t == NULL) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to get address of client");
  		ret = -1;
  		goto clean;
  	}
  	elen = sizeof (client_str) + 1 + strlen(t) + 1;
  	if ((s = envp[i++] = malloc(elen)) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to allocate string for client");
  		ret = -1;
  		goto clean;
--- 132,145 ----
  	/* address */
  	t = addr2str((struct sockaddr *) client);
  	if (t == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to get address of client");
  		ret = -1;
  		goto clean;
  	}
  	elen = sizeof (client_str) + 1 + strlen(t) + 1;
  	if ((s = envp[i++] = malloc(elen)) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to allocate string for client");
  		ret = -1;
  		goto clean;
***************
*** 167,173 ****
  	/* launch the script */
  	pid = fork();
  	if (pid < 0) {
! 		dprintf(LOG_ERR, FNAME, "failed to fork: %s", strerror(errno));
  		ret = -1;
  		goto clean;
  	} else if (pid) {
--- 167,173 ----
  	/* launch the script */
  	pid = fork();
  	if (pid < 0) {
! 		debug_printf(LOG_ERR, FNAME, "failed to fork: %s", strerror(errno));
  		ret = -1;
  		goto clean;
  	} else if (pid) {
***************
*** 178,186 ****
  		} while (wpid != pid && wpid > 0);
  
  		if (wpid < 0)
! 			dprintf(LOG_ERR, FNAME, "wait: %s", strerror(errno));
  		else {
! 			dprintf(LOG_DEBUG, FNAME,
  			    "script \"%s\" terminated", scriptpath);
  		}
  	} else {
--- 178,186 ----
  		} while (wpid != pid && wpid > 0);
  
  		if (wpid < 0)
! 			debug_printf(LOG_ERR, FNAME, "wait: %s", strerror(errno));
  		else {
! 			debug_printf(LOG_DEBUG, FNAME,
  			    "script \"%s\" terminated", scriptpath);
  		}
  	} else {
***************
*** 191,197 ****
  		argv[1] = NULL;
  
  		if (safefile(scriptpath)) {
! 			dprintf(LOG_ERR, FNAME,
  			    "script \"%s\" cannot be executed safely",
  			    scriptpath);
  			exit(1);
--- 191,197 ----
  		argv[1] = NULL;
  
  		if (safefile(scriptpath)) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "script \"%s\" cannot be executed safely",
  			    scriptpath);
  			exit(1);
***************
*** 208,214 ****
  
  		execve(scriptpath, argv, envp);
  
! 		dprintf(LOG_ERR, FNAME, "child: exec failed: %s",
  		    strerror(errno));
  		exit(0);
  	}
--- 208,214 ----
  
  		execve(scriptpath, argv, envp);
  
! 		debug_printf(LOG_ERR, FNAME, "child: exec failed: %s",
  		    strerror(errno));
  		exit(0);
  	}
***************
*** 254,265 ****
  			break;
  
  		default:
! 			dprintf(LOG_ERR, FNAME, "impossible subopt");
  		}
  	}
  
  	if ((r = strdup(s)) == NULL)
! 		dprintf(LOG_ERR, FNAME, "failed to allocate iapd_%d", num);
  	return r;
  }
  
--- 254,265 ----
  			break;
  
  		default:
! 			debug_printf(LOG_ERR, FNAME, "impossible subopt");
  		}
  	}
  
  	if ((r = strdup(s)) == NULL)
! 		debug_printf(LOG_ERR, FNAME, "failed to allocate iapd_%d", num);
  	return r;
  }
  
***************
*** 294,304 ****
  			break;
  
  		default:
! 			dprintf(LOG_ERR, FNAME, "impossible subopt");
  		}
  	}
  
  	if ((r = strdup(s)) == NULL)
! 		dprintf(LOG_ERR, FNAME, "failed to allocate iana_%d", num);
  	return r;
  }
--- 294,304 ----
  			break;
  
  		default:
! 			debug_printf(LOG_ERR, FNAME, "impossible subopt");
  		}
  	}
  
  	if ((r = strdup(s)) == NULL)
! 		debug_printf(LOG_ERR, FNAME, "failed to allocate iana_%d", num);
  	return r;
  }
diff -crB wide-dhcpv6-20080615/dhcp6s.c wide-dhcpv6-20080615-ltrx/dhcp6s.c
*** wide-dhcpv6-20080615/dhcp6s.c	2015-04-22 16:16:34.964458165 +0530
--- wide-dhcpv6-20080615-ltrx/dhcp6s.c	2015-04-22 16:17:46.384967205 +0530
***************
*** 314,320 ****
  		exit(1);
  
  	if ((cfparse(conffile)) != 0) {
! 		dprintf(LOG_ERR, FNAME, "failed to parse configuration file");
  		exit(1);
  	}
  
--- 314,320 ----
  		exit(1);
  
  	if ((cfparse(conffile)) != 0) {
! 		debug_printf(LOG_ERR, FNAME, "failed to parse configuration file");
  		exit(1);
  	}
  
***************
*** 333,339 ****
  	/* prohibit a mixture of old and new style of DNS server config */
  	if (!TAILQ_EMPTY(&arg_dnslist)) {
  		if (!TAILQ_EMPTY(&dnslist)) {
! 			dprintf(LOG_INFO, FNAME, "do not specify DNS servers "
  			    "both by command line and by configuration file.");
  			exit(1);
  		}
--- 333,339 ----
  	/* prohibit a mixture of old and new style of DNS server config */
  	if (!TAILQ_EMPTY(&arg_dnslist)) {
  		if (!TAILQ_EMPTY(&dnslist)) {
! 			debug_printf(LOG_INFO, FNAME, "do not specify DNS servers "
  			    "both by command line and by configuration file.");
  			exit(1);
  		}
***************
*** 372,395 ****
  
  	TAILQ_INIT(&dhcp6_binding_head);
  	if (lease_init() != 0) {
! 		dprintf(LOG_ERR, FNAME, "failed to initialize the lease table");
  		exit(1);
  	}
  
  	ifidx = if_nametoindex(device);
  	if (ifidx == 0) {
! 		dprintf(LOG_ERR, FNAME, "invalid interface %s", device);
  		exit(1);
  	}
  
  	/* get our DUID */
  	if (get_duid(DUID_FILE, &server_duid)) {
! 		dprintf(LOG_ERR, FNAME, "failed to get a DUID");
  		exit(1);
  	}
  
  	if (dhcp6_ctl_authinit(ctlkeyfile, &ctlkey, &ctldigestlen) != 0) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to initialize control message authentication");
  		/* run the server anyway */
  	}
--- 372,395 ----
  
  	TAILQ_INIT(&dhcp6_binding_head);
  	if (lease_init() != 0) {
! 		debug_printf(LOG_ERR, FNAME, "failed to initialize the lease table");
  		exit(1);
  	}
  
  	ifidx = if_nametoindex(device);
  	if (ifidx == 0) {
! 		debug_printf(LOG_ERR, FNAME, "invalid interface %s", device);
  		exit(1);
  	}
  
  	/* get our DUID */
  	if (get_duid(DUID_FILE, &server_duid)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to get a DUID");
  		exit(1);
  	}
  
  	if (dhcp6_ctl_authinit(ctlkeyfile, &ctlkey, &ctldigestlen) != 0) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to initialize control message authentication");
  		/* run the server anyway */
  	}
***************
*** 401,407 ****
  	rmh.msg_iovlen = 1;
  	rmsgctllen = CMSG_SPACE(sizeof(struct in6_pktinfo));
  	if ((rmsgctlbuf = (char *)malloc(rmsgctllen)) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "memory allocation failed");
  		exit(1);
  	}
  
--- 401,407 ----
  	rmh.msg_iovlen = 1;
  	rmsgctllen = CMSG_SPACE(sizeof(struct in6_pktinfo));
  	if ((rmsgctlbuf = (char *)malloc(rmsgctllen)) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "memory allocation failed");
  		exit(1);
  	}
  
***************
*** 413,444 ****
  	hints.ai_flags = AI_PASSIVE;
  	error = getaddrinfo(NULL, DH6PORT_UPSTREAM, &hints, &res);
  	if (error) {
! 		dprintf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
  	insock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  	if (insock < 0) {
! 		dprintf(LOG_ERR, FNAME, "socket(insock): %s",
  		    strerror(errno));
  		exit(1);
  	}
  	if (setsockopt(insock, SOL_SOCKET, SO_REUSEPORT, &on,
  		       sizeof(on)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "setsockopt(insock, SO_REUSEPORT): %s",
  		    strerror(errno));
  		exit(1);
  	}
  	if (setsockopt(insock, SOL_SOCKET, SO_REUSEADDR, &on,
  		       sizeof(on)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "setsockopt(insock, SO_REUSEADDR): %s",
  		    strerror(errno));
  		exit(1);
  	}
  #ifdef IPV6_RECVPKTINFO
  	if (setsockopt(insock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,
  		       sizeof(on)) < 0) {
! 		dprintf(LOG_ERR, FNAME,
  		    "setsockopt(inbound, IPV6_RECVPKTINFO): %s",
  		    strerror(errno));
  		exit(1);
--- 413,444 ----
  	hints.ai_flags = AI_PASSIVE;
  	error = getaddrinfo(NULL, DH6PORT_UPSTREAM, &hints, &res);
  	if (error) {
! 		debug_printf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
  	insock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  	if (insock < 0) {
! 		debug_printf(LOG_ERR, FNAME, "socket(insock): %s",
  		    strerror(errno));
  		exit(1);
  	}
  	if (setsockopt(insock, SOL_SOCKET, SO_REUSEPORT, &on,
  		       sizeof(on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "setsockopt(insock, SO_REUSEPORT): %s",
  		    strerror(errno));
  		exit(1);
  	}
  	if (setsockopt(insock, SOL_SOCKET, SO_REUSEADDR, &on,
  		       sizeof(on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "setsockopt(insock, SO_REUSEADDR): %s",
  		    strerror(errno));
  		exit(1);
  	}
  #ifdef IPV6_RECVPKTINFO
  	if (setsockopt(insock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,
  		       sizeof(on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "setsockopt(inbound, IPV6_RECVPKTINFO): %s",
  		    strerror(errno));
  		exit(1);
***************
*** 446,452 ****
  #else
  	if (setsockopt(insock, IPPROTO_IPV6, IPV6_PKTINFO, &on,
  		       sizeof(on)) < 0) {
! 		dprintf(LOG_ERR, FNAME,
  		    "setsockopt(inbound, IPV6_PKTINFO): %s",
  		    strerror(errno));
  		exit(1);
--- 446,452 ----
  #else
  	if (setsockopt(insock, IPPROTO_IPV6, IPV6_PKTINFO, &on,
  		       sizeof(on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "setsockopt(inbound, IPV6_PKTINFO): %s",
  		    strerror(errno));
  		exit(1);
***************
*** 455,467 ****
  #ifdef IPV6_V6ONLY
  	if (setsockopt(insock, IPPROTO_IPV6, IPV6_V6ONLY,
  	    &on, sizeof(on)) < 0) {
! 		dprintf(LOG_ERR, FNAME,
  		    "setsockopt(inbound, IPV6_V6ONLY): %s", strerror(errno));
  		exit(1);
  	}
  #endif
  	if (bind(insock, res->ai_addr, res->ai_addrlen) < 0) {
! 		dprintf(LOG_ERR, FNAME, "bind(insock): %s", strerror(errno));
  		exit(1);
  	}
  	freeaddrinfo(res);
--- 455,467 ----
  #ifdef IPV6_V6ONLY
  	if (setsockopt(insock, IPPROTO_IPV6, IPV6_V6ONLY,
  	    &on, sizeof(on)) < 0) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "setsockopt(inbound, IPV6_V6ONLY): %s", strerror(errno));
  		exit(1);
  	}
  #endif
  	if (bind(insock, res->ai_addr, res->ai_addrlen) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "bind(insock): %s", strerror(errno));
  		exit(1);
  	}
  	freeaddrinfo(res);
***************
*** 469,475 ****
  	hints.ai_flags = 0;
  	error = getaddrinfo(DH6ADDR_ALLAGENT, DH6PORT_UPSTREAM, &hints, &res2);
  	if (error) {
! 		dprintf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
--- 469,475 ----
  	hints.ai_flags = 0;
  	error = getaddrinfo(DH6ADDR_ALLAGENT, DH6PORT_UPSTREAM, &hints, &res2);
  	if (error) {
! 		debug_printf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
***************
*** 480,486 ****
  	    sizeof(mreq6.ipv6mr_multiaddr));
  	if (setsockopt(insock, IPPROTO_IPV6, IPV6_JOIN_GROUP,
  	    &mreq6, sizeof(mreq6))) {
! 		dprintf(LOG_ERR, FNAME,
  		    "setsockopt(insock, IPV6_JOIN_GROUP): %s",
  		    strerror(errno));
  		exit(1);
--- 480,486 ----
  	    sizeof(mreq6.ipv6mr_multiaddr));
  	if (setsockopt(insock, IPPROTO_IPV6, IPV6_JOIN_GROUP,
  	    &mreq6, sizeof(mreq6))) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "setsockopt(insock, IPV6_JOIN_GROUP): %s",
  		    strerror(errno));
  		exit(1);
***************
*** 491,497 ****
  	error = getaddrinfo(DH6ADDR_ALLSERVER, DH6PORT_UPSTREAM,
  			    &hints, &res2);
  	if (error) {
! 		dprintf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
--- 491,497 ----
  	error = getaddrinfo(DH6ADDR_ALLSERVER, DH6PORT_UPSTREAM,
  			    &hints, &res2);
  	if (error) {
! 		debug_printf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
***************
*** 502,508 ****
  	    sizeof(mreq6.ipv6mr_multiaddr));
  	if (setsockopt(insock, IPPROTO_IPV6, IPV6_JOIN_GROUP,
  	    &mreq6, sizeof(mreq6))) {
! 		dprintf(LOG_ERR, FNAME,
  		    "setsockopt(insock, IPV6_JOIN_GROUP): %s",
  		    strerror(errno));
  		exit(1);
--- 502,508 ----
  	    sizeof(mreq6.ipv6mr_multiaddr));
  	if (setsockopt(insock, IPPROTO_IPV6, IPV6_JOIN_GROUP,
  	    &mreq6, sizeof(mreq6))) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "setsockopt(insock, IPV6_JOIN_GROUP): %s",
  		    strerror(errno));
  		exit(1);
***************
*** 512,531 ****
  	hints.ai_flags = 0;
  	error = getaddrinfo(NULL, DH6PORT_DOWNSTREAM, &hints, &res);
  	if (error) {
! 		dprintf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
  	outsock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  	if (outsock < 0) {
! 		dprintf(LOG_ERR, FNAME, "socket(outsock): %s",
  		    strerror(errno));
  		exit(1);
  	}
  	/* set outgoing interface of multicast packets for DHCP reconfig */
  	if (setsockopt(outsock, IPPROTO_IPV6, IPV6_MULTICAST_IF,
  	    &ifidx, sizeof(ifidx)) < 0) {
! 		dprintf(LOG_ERR, FNAME,
  		    "setsockopt(outsock, IPV6_MULTICAST_IF): %s",
  		    strerror(errno));
  		exit(1);
--- 512,531 ----
  	hints.ai_flags = 0;
  	error = getaddrinfo(NULL, DH6PORT_DOWNSTREAM, &hints, &res);
  	if (error) {
! 		debug_printf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
  	outsock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  	if (outsock < 0) {
! 		debug_printf(LOG_ERR, FNAME, "socket(outsock): %s",
  		    strerror(errno));
  		exit(1);
  	}
  	/* set outgoing interface of multicast packets for DHCP reconfig */
  	if (setsockopt(outsock, IPPROTO_IPV6, IPV6_MULTICAST_IF,
  	    &ifidx, sizeof(ifidx)) < 0) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "setsockopt(outsock, IPV6_MULTICAST_IF): %s",
  		    strerror(errno));
  		exit(1);
***************
*** 533,539 ****
  #if !defined(__linux__) && !defined(__sun__)
  	/* make the socket write-only */
  	if (shutdown(outsock, 0)) {
! 		dprintf(LOG_ERR, FNAME, "shutdown(outbound, 0): %s",
  		    strerror(errno));
  		exit(1);
  	}
--- 533,539 ----
  #if !defined(__linux__) && !defined(__sun__)
  	/* make the socket write-only */
  	if (shutdown(outsock, 0)) {
! 		debug_printf(LOG_ERR, FNAME, "shutdown(outbound, 0): %s",
  		    strerror(errno));
  		exit(1);
  	}
***************
*** 546,552 ****
  	hints.ai_protocol = IPPROTO_UDP;
  	error = getaddrinfo("::", DH6PORT_DOWNSTREAM, &hints, &res);
  	if (error) {
! 		dprintf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
--- 546,552 ----
  	hints.ai_protocol = IPPROTO_UDP;
  	error = getaddrinfo("::", DH6PORT_DOWNSTREAM, &hints, &res);
  	if (error) {
! 		debug_printf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
***************
*** 561,567 ****
  	hints.ai_protocol = IPPROTO_UDP;
  	error = getaddrinfo("::", DH6PORT_UPSTREAM, &hints, &res);
  	if (error) {
! 		dprintf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
--- 561,567 ----
  	hints.ai_protocol = IPPROTO_UDP;
  	error = getaddrinfo("::", DH6PORT_UPSTREAM, &hints, &res);
  	if (error) {
! 		debug_printf(LOG_ERR, FNAME, "getaddrinfo: %s",
  		    gai_strerror(error));
  		exit(1);
  	}
***************
*** 572,587 ****
  
  	/* set up control socket */
  	if (ctlkey == NULL)
! 		dprintf(LOG_NOTICE, FNAME, "skip opening control port");
  	else if (dhcp6_ctl_init(ctladdr, ctlport,
  	    DHCP6CTL_DEF_COMMANDQUEUELEN, &ctlsock)) {
! 		dprintf(LOG_ERR, FNAME,
  		    "failed to initialize control channel");
  		exit(1);
  	}
  
  	if (signal(SIGTERM, server6_signal) == SIG_ERR) {
! 		dprintf(LOG_WARNING, FNAME, "failed to set signal: %s",
  		    strerror(errno));
  		exit(1);
  	}
--- 572,587 ----
  
  	/* set up control socket */
  	if (ctlkey == NULL)
! 		debug_printf(LOG_NOTICE, FNAME, "skip opening control port");
  	else if (dhcp6_ctl_init(ctladdr, ctlport,
  	    DHCP6CTL_DEF_COMMANDQUEUELEN, &ctlsock)) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "failed to initialize control channel");
  		exit(1);
  	}
  
  	if (signal(SIGTERM, server6_signal) == SIG_ERR) {
! 		debug_printf(LOG_WARNING, FNAME, "failed to set signal: %s",
  		    strerror(errno));
  		exit(1);
  	}
***************
*** 625,631 ****
  		switch (ret) {
  		case -1:
  			if (errno != EINTR) {
! 				dprintf(LOG_ERR, FNAME, "select: %s",
  				    strerror(errno));
  				exit(1);
  			}
--- 625,631 ----
  		switch (ret) {
  		case -1:
  			if (errno != EINTR) {
! 				debug_printf(LOG_ERR, FNAME, "select: %s",
  				    strerror(errno));
  				exit(1);
  			}
***************
*** 712,742 ****
  	commandlen = (int)(ntohs(ctlhead->len));
  	version = ntohs(ctlhead->version);
  	if (len != sizeof(struct dhcp6ctl) + commandlen) {
! 		dprintf(LOG_ERR, FNAME,
  		    "assumption failure: command length mismatch");
  		return (DHCP6CTL_R_FAILURE);
  	}
  
  	/* replay protection and message authentication */
  	if ((now = time(NULL)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "failed to get current time: %s",
  		    strerror(errno));
  		return (DHCP6CTL_R_FAILURE);
  	}
  	ts0 = (u_int32_t)now;
  	ts = ntohl(ctlhead->timestamp);
  	if (ts + CTLSKEW < ts0 || (ts - CTLSKEW) > ts0) {
! 		dprintf(LOG_INFO, FNAME, "timestamp is out of range");
  		return (DHCP6CTL_R_FAILURE);
  	}
  
  	if (ctlkey == NULL) {	/* should not happen!! */
! 		dprintf(LOG_ERR, FNAME, "no secret key for control channel");
  		return (DHCP6CTL_R_FAILURE);
  	}
  	if (dhcp6_verify_mac(buf, len, DHCP6CTL_AUTHPROTO_UNDEF,
  	    DHCP6CTL_AUTHALG_HMACMD5, sizeof(*ctlhead), ctlkey) != 0) {
! 		dprintf(LOG_INFO, FNAME, "authentication failure");
  		return (DHCP6CTL_R_FAILURE);
  	}
  
--- 712,742 ----
  	commandlen = (int)(ntohs(ctlhead->len));
  	version = ntohs(ctlhead->version);
  	if (len != sizeof(struct dhcp6ctl) + commandlen) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "assumption failure: command length mismatch");
  		return (DHCP6CTL_R_FAILURE);
  	}
  
  	/* replay protection and message authentication */
  	if ((now = time(NULL)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "failed to get current time: %s",
  		    strerror(errno));
  		return (DHCP6CTL_R_FAILURE);
  	}
  	ts0 = (u_int32_t)now;
  	ts = ntohl(ctlhead->timestamp);
  	if (ts + CTLSKEW < ts0 || (ts - CTLSKEW) > ts0) {
! 		debug_printf(LOG_INFO, FNAME, "timestamp is out of range");
  		return (DHCP6CTL_R_FAILURE);
  	}
  
  	if (ctlkey == NULL) {	/* should not happen!! */
! 		debug_printf(LOG_ERR, FNAME, "no secret key for control channel");
  		return (DHCP6CTL_R_FAILURE);
  	}
  	if (dhcp6_verify_mac(buf, len, DHCP6CTL_AUTHPROTO_UNDEF,
  	    DHCP6CTL_AUTHALG_HMACMD5, sizeof(*ctlhead), ctlkey) != 0) {
! 		debug_printf(LOG_INFO, FNAME, "authentication failure");
  		return (DHCP6CTL_R_FAILURE);
  	}
  
***************
*** 744,757 ****
  	commandlen -= ctldigestlen;
  
  	if (version > DHCP6CTL_VERSION) {
! 		dprintf(LOG_INFO, FNAME, "unsupported version: %d", version);
  		return (DHCP6CTL_R_FAILURE);
  	}
  
  	switch (command) {
  	case DHCP6CTL_COMMAND_RELOAD:
  		if (commandlen != 0) {
! 			dprintf(LOG_INFO, FNAME, "invalid command length "
  			    "for reload: %d", commandlen);
  			return (DHCP6CTL_R_DONE);
  		}
--- 744,757 ----
  	commandlen -= ctldigestlen;
  
  	if (version > DHCP6CTL_VERSION) {
! 		debug_printf(LOG_INFO, FNAME, "unsupported version: %d", version);
  		return (DHCP6CTL_R_FAILURE);
  	}
  
  	switch (command) {
  	case DHCP6CTL_COMMAND_RELOAD:
  		if (commandlen != 0) {
! 			debug_printf(LOG_INFO, FNAME, "invalid command length "
  			    "for reload: %d", commandlen);
  			return (DHCP6CTL_R_DONE);
  		}
***************
*** 759,765 ****
  		break;
  	case DHCP6CTL_COMMAND_STOP:
  		if (commandlen != 0) {
! 			dprintf(LOG_INFO, FNAME, "invalid command length "
  			    "for stop: %d", commandlen);
  			return (DHCP6CTL_R_DONE);
  		}
--- 759,765 ----
  		break;
  	case DHCP6CTL_COMMAND_STOP:
  		if (commandlen != 0) {
! 			debug_printf(LOG_INFO, FNAME, "invalid command length "
  			    "for stop: %d", commandlen);
  			return (DHCP6CTL_R_DONE);
  		}
***************
*** 769,775 ****
  		if (get_val32(&bp, &commandlen, &p32))
  			return (DHCP6CTL_R_FAILURE);
  		if (p32 != DHCP6CTL_BINDING) {
! 			dprintf(LOG_INFO, FNAME,
  			    "unknown remove target: %ul", p32);
  			return (DHCP6CTL_R_FAILURE);
  		}
--- 769,775 ----
  		if (get_val32(&bp, &commandlen, &p32))
  			return (DHCP6CTL_R_FAILURE);
  		if (p32 != DHCP6CTL_BINDING) {
! 			debug_printf(LOG_INFO, FNAME,
  			    "unknown remove target: %ul", p32);
  			return (DHCP6CTL_R_FAILURE);
  		}
***************
*** 777,783 ****
  		if (get_val32(&bp, &commandlen, &p32))
  			return (DHCP6CTL_R_FAILURE);
  		if (p32 != DHCP6CTL_BINDING_IA) {
! 			dprintf(LOG_INFO, FNAME, "unknown binding type: %ul",
  			    p32);
  			return (DHCP6CTL_R_FAILURE);
  		}
--- 777,783 ----
  		if (get_val32(&bp, &commandlen, &p32))
  			return (DHCP6CTL_R_FAILURE);
  		if (p32 != DHCP6CTL_BINDING_IA) {
! 			debug_printf(LOG_INFO, FNAME, "unknown binding type: %ul",
  			    p32);
  			return (DHCP6CTL_R_FAILURE);
  		}
***************
*** 786,792 ****
  			return (DHCP6CTL_R_FAILURE);
  		if (ntohl(iaspec.type) != DHCP6CTL_IA_PD &&
  		    ntohl(iaspec.type) != DHCP6CTL_IA_NA) {
! 			dprintf(LOG_INFO, FNAME, "unknown IA type: %ul",
  			    ntohl(iaspec.type));
  			return (DHCP6CTL_R_FAILURE);
  		}
--- 786,792 ----
  			return (DHCP6CTL_R_FAILURE);
  		if (ntohl(iaspec.type) != DHCP6CTL_IA_PD &&
  		    ntohl(iaspec.type) != DHCP6CTL_IA_NA) {
! 			debug_printf(LOG_INFO, FNAME, "unknown IA type: %ul",
  			    ntohl(iaspec.type));
  			return (DHCP6CTL_R_FAILURE);
  		}
***************
*** 794,800 ****
  		duidlen = ntohl(iaspec.duidlen);
  
  		if (duidlen > commandlen) {
! 			dprintf(LOG_INFO, FNAME, "DUID length mismatch");
  			return (DHCP6CTL_R_FAILURE);
  		}
  
--- 794,800 ----
  		duidlen = ntohl(iaspec.duidlen);
  
  		if (duidlen > commandlen) {
! 			debug_printf(LOG_INFO, FNAME, "DUID length mismatch");
  			return (DHCP6CTL_R_FAILURE);
  		}
  
***************
*** 807,813 ****
  			binding = find_binding(&duid, DHCP6_BINDING_IA,
  			    DHCP6_LISTVAL_IANA, iaid);
  			if (binding == NULL) {
! 				dprintf(LOG_INFO, FNAME, "no such binding");
  				return (DHCP6CTL_R_FAILURE);
  			}
  		}
--- 807,813 ----
  			binding = find_binding(&duid, DHCP6_BINDING_IA,
  			    DHCP6_LISTVAL_IANA, iaid);
  			if (binding == NULL) {
! 				debug_printf(LOG_INFO, FNAME, "no such binding");
  				return (DHCP6CTL_R_FAILURE);
  			}
  		}
***************
*** 815,821 ****
  		    
  		break;
  	default:
! 		dprintf(LOG_INFO, FNAME,
  		    "unknown control command: %d (len=%d)",
  		    (int)command, commandlen);
  		return (DHCP6CTL_R_FAILURE);
--- 815,821 ----
  		    
  		break;
  	default:
! 		debug_printf(LOG_INFO, FNAME,
  		    "unknown control command: %d (len=%d)",
  		    (int)command, commandlen);
  		return (DHCP6CTL_R_FAILURE);
***************
*** 829,840 ****
  {
  	/* reload the configuration file */
  	if (cfparse(conffile) != 0) {
! 		dprintf(LOG_WARNING, FNAME,
  		    "failed to reload configuration file");
  		return;
  	}
  
! 	dprintf(LOG_NOTICE, FNAME, "server reloaded");
  
  	return;
  }
--- 829,840 ----
  {
  	/* reload the configuration file */
  	if (cfparse(conffile) != 0) {
! 		debug_printf(LOG_WARNING, FNAME,
  		    "failed to reload configuration file");
  		return;
  	}
  
! 	debug_printf(LOG_NOTICE, FNAME, "server reloaded");
  
  	return;
  }
***************
*** 844,850 ****
  {
  	/* Right now, we simply stop running */
  
! 	dprintf(LOG_NOTICE, FNAME, "exiting");
  
  	exit (0);
  }
--- 844,850 ----
  {
  	/* Right now, we simply stop running */
  
! 	debug_printf(LOG_NOTICE, FNAME, "exiting");
  
  	exit (0);
  }
***************
*** 883,889 ****
  	mhdr.msg_controllen = sizeof(cmsgbuf);
  
  	if ((len = recvmsg(insock, &mhdr, 0)) < 0) {
! 		dprintf(LOG_ERR, FNAME, "recvmsg: %s", strerror(errno));
  		return;
  	}
  	fromlen = mhdr.msg_namelen;
--- 883,889 ----
  	mhdr.msg_controllen = sizeof(cmsgbuf);
  
  	if ((len = recvmsg(insock, &mhdr, 0)) < 0) {
! 		debug_printf(LOG_ERR, FNAME, "recvmsg: %s", strerror(errno));
  		return;
  	}
  	fromlen = mhdr.msg_namelen;
***************
*** 897,903 ****
  		}
  	}
  	if (pi == NULL) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to get packet info");
  		return;
  	}
  	/*
--- 897,903 ----
  		}
  	}
  	if (pi == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to get packet info");
  		return;
  	}
  	/*
***************
*** 908,914 ****
  	if (pi->ipi6_ifindex != ifidx)
  		return;
  	if ((ifp = find_ifconfbyid((unsigned int)pi->ipi6_ifindex)) == NULL) {
! 		dprintf(LOG_INFO, FNAME, "unexpected interface (%d)",
  		    (unsigned int)pi->ipi6_ifindex);
  		return;
  	}
--- 908,914 ----
  	if (pi->ipi6_ifindex != ifidx)
  		return;
  	if ((ifp = find_ifconfbyid((unsigned int)pi->ipi6_ifindex)) == NULL) {
! 		debug_printf(LOG_INFO, FNAME, "unexpected interface (%d)",
  		    (unsigned int)pi->ipi6_ifindex);
  		return;
  	}
***************
*** 916,926 ****
  	dh6 = (struct dhcp6 *)rdatabuf;
  
  	if (len < sizeof(*dh6)) {
! 		dprintf(LOG_INFO, FNAME, "short packet (%d bytes)", len);
  		return;
  	}
  
! 	dprintf(LOG_DEBUG, FNAME, "received %s from %s",
  	    dhcp6msgstr(dh6->dh6_msgtype),
  	    addr2str((struct sockaddr *)&from));
  
--- 916,926 ----
  	dh6 = (struct dhcp6 *)rdatabuf;
  
  	if (len < sizeof(*dh6)) {
! 		debug_printf(LOG_INFO, FNAME, "short packet (%d bytes)", len);
  		return;
  	}
  
! 	debug_printf(LOG_DEBUG, FNAME, "received %s from %s",
  	    dhcp6msgstr(dh6->dh6_msgtype),
  	    addr2str((struct sockaddr *)&from));
  
***************
*** 935,941 ****
  	    dh6->dh6_msgtype == DH6_CONFIRM ||
  	    dh6->dh6_msgtype == DH6_REBIND ||
  	    dh6->dh6_msgtype == DH6_INFORM_REQ)) {
! 		dprintf(LOG_INFO, FNAME, "invalid unicast message");
  		return;
  	}
  
--- 935,941 ----
  	    dh6->dh6_msgtype == DH6_CONFIRM ||
  	    dh6->dh6_msgtype == DH6_REBIND ||
  	    dh6->dh6_msgtype == DH6_INFORM_REQ)) {
! 		debug_printf(LOG_INFO, FNAME, "invalid unicast message");
  		return;
  	}
  
***************
*** 945,951 ****
  	 * reject them here.
  	 */
  	if (dh6->dh6_msgtype == DH6_RELAY_REPLY) {
! 		dprintf(LOG_INFO, FNAME, "relay reply message from %s",
  		    addr2str((struct sockaddr *)&from));
  		return;
  		
--- 945,951 ----
  	 * reject them here.
  	 */
  	if (dh6->dh6_msgtype == DH6_RELAY_REPLY) {
! 		debug_printf(LOG_INFO, FNAME, "relay reply message from %s",
  		    addr2str((struct sockaddr *)&from));
  		return;
  		
***************
*** 967,973 ****
  	dhcp6_init_options(&optinfo);
  	if (dhcp6_get_options((struct dhcp6opt *)(dh6 + 1),
  	    optend, &optinfo) < 0) {
! 		dprintf(LOG_INFO, FNAME, "failed to parse options");
  		goto end;
  	}
  
--- 967,973 ----
  	dhcp6_init_options(&optinfo);
  	if (dhcp6_get_options((struct dhcp6opt *)(dh6 + 1),
  	    optend, &optinfo) < 0) {
! 		debug_printf(LOG_INFO, FNAME, "failed to parse options");
  		goto end;
  	}
  
***************
*** 1005,1011 ****
  		    (struct sockaddr *)&from, fromlen, &relayinfohead);
  		break;
  	default:
! 		dprintf(LOG_INFO, FNAME, "unknown or unsupported msgtype (%s)",
  		    dhcp6msgstr(dh6->dh6_msgtype));
  		break;
  	}
--- 1005,1011 ----
  		    (struct sockaddr *)&from, fromlen, &relayinfohead);
  		break;
  	default:
! 		debug_printf(LOG_INFO, FNAME, "unknown or unsupported msgtype (%s)",
  		    dhcp6msgstr(dh6->dh6_msgtype));
  		break;
  	}
***************
*** 1050,1060 ****
    again:
  	len = (void *)optend - (void *)dh6relay;
  	if (len < sizeof (*dh6relay)) {
! 		dprintf(LOG_INFO, FNAME, "short relay message from %s",
  		    addr2str(from));
  		return (-1);
  	}
! 	dprintf(LOG_DEBUG, FNAME,
  	    "dhcp6 relay: hop=%d, linkaddr=%s, peeraddr=%s",
  	    dh6relay->dh6relay_hcnt,
  	    in6addr2str(&dh6relay->dh6relay_linkaddr, 0),
--- 1050,1060 ----
    again:
  	len = (void *)optend - (void *)dh6relay;
  	if (len < sizeof (*dh6relay)) {
! 		debug_printf(LOG_INFO, FNAME, "short relay message from %s",
  		    addr2str(from));
  		return (-1);
  	}
! 	debug_printf(LOG_DEBUG, FNAME,
  	    "dhcp6 relay: hop=%d, linkaddr=%s, peeraddr=%s",
  	    dh6relay->dh6relay_hcnt,
  	    in6addr2str(&dh6relay->dh6relay_linkaddr, 0),
***************
*** 1066,1078 ****
  	dhcp6_init_options(&optinfo);
  	if (dhcp6_get_options((struct dhcp6opt *)(dh6relay + 1),
  	    optend, &optinfo) < 0) {
! 		dprintf(LOG_INFO, FNAME, "failed to parse options");
  		return (-1);
  	}
  
  	/* A relay forward message must include a relay message option */
  	if (optinfo.relaymsg_msg == NULL) {
! 		dprintf(LOG_INFO, FNAME, "relay forward from %s "
  		    "without a relay message", addr2str(from));
  		return (-1);
  	}
--- 1066,1078 ----
  	dhcp6_init_options(&optinfo);
  	if (dhcp6_get_options((struct dhcp6opt *)(dh6relay + 1),
  	    optend, &optinfo) < 0) {
! 		debug_printf(LOG_INFO, FNAME, "failed to parse options");
  		return (-1);
  	}
  
  	/* A relay forward message must include a relay message option */
  	if (optinfo.relaymsg_msg == NULL) {
! 		debug_printf(LOG_INFO, FNAME, "relay forward from %s "
  		    "without a relay message", addr2str(from));
  		return (-1);
  	}
***************
*** 1080,1092 ****
  	/* relay message must contain a DHCPv6 message. */
  	len = optinfo.relaymsg_len;
  	if (len < sizeof (struct dhcp6)) {
! 		dprintf(LOG_INFO, FNAME,
  		    "short packet (%d bytes) in relay message", len);
  		return (-1);
  	}
  
  	if ((relayinfo = malloc(sizeof (*relayinfo))) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "failed to allocate relay info");
  		return (-1);
  	}
  	memset(relayinfo, 0, sizeof (*relayinfo));
--- 1080,1092 ----
  	/* relay message must contain a DHCPv6 message. */
  	len = optinfo.relaymsg_len;
  	if (len < sizeof (struct dhcp6)) {
! 		debug_printf(LOG_INFO, FNAME,
  		    "short packet (%d bytes) in relay message", len);
  		return (-1);
  	}
  
  	if ((relayinfo = malloc(sizeof (*relayinfo))) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "failed to allocate relay info");
  		return (-1);
  	}
  	memset(relayinfo, 0, sizeof (*relayinfo));
***************
*** 1137,1207 ****
  {
  	/* SIP domain name */
  	if (dhcp6_copy_list(&optinfo->sipname_list, &sipnamelist)) {
! 		dprintf(LOG_ERR, FNAME,
  		    "failed to copy SIP domain list");
  		return (-1);
  	}
  
  	/* SIP server */
  	if (dhcp6_copy_list(&optinfo->sip_list, &siplist)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy SIP servers");
  		return (-1);
  	}
  
  	/* DNS server */
  	if (dhcp6_copy_list(&optinfo->dns_list, &dnslist)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy DNS servers");
  		return (-1);
  	}
  
  	/* DNS search list */
  	if (dhcp6_copy_list(&optinfo->dnsname_list, &dnsnamelist)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy DNS search list");
  		return (-1);
  	}
  
  	/* NTP server */
  	if (dhcp6_copy_list(&optinfo->ntp_list, &ntplist)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy NTP servers");
  		return (-1);
  	}
  
  	/* NIS domain name */
  	if (dhcp6_copy_list(&optinfo->nisname_list, &nisnamelist)) {
! 		dprintf(LOG_ERR, FNAME,
  		    "failed to copy NIS domain list");
  		return (-1);
  	}
  
  	/* NIS server */
  	if (dhcp6_copy_list(&optinfo->nis_list, &nislist)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy NIS servers");
  		return (-1);
  	}
  
  	/* NIS+ domain name */
  	if (dhcp6_copy_list(&optinfo->nispname_list, &nispnamelist)) {
! 		dprintf(LOG_ERR, FNAME,
  		    "failed to copy NIS+ domain list");
  		return (-1);
  	}
  
  	/* NIS+ server */
  	if (dhcp6_copy_list(&optinfo->nisp_list, &nisplist)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy NIS+ servers");
  		return (-1);
  	}
  
  	/* BCMCS domain name */
  	if (dhcp6_copy_list(&optinfo->bcmcsname_list, &bcmcsnamelist)) {
! 		dprintf(LOG_ERR, FNAME,
  		    "failed to copy BCMCS domain list");
  		return (-1);
  	}
  
  	/* BCMCS server */
  	if (dhcp6_copy_list(&optinfo->bcmcs_list, &bcmcslist)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy BCMCS servers");
  		return (-1);
  	}
  
--- 1137,1207 ----
  {
  	/* SIP domain name */
  	if (dhcp6_copy_list(&optinfo->sipname_list, &sipnamelist)) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "failed to copy SIP domain list");
  		return (-1);
  	}
  
  	/* SIP server */
  	if (dhcp6_copy_list(&optinfo->sip_list, &siplist)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy SIP servers");
  		return (-1);
  	}
  
  	/* DNS server */
  	if (dhcp6_copy_list(&optinfo->dns_list, &dnslist)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy DNS servers");
  		return (-1);
  	}
  
  	/* DNS search list */
  	if (dhcp6_copy_list(&optinfo->dnsname_list, &dnsnamelist)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy DNS search list");
  		return (-1);
  	}
  
  	/* NTP server */
  	if (dhcp6_copy_list(&optinfo->ntp_list, &ntplist)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy NTP servers");
  		return (-1);
  	}
  
  	/* NIS domain name */
  	if (dhcp6_copy_list(&optinfo->nisname_list, &nisnamelist)) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "failed to copy NIS domain list");
  		return (-1);
  	}
  
  	/* NIS server */
  	if (dhcp6_copy_list(&optinfo->nis_list, &nislist)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy NIS servers");
  		return (-1);
  	}
  
  	/* NIS+ domain name */
  	if (dhcp6_copy_list(&optinfo->nispname_list, &nispnamelist)) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "failed to copy NIS+ domain list");
  		return (-1);
  	}
  
  	/* NIS+ server */
  	if (dhcp6_copy_list(&optinfo->nisp_list, &nisplist)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy NIS+ servers");
  		return (-1);
  	}
  
  	/* BCMCS domain name */
  	if (dhcp6_copy_list(&optinfo->bcmcsname_list, &bcmcsnamelist)) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "failed to copy BCMCS domain list");
  		return (-1);
  	}
  
  	/* BCMCS server */
  	if (dhcp6_copy_list(&optinfo->bcmcs_list, &bcmcslist)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy BCMCS servers");
  		return (-1);
  	}
  
***************
*** 1237,1246 ****
  	 * [RFC3315 Section 15.2]
  	 */
  	if (optinfo->clientID.duid_len == 0) {
! 		dprintf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	} else {
! 		dprintf(LOG_DEBUG, FNAME, "client ID %s",
  		    duidstr(&optinfo->clientID));
  	}
  
--- 1237,1246 ----
  	 * [RFC3315 Section 15.2]
  	 */
  	if (optinfo->clientID.duid_len == 0) {
! 		debug_printf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	} else {
! 		debug_printf(LOG_DEBUG, FNAME, "client ID %s",
  		    duidstr(&optinfo->clientID));
  	}
  
***************
*** 1250,1262 ****
  	 * [RFC3315 Section 15.2]
  	 */
  	if (optinfo->serverID.duid_len) {
! 		dprintf(LOG_INFO, FNAME, "server ID option found");
  		return (-1);
  	}
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		dprintf(LOG_DEBUG, FNAME, "found a host configuration for %s",
  		    client_conf->name);
  	}
  
--- 1250,1262 ----
  	 * [RFC3315 Section 15.2]
  	 */
  	if (optinfo->serverID.duid_len) {
! 		debug_printf(LOG_INFO, FNAME, "server ID option found");
  		return (-1);
  	}
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		debug_printf(LOG_DEBUG, FNAME, "found a host configuration for %s",
  		    client_conf->name);
  	}
  
***************
*** 1267,1273 ****
  
  	/* process authentication */
  	if (process_auth(dh6, len, client_conf, optinfo, &roptinfo)) {
! 		dprintf(LOG_INFO, FNAME, "failed to process authentication "
  		    "information for %s",
  		    clientstr(client_conf, &optinfo->clientID));
  		goto fail;
--- 1267,1273 ----
  
  	/* process authentication */
  	if (process_auth(dh6, len, client_conf, optinfo, &roptinfo)) {
! 		debug_printf(LOG_INFO, FNAME, "failed to process authentication "
  		    "information for %s",
  		    clientstr(client_conf, &optinfo->clientID));
  		goto fail;
***************
*** 1275,1287 ****
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  
  	/* copy client information back */
  	if (duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
--- 1275,1287 ----
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  
  	/* copy client information back */
  	if (duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
***************
*** 1291,1297 ****
  
  	/* add other configuration information */
  	if (set_statelessinfo(DH6_SOLICIT, &roptinfo)) {
! 		dprintf(LOG_ERR, FNAME,
  		    "failed to set other stateless information");
  		goto fail;
  	}
--- 1291,1297 ----
  
  	/* add other configuration information */
  	if (set_statelessinfo(DH6_SOLICIT, &roptinfo)) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "failed to set other stateless information");
  		goto fail;
  	}
***************
*** 1318,1324 ****
  		/* make a local copy of the configured prefixes */
  		if (client_conf &&
  		    dhcp6_copy_list(&conflist, &client_conf->prefix_list)) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to make local data");
  			goto fail;
  		}
--- 1318,1324 ----
  		/* make a local copy of the configured prefixes */
  		if (client_conf &&
  		    dhcp6_copy_list(&conflist, &client_conf->prefix_list)) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to make local data");
  			goto fail;
  		}
***************
*** 1364,1370 ****
  		if (client_conf == NULL && ifp->pool.name) {
  			if ((client_conf = create_dynamic_hostconf(&optinfo->clientID,
  				&ifp->pool)) == NULL)
! 				dprintf(LOG_NOTICE, FNAME,
  			    	"failed to make host configuration");
  		}
  		TAILQ_INIT(&conflist);
--- 1364,1370 ----
  		if (client_conf == NULL && ifp->pool.name) {
  			if ((client_conf = create_dynamic_hostconf(&optinfo->clientID,
  				&ifp->pool)) == NULL)
! 				debug_printf(LOG_NOTICE, FNAME,
  			    	"failed to make host configuration");
  		}
  		TAILQ_INIT(&conflist);
***************
*** 1372,1378 ****
  		/* make a local copy of the configured addresses */
  		if (client_conf &&
  		    dhcp6_copy_list(&conflist, &client_conf->addr_list)) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to make local data");
  			goto fail;
  		}
--- 1372,1378 ----
  		/* make a local copy of the configured addresses */
  		if (client_conf &&
  		    dhcp6_copy_list(&conflist, &client_conf->addr_list)) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to make local data");
  			goto fail;
  		}
***************
*** 1442,1458 ****
  
  	/* the message must include a Server Identifier option */
  	if (optinfo->serverID.duid_len == 0) {
! 		dprintf(LOG_INFO, FNAME, "no server ID option");
  		return (-1);
  	}
  	/* the contents of the Server Identifier option must match ours */
  	if (duidcmp(&optinfo->serverID, &server_duid)) {
! 		dprintf(LOG_INFO, FNAME, "server ID mismatch");
  		return (-1);
  	}
  	/* the message must include a Client Identifier option */
  	if (optinfo->clientID.duid_len == 0) {
! 		dprintf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  
--- 1442,1458 ----
  
  	/* the message must include a Server Identifier option */
  	if (optinfo->serverID.duid_len == 0) {
! 		debug_printf(LOG_INFO, FNAME, "no server ID option");
  		return (-1);
  	}
  	/* the contents of the Server Identifier option must match ours */
  	if (duidcmp(&optinfo->serverID, &server_duid)) {
! 		debug_printf(LOG_INFO, FNAME, "server ID mismatch");
  		return (-1);
  	}
  	/* the message must include a Client Identifier option */
  	if (optinfo->clientID.duid_len == 0) {
! 		debug_printf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  
***************
*** 1463,1486 ****
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  	/* copy client information back */
  	if (duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		dprintf(LOG_DEBUG, FNAME,
  		    "found a host configuration named %s", client_conf->name);
  	}
  
  	/* process authentication */
  	if (process_auth(dh6, len, client_conf, optinfo, &roptinfo)) {
! 		dprintf(LOG_INFO, FNAME, "failed to process authentication "
  		    "information for %s",
  		    clientstr(client_conf, &optinfo->clientID));
  		goto fail;
--- 1463,1486 ----
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  	/* copy client information back */
  	if (duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "found a host configuration named %s", client_conf->name);
  	}
  
  	/* process authentication */
  	if (process_auth(dh6, len, client_conf, optinfo, &roptinfo)) {
! 		debug_printf(LOG_INFO, FNAME, "failed to process authentication "
  		    "information for %s",
  		    clientstr(client_conf, &optinfo->clientID));
  		goto fail;
***************
*** 1502,1512 ****
  	    TAILQ_EMPTY(relayinfohead)) {
  		u_int16_t stcode = DH6OPT_STCODE_USEMULTICAST;
  
! 		dprintf(LOG_INFO, FNAME, "unexpected unicast message from %s",
  		    addr2str(from));
  		if (dhcp6_add_listval(&roptinfo.stcode_list,
  		    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "failed to add a status code");
  			goto fail;
  		}
  		server6_send(DH6_REPLY, ifp, dh6, optinfo, from,
--- 1502,1512 ----
  	    TAILQ_EMPTY(relayinfohead)) {
  		u_int16_t stcode = DH6OPT_STCODE_USEMULTICAST;
  
! 		debug_printf(LOG_INFO, FNAME, "unexpected unicast message from %s",
  		    addr2str(from));
  		if (dhcp6_add_listval(&roptinfo.stcode_list,
  		    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "failed to add a status code");
  			goto fail;
  		}
  		server6_send(DH6_REPLY, ifp, dh6, optinfo, from,
***************
*** 1536,1542 ****
  		/* make a local copy of the configured prefixes */
  		if (client_conf &&
  		    dhcp6_copy_list(&conflist, &client_conf->prefix_list)) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to make local data");
  			goto fail;
  		}
--- 1536,1542 ----
  		/* make a local copy of the configured prefixes */
  		if (client_conf &&
  		    dhcp6_copy_list(&conflist, &client_conf->prefix_list)) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to make local data");
  			goto fail;
  		}
***************
*** 1561,1567 ****
  				    iapd->val_ia.iaid,
  				    DH6OPT_STCODE_NOPREFIXAVAIL,
  				    &roptinfo.iapd_list)) {
! 					dprintf(LOG_NOTICE, FNAME,
  					    "failed to make an option list");
  					dhcp6_clear_list(&conflist);
  					goto fail;
--- 1561,1567 ----
  				    iapd->val_ia.iaid,
  				    DH6OPT_STCODE_NOPREFIXAVAIL,
  				    &roptinfo.iapd_list)) {
! 					debug_printf(LOG_NOTICE, FNAME,
  					    "failed to make an option list");
  					dhcp6_clear_list(&conflist);
  					goto fail;
***************
*** 1579,1585 ****
  		if (client_conf == NULL && ifp->pool.name) {
  			if ((client_conf = create_dynamic_hostconf(&optinfo->clientID,
  				&ifp->pool)) == NULL)
! 				dprintf(LOG_NOTICE, FNAME,
  			    	"failed to make host configuration");
  		}
  		TAILQ_INIT(&conflist);
--- 1579,1585 ----
  		if (client_conf == NULL && ifp->pool.name) {
  			if ((client_conf = create_dynamic_hostconf(&optinfo->clientID,
  				&ifp->pool)) == NULL)
! 				debug_printf(LOG_NOTICE, FNAME,
  			    	"failed to make host configuration");
  		}
  		TAILQ_INIT(&conflist);
***************
*** 1587,1593 ****
  		/* make a local copy of the configured prefixes */
  		if (client_conf &&
  		    dhcp6_copy_list(&conflist, &client_conf->addr_list)) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to make local data");
  			goto fail;
  		}
--- 1587,1593 ----
  		/* make a local copy of the configured prefixes */
  		if (client_conf &&
  		    dhcp6_copy_list(&conflist, &client_conf->addr_list)) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to make local data");
  			goto fail;
  		}
***************
*** 1605,1611 ****
  				    iana->val_ia.iaid,
  				    DH6OPT_STCODE_NOADDRSAVAIL,
  				    &roptinfo.iana_list)) {
! 					dprintf(LOG_NOTICE, FNAME,
  					    "failed to make an option list");
  					dhcp6_clear_list(&conflist);
  					goto fail;
--- 1605,1611 ----
  				    iana->val_ia.iaid,
  				    DH6OPT_STCODE_NOADDRSAVAIL,
  				    &roptinfo.iana_list)) {
! 					debug_printf(LOG_NOTICE, FNAME,
  					    "failed to make an option list");
  					dhcp6_clear_list(&conflist);
  					goto fail;
***************
*** 1638,1644 ****
  	 * information to be assigned to the client.
  	 */
  	if (set_statelessinfo(DH6_REQUEST, &roptinfo)) {
! 		dprintf(LOG_ERR, FNAME,
  		    "failed to set other stateless information");
  		goto fail;
  	}
--- 1638,1644 ----
  	 * information to be assigned to the client.
  	 */
  	if (set_statelessinfo(DH6_REQUEST, &roptinfo)) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "failed to set other stateless information");
  		goto fail;
  	}
***************
*** 1675,1691 ****
  
  	/* the message must include a Server Identifier option */
  	if (optinfo->serverID.duid_len == 0) {
! 		dprintf(LOG_INFO, FNAME, "no server ID option");
  		return (-1);
  	}
  	/* the contents of the Server Identifier option must match ours */
  	if (duidcmp(&optinfo->serverID, &server_duid)) {
! 		dprintf(LOG_INFO, FNAME, "server ID mismatch");
  		return (-1);
  	}
  	/* the message must include a Client Identifier option */
  	if (optinfo->clientID.duid_len == 0) {
! 		dprintf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  
--- 1675,1691 ----
  
  	/* the message must include a Server Identifier option */
  	if (optinfo->serverID.duid_len == 0) {
! 		debug_printf(LOG_INFO, FNAME, "no server ID option");
  		return (-1);
  	}
  	/* the contents of the Server Identifier option must match ours */
  	if (duidcmp(&optinfo->serverID, &server_duid)) {
! 		debug_printf(LOG_INFO, FNAME, "server ID mismatch");
  		return (-1);
  	}
  	/* the message must include a Client Identifier option */
  	if (optinfo->clientID.duid_len == 0) {
! 		debug_printf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  
***************
*** 1696,1719 ****
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  	/* copy client information back */
  	if (duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		dprintf(LOG_DEBUG, FNAME,
  		    "found a host configuration named %s", client_conf->name);
  	}
  
  	/* process authentication */
  	if (process_auth(dh6, len, client_conf, optinfo, &roptinfo)) {
! 		dprintf(LOG_INFO, FNAME, "failed to process authentication "
  		    "information for %s",
  		    clientstr(client_conf, &optinfo->clientID));
  		goto fail;
--- 1696,1719 ----
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  	/* copy client information back */
  	if (duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "found a host configuration named %s", client_conf->name);
  	}
  
  	/* process authentication */
  	if (process_auth(dh6, len, client_conf, optinfo, &roptinfo)) {
! 		debug_printf(LOG_INFO, FNAME, "failed to process authentication "
  		    "information for %s",
  		    clientstr(client_conf, &optinfo->clientID));
  		goto fail;
***************
*** 1733,1743 ****
  	    TAILQ_EMPTY(relayinfohead)) {
  		u_int16_t stcode = DH6OPT_STCODE_USEMULTICAST;
  
! 		dprintf(LOG_INFO, FNAME, "unexpected unicast message from %s",
  		    addr2str(from));
  		if (dhcp6_add_listval(&roptinfo.stcode_list,
  		    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "failed to add a status code");
  			goto fail;
  		}
  		server6_send(DH6_REPLY, ifp, dh6, optinfo, from,
--- 1733,1743 ----
  	    TAILQ_EMPTY(relayinfohead)) {
  		u_int16_t stcode = DH6OPT_STCODE_USEMULTICAST;
  
! 		debug_printf(LOG_INFO, FNAME, "unexpected unicast message from %s",
  		    addr2str(from));
  		if (dhcp6_add_listval(&roptinfo.stcode_list,
  		    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "failed to add a status code");
  			goto fail;
  		}
  		server6_send(DH6_REPLY, ifp, dh6, optinfo, from,
***************
*** 1762,1768 ****
  
  	/* add other configuration information */
  	if (set_statelessinfo(DH6_RENEW, &roptinfo)) {
! 		dprintf(LOG_ERR, FNAME,
  		    "failed to set other stateless information");
  		goto fail;
  	}
--- 1762,1768 ----
  
  	/* add other configuration information */
  	if (set_statelessinfo(DH6_RENEW, &roptinfo)) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "failed to set other stateless information");
  		goto fail;
  	}
***************
*** 1797,1809 ****
  
  	/* the message must include a Client Identifier option */
  	if (optinfo->clientID.duid_len == 0) {
! 		dprintf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  
  	/* the message must not include a server Identifier option */
  	if (optinfo->serverID.duid_len) {
! 		dprintf(LOG_INFO, FNAME, "server ID option is included in "
  		    "a rebind message");
  		return (-1);
  	}
--- 1797,1809 ----
  
  	/* the message must include a Client Identifier option */
  	if (optinfo->clientID.duid_len == 0) {
! 		debug_printf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  
  	/* the message must not include a server Identifier option */
  	if (optinfo->serverID.duid_len) {
! 		debug_printf(LOG_INFO, FNAME, "server ID option is included in "
  		    "a rebind message");
  		return (-1);
  	}
***************
*** 1815,1838 ****
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  	/* copy client information back */
  	if (duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		dprintf(LOG_DEBUG, FNAME,
  		    "found a host configuration named %s", client_conf->name);
  	}
  
  	/* process authentication */
  	if (process_auth(dh6, len, client_conf, optinfo, &roptinfo)) {
! 		dprintf(LOG_INFO, FNAME, "failed to process authentication "
  		    "information for %s",
  		    clientstr(client_conf, &optinfo->clientID));
  		goto fail;
--- 1815,1838 ----
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  	/* copy client information back */
  	if (duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "found a host configuration named %s", client_conf->name);
  	}
  
  	/* process authentication */
  	if (process_auth(dh6, len, client_conf, optinfo, &roptinfo)) {
! 		debug_printf(LOG_INFO, FNAME, "failed to process authentication "
  		    "information for %s",
  		    clientstr(client_conf, &optinfo->clientID));
  		goto fail;
***************
*** 1864,1876 ****
  	 */
  	if (TAILQ_EMPTY(&roptinfo.iapd_list) &&
  	    TAILQ_EMPTY(&roptinfo.iana_list)) {
! 		dprintf(LOG_INFO, FNAME, "no useful information for a rebind");
  		goto fail;	/* discard the rebind */
  	}
  
  	/* add other configuration information */
  	if (set_statelessinfo(DH6_REBIND, &roptinfo)) {
! 		dprintf(LOG_ERR, FNAME,
  		    "failed to set other stateless information");
  		goto fail;
  	}
--- 1864,1876 ----
  	 */
  	if (TAILQ_EMPTY(&roptinfo.iapd_list) &&
  	    TAILQ_EMPTY(&roptinfo.iana_list)) {
! 		debug_printf(LOG_INFO, FNAME, "no useful information for a rebind");
  		goto fail;	/* discard the rebind */
  	}
  
  	/* add other configuration information */
  	if (set_statelessinfo(DH6_REBIND, &roptinfo)) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "failed to set other stateless information");
  		goto fail;
  	}
***************
*** 1906,1922 ****
  
  	/* the message must include a Server Identifier option */
  	if (optinfo->serverID.duid_len == 0) {
! 		dprintf(LOG_INFO, FNAME, "no server ID option");
  		return (-1);
  	}
  	/* the contents of the Server Identifier option must match ours */
  	if (duidcmp(&optinfo->serverID, &server_duid)) {
! 		dprintf(LOG_INFO, FNAME, "server ID mismatch");
  		return (-1);
  	}
  	/* the message must include a Client Identifier option */
  	if (optinfo->clientID.duid_len == 0) {
! 		dprintf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  
--- 1906,1922 ----
  
  	/* the message must include a Server Identifier option */
  	if (optinfo->serverID.duid_len == 0) {
! 		debug_printf(LOG_INFO, FNAME, "no server ID option");
  		return (-1);
  	}
  	/* the contents of the Server Identifier option must match ours */
  	if (duidcmp(&optinfo->serverID, &server_duid)) {
! 		debug_printf(LOG_INFO, FNAME, "server ID mismatch");
  		return (-1);
  	}
  	/* the message must include a Client Identifier option */
  	if (optinfo->clientID.duid_len == 0) {
! 		debug_printf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  
***************
*** 1927,1950 ****
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  	/* copy client information back */
  	if (duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		dprintf(LOG_DEBUG, FNAME,
  		    "found a host configuration named %s", client_conf->name);
  	}
  
  	/* process authentication */
  	if (process_auth(dh6, len, client_conf, optinfo, &roptinfo)) {
! 		dprintf(LOG_INFO, FNAME, "failed to process authentication "
  		    "information for %s",
  		    clientstr(client_conf, &optinfo->clientID));
  		goto fail;
--- 1927,1950 ----
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  	/* copy client information back */
  	if (duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "found a host configuration named %s", client_conf->name);
  	}
  
  	/* process authentication */
  	if (process_auth(dh6, len, client_conf, optinfo, &roptinfo)) {
! 		debug_printf(LOG_INFO, FNAME, "failed to process authentication "
  		    "information for %s",
  		    clientstr(client_conf, &optinfo->clientID));
  		goto fail;
***************
*** 1964,1974 ****
  	    TAILQ_EMPTY(relayinfohead)) {
  		u_int16_t stcode = DH6OPT_STCODE_USEMULTICAST;
  
! 		dprintf(LOG_INFO, FNAME, "unexpected unicast message from %s",
  		    addr2str(from));
  		if (dhcp6_add_listval(&roptinfo.stcode_list,
  		    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "failed to add a status code");
  			goto fail;
  		}
  		server6_send(DH6_REPLY, ifp, dh6, optinfo, from,
--- 1964,1974 ----
  	    TAILQ_EMPTY(relayinfohead)) {
  		u_int16_t stcode = DH6OPT_STCODE_USEMULTICAST;
  
! 		debug_printf(LOG_INFO, FNAME, "unexpected unicast message from %s",
  		    addr2str(from));
  		if (dhcp6_add_listval(&roptinfo.stcode_list,
  		    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "failed to add a status code");
  			goto fail;
  		}
  		server6_send(DH6_REPLY, ifp, dh6, optinfo, from,
***************
*** 1999,2005 ****
  	stcode = DH6OPT_STCODE_SUCCESS;
  	if (dhcp6_add_listval(&roptinfo.stcode_list,
  	    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to add a status code");
  		goto fail;
  	}
  
--- 1999,2005 ----
  	stcode = DH6OPT_STCODE_SUCCESS;
  	if (dhcp6_add_listval(&roptinfo.stcode_list,
  	    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to add a status code");
  		goto fail;
  	}
  
***************
*** 2035,2051 ****
  
  	/* the message must include a Server Identifier option */
  	if (optinfo->serverID.duid_len == 0) {
! 		dprintf(LOG_INFO, FNAME, "no server ID option");
  		return (-1);
  	}
  	/* the contents of the Server Identifier option must match ours */
  	if (duidcmp(&optinfo->serverID, &server_duid)) {
! 		dprintf(LOG_INFO, FNAME, "server ID mismatch");
  		return (-1);
  	}
  	/* the message must include a Client Identifier option */
  	if (optinfo->clientID.duid_len == 0) {
! 		dprintf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  
--- 2035,2051 ----
  
  	/* the message must include a Server Identifier option */
  	if (optinfo->serverID.duid_len == 0) {
! 		debug_printf(LOG_INFO, FNAME, "no server ID option");
  		return (-1);
  	}
  	/* the contents of the Server Identifier option must match ours */
  	if (duidcmp(&optinfo->serverID, &server_duid)) {
! 		debug_printf(LOG_INFO, FNAME, "server ID mismatch");
  		return (-1);
  	}
  	/* the message must include a Client Identifier option */
  	if (optinfo->clientID.duid_len == 0) {
! 		debug_printf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  
***************
*** 2056,2079 ****
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  	/* copy client information back */
  	if (duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		dprintf(LOG_DEBUG, FNAME,
  		    "found a host configuration named %s", client_conf->name);
  	}
  
  	/* process authentication */
  	if (process_auth(dh6, len, client_conf, optinfo, &roptinfo)) {
! 		dprintf(LOG_INFO, FNAME, "failed to process authentication "
  		    "information for %s",
  		    clientstr(client_conf, &optinfo->clientID));
  		goto fail;
--- 2056,2079 ----
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  	/* copy client information back */
  	if (duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "found a host configuration named %s", client_conf->name);
  	}
  
  	/* process authentication */
  	if (process_auth(dh6, len, client_conf, optinfo, &roptinfo)) {
! 		debug_printf(LOG_INFO, FNAME, "failed to process authentication "
  		    "information for %s",
  		    clientstr(client_conf, &optinfo->clientID));
  		goto fail;
***************
*** 2093,2103 ****
  	    TAILQ_EMPTY(relayinfohead)) {
  		stcode = DH6OPT_STCODE_USEMULTICAST;
  
! 		dprintf(LOG_INFO, FNAME, "unexpected unicast message from %s",
  		    addr2str(from));
  		if (dhcp6_add_listval(&roptinfo.stcode_list,
  		    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
! 			dprintf(LOG_ERR, FNAME, "failed to add a status code");
  			goto fail;
  		}
  		server6_send(DH6_REPLY, ifp, dh6, optinfo, from,
--- 2093,2103 ----
  	    TAILQ_EMPTY(relayinfohead)) {
  		stcode = DH6OPT_STCODE_USEMULTICAST;
  
! 		debug_printf(LOG_INFO, FNAME, "unexpected unicast message from %s",
  		    addr2str(from));
  		if (dhcp6_add_listval(&roptinfo.stcode_list,
  		    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "failed to add a status code");
  			goto fail;
  		}
  		server6_send(DH6_REPLY, ifp, dh6, optinfo, from,
***************
*** 2124,2130 ****
  	stcode = DH6OPT_STCODE_SUCCESS;
  	if (dhcp6_add_listval(&roptinfo.stcode_list,
  	    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to add a status code");
  		goto fail;
  	}
  
--- 2124,2130 ----
  	stcode = DH6OPT_STCODE_SUCCESS;
  	if (dhcp6_add_listval(&roptinfo.stcode_list,
  	    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to add a status code");
  		goto fail;
  	}
  
***************
*** 2162,2173 ****
  
  	/* the message may not include a Server Identifier option */
  	if (optinfo->serverID.duid_len) {
! 		dprintf(LOG_INFO, FNAME, "server ID option found");
  		return (-1);
  	}
  	/* the message must include a Client Identifier option */
  	if (optinfo->clientID.duid_len == 0) {
! 		dprintf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  
--- 2162,2173 ----
  
  	/* the message may not include a Server Identifier option */
  	if (optinfo->serverID.duid_len) {
! 		debug_printf(LOG_INFO, FNAME, "server ID option found");
  		return (-1);
  	}
  	/* the message must include a Client Identifier option */
  	if (optinfo->clientID.duid_len == 0) {
! 		debug_printf(LOG_INFO, FNAME, "no client ID option");
  		return (-1);
  	}
  
***************
*** 2175,2198 ****
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  	/* copy client information back */
  	if (duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		dprintf(LOG_DEBUG, FNAME,
  		    "found a host configuration named %s", client_conf->name);
  	}
  
  	/* process authentication */
  	if (process_auth(dh6, len, client_conf, optinfo, &roptinfo)) {
! 		dprintf(LOG_INFO, FNAME, "failed to process authentication "
  		    "information for %s",
  		    clientstr(client_conf, &optinfo->clientID));
  		goto fail;
--- 2175,2198 ----
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  	/* copy client information back */
  	if (duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "found a host configuration named %s", client_conf->name);
  	}
  
  	/* process authentication */
  	if (process_auth(dh6, len, client_conf, optinfo, &roptinfo)) {
! 		debug_printf(LOG_INFO, FNAME, "failed to process authentication "
  		    "information for %s",
  		    clientstr(client_conf, &optinfo->clientID));
  		goto fail;
***************
*** 2201,2207 ****
  	if (client_conf == NULL && ifp->pool.name) {
  		if ((client_conf = create_dynamic_hostconf(&optinfo->clientID,
  			&ifp->pool)) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  		    	"failed to make host configuration");
  			goto fail;
  		}
--- 2201,2207 ----
  	if (client_conf == NULL && ifp->pool.name) {
  		if ((client_conf = create_dynamic_hostconf(&optinfo->clientID,
  			&ifp->pool)) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  		    	"failed to make host configuration");
  			goto fail;
  		}
***************
*** 2209,2215 ****
  	TAILQ_INIT(&conflist);
  	/* make a local copy of the configured addresses */
  	if (dhcp6_copy_list(&conflist, &client_conf->addr_list)) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to make local data");
  		goto fail;
  	}
--- 2209,2215 ----
  	TAILQ_INIT(&conflist);
  	/* make a local copy of the configured addresses */
  	if (dhcp6_copy_list(&conflist, &client_conf->addr_list)) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to make local data");
  		goto fail;
  	}
***************
*** 2219,2231 ****
  	 * [RFC3315 18.2]. (IA-PD is just ignored [RFC3633 12.1])
  	 */
  	if (TAILQ_EMPTY(&optinfo->iana_list)) {
! 		dprintf(LOG_INFO, FNAME, "no IA-NA option found");
  		goto fail;
  	}
  	for (iana = TAILQ_FIRST(&optinfo->iana_list); iana;
  	    iana = TAILQ_NEXT(iana, link)) {
  		if (TAILQ_EMPTY(&iana->sublist)) {
! 			dprintf(LOG_INFO, FNAME,
  			    "no IA-ADDR option found in IA-NA %d",
  			    iana->val_ia.iaid);
  			goto fail;
--- 2219,2231 ----
  	 * [RFC3315 18.2]. (IA-PD is just ignored [RFC3633 12.1])
  	 */
  	if (TAILQ_EMPTY(&optinfo->iana_list)) {
! 		debug_printf(LOG_INFO, FNAME, "no IA-NA option found");
  		goto fail;
  	}
  	for (iana = TAILQ_FIRST(&optinfo->iana_list); iana;
  	    iana = TAILQ_NEXT(iana, link)) {
  		if (TAILQ_EMPTY(&iana->sublist)) {
! 			debug_printf(LOG_INFO, FNAME,
  			    "no IA-ADDR option found in IA-NA %d",
  			    iana->val_ia.iaid);
  			goto fail;
***************
*** 2248,2254 ****
  				struct relayinfo *relayinfo;
  
  				if (relayinfohead == NULL) {
! 					dprintf(LOG_INFO, FNAME,
  					    "no link-addr found");
  					goto fail;
  				}
--- 2248,2254 ----
  				struct relayinfo *relayinfo;
  
  				if (relayinfohead == NULL) {
! 					debug_printf(LOG_INFO, FNAME,
  					    "no link-addr found");
  					goto fail;
  				}
***************
*** 2262,2268 ****
  			}
  
  			if (memcmp(linkaddr, confaddr, 8) != 0) {
! 				dprintf(LOG_INFO, FNAME,
  				    "%s does not seem to belong to %s's link",
  				    in6addr2str(confaddr, 0),
  				    in6addr2str(linkaddr, 0));
--- 2262,2268 ----
  			}
  
  			if (memcmp(linkaddr, confaddr, 8) != 0) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "%s does not seem to belong to %s's link",
  				    in6addr2str(confaddr, 0),
  				    in6addr2str(linkaddr, 0));
***************
*** 2281,2287 ****
  	    iana = TAILQ_NEXT(iana, link)) {
  		if (make_ia(iana, &conflist, &roptinfo.iana_list,
  		    client_conf, 1) == 0) {
! 			dprintf(LOG_DEBUG, FNAME,
  			    "IA-NA configuration not found");
  			goto fail;
  		}
--- 2281,2287 ----
  	    iana = TAILQ_NEXT(iana, link)) {
  		if (make_ia(iana, &conflist, &roptinfo.iana_list,
  		    client_conf, 1) == 0) {
! 			debug_printf(LOG_DEBUG, FNAME,
  			    "IA-NA configuration not found");
  			goto fail;
  		}
***************
*** 2324,2335 ****
  	 * [RFC3315 Section 15]
  	 */
  	if (!TAILQ_EMPTY(&optinfo->iapd_list)) {
! 		dprintf(LOG_INFO, FNAME,
  		    "information request contains an IA_PD option");
  		return (-1);
  	}
  	if (!TAILQ_EMPTY(&optinfo->iana_list)) {
! 		dprintf(LOG_INFO, FNAME,
  		    "information request contains an IA_NA option");
  		return (-1);
  	}
--- 2324,2335 ----
  	 * [RFC3315 Section 15]
  	 */
  	if (!TAILQ_EMPTY(&optinfo->iapd_list)) {
! 		debug_printf(LOG_INFO, FNAME,
  		    "information request contains an IA_PD option");
  		return (-1);
  	}
  	if (!TAILQ_EMPTY(&optinfo->iana_list)) {
! 		debug_printf(LOG_INFO, FNAME,
  		    "information request contains an IA_NA option");
  		return (-1);
  	}
***************
*** 2337,2343 ****
  	/* if a server identifier is included, it must match ours. */
  	if (optinfo->serverID.duid_len &&
  	    duidcmp(&optinfo->serverID, &server_duid)) {
! 		dprintf(LOG_INFO, FNAME, "server DUID mismatch");
  		return (-1);
  	}
  
--- 2337,2343 ----
  	/* if a server identifier is included, it must match ours. */
  	if (optinfo->serverID.duid_len &&
  	    duidcmp(&optinfo->serverID, &server_duid)) {
! 		debug_printf(LOG_INFO, FNAME, "server DUID mismatch");
  		return (-1);
  	}
  
***************
*** 2348,2367 ****
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  
  	/* copy client information back (if provided) */
  	if (optinfo->clientID.duid_id &&
  	    duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
  	/* set stateless information */
  	if (set_statelessinfo(DH6_INFORM_REQ, &roptinfo)) {
! 		dprintf(LOG_ERR, FNAME,
  		    "failed to set other stateless information");
  		goto fail;
  	}
--- 2348,2367 ----
  
  	/* server identifier option */
  	if (duidcpy(&roptinfo.serverID, &server_duid)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy server ID");
  		goto fail;
  	}
  
  	/* copy client information back (if provided) */
  	if (optinfo->clientID.duid_id &&
  	    duidcpy(&roptinfo.clientID, &optinfo->clientID)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy client ID");
  		goto fail;
  	}
  
  	/* set stateless information */
  	if (set_statelessinfo(DH6_INFORM_REQ, &roptinfo)) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "failed to set other stateless information");
  		goto fail;
  	}
***************
*** 2389,2395 ****
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		dprintf(LOG_DEBUG, FNAME,
  		    "found a host configuration named %s", client_conf->name);
  	}
  
--- 2389,2395 ----
  
  	/* get per-host configuration for the client, if any. */
  	if ((client_conf = find_hostconf(&optinfo->clientID))) {
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "found a host configuration named %s", client_conf->name);
  	}
  
***************
*** 2402,2408 ****
  		 * Sections 18.2.3 and 18.2.4 of RFC3315, and the two sets
  		 * of behavior are identical.
  		 */
! 		dprintf(LOG_INFO, FNAME, "no binding found for %s",
  		    duidstr(&optinfo->clientID));
  
  		switch (msgtype) {
--- 2402,2408 ----
  		 * Sections 18.2.3 and 18.2.4 of RFC3315, and the two sets
  		 * of behavior are identical.
  		 */
! 		debug_printf(LOG_INFO, FNAME, "no binding found for %s",
  		    duidstr(&optinfo->clientID));
  
  		switch (msgtype) {
***************
*** 2416,2422 ****
  			 */
  			if (make_ia_stcode(iap->type, iap->val_ia.iaid,
  			    DH6OPT_STCODE_NOBINDING, retlist)) {
! 				dprintf(LOG_NOTICE, FNAME,
  				    "failed to make an option list");
  				return (-1);
  			}
--- 2416,2422 ----
  			 */
  			if (make_ia_stcode(iap->type, iap->val_ia.iaid,
  			    DH6OPT_STCODE_NOBINDING, retlist)) {
! 				debug_printf(LOG_NOTICE, FNAME,
  				    "failed to make an option list");
  				return (-1);
  			}
***************
*** 2438,2444 ****
  			 */
  			return (-1);
  		default:	/* XXX: should be a bug */
! 			dprintf(LOG_ERR, FNAME, "impossible message type %s",
  			    dhcp6msgstr(msgtype));
  			return (-1);
  		}
--- 2438,2444 ----
  			 */
  			return (-1);
  		default:	/* XXX: should be a bug */
! 			debug_printf(LOG_ERR, FNAME, "impossible message type %s",
  			    dhcp6msgstr(msgtype));
  			return (-1);
  		}
***************
*** 2466,2472 ****
  				blv = dhcp6_find_listval(&binding->val_list,
  				    DHCP6_LISTVAL_PREFIX6, &prefix, 0);
  				if (blv == NULL) {
! 					dprintf(LOG_DEBUG, FNAME,
  					    "%s/%d is not found in %s",
  					    in6addr2str(&prefix.addr, 0),
  					    prefix.plen, bindingstr(binding));
--- 2466,2472 ----
  				blv = dhcp6_find_listval(&binding->val_list,
  				    DHCP6_LISTVAL_PREFIX6, &prefix, 0);
  				if (blv == NULL) {
! 					debug_printf(LOG_DEBUG, FNAME,
  					    "%s/%d is not found in %s",
  					    in6addr2str(&prefix.addr, 0),
  					    prefix.plen, bindingstr(binding));
***************
*** 2482,2488 ****
  				if (dhcp6_add_listval(&ialist,
  				    DHCP6_LISTVAL_PREFIX6, &prefix, NULL)
  				    == NULL) {
! 					dprintf(LOG_NOTICE, FNAME,
  					    "failed  to copy binding info");
  					dhcp6_clear_list(&ialist);
  					return (-1);
--- 2482,2488 ----
  				if (dhcp6_add_listval(&ialist,
  				    DHCP6_LISTVAL_PREFIX6, &prefix, NULL)
  				    == NULL) {
! 					debug_printf(LOG_NOTICE, FNAME,
  					    "failed  to copy binding info");
  					dhcp6_clear_list(&ialist);
  					return (-1);
***************
*** 2496,2502 ****
  				blv = dhcp6_find_listval(&binding->val_list,
  				    DHCP6_LISTVAL_STATEFULADDR6, &saddr, 0);
  				if (blv == NULL) {
! 					dprintf(LOG_DEBUG, FNAME,
  					    "%s is not found in %s",
  					    in6addr2str(&saddr.addr, 0),
  					    bindingstr(binding));
--- 2496,2502 ----
  				blv = dhcp6_find_listval(&binding->val_list,
  				    DHCP6_LISTVAL_STATEFULADDR6, &saddr, 0);
  				if (blv == NULL) {
! 					debug_printf(LOG_DEBUG, FNAME,
  					    "%s is not found in %s",
  					    in6addr2str(&saddr.addr, 0),
  					    bindingstr(binding));
***************
*** 2512,2525 ****
  				if (dhcp6_add_listval(&ialist,
  				    DHCP6_LISTVAL_STATEFULADDR6, &saddr, NULL)
  				    == NULL) {
! 					dprintf(LOG_NOTICE, FNAME,
  					    "failed  to copy binding info");
  					dhcp6_clear_list(&ialist);
  					return (-1);
  				}
  				break;
  			default:
! 				dprintf(LOG_ERR, FNAME, "unsupported IA type");
  				return (-1); /* XXX */
  			}
  		}
--- 2512,2525 ----
  				if (dhcp6_add_listval(&ialist,
  				    DHCP6_LISTVAL_STATEFULADDR6, &saddr, NULL)
  				    == NULL) {
! 					debug_printf(LOG_NOTICE, FNAME,
  					    "failed  to copy binding info");
  					dhcp6_clear_list(&ialist);
  					return (-1);
  				}
  				break;
  			default:
! 				debug_printf(LOG_ERR, FNAME, "unsupported IA type");
  				return (-1); /* XXX */
  			}
  		}
***************
*** 2558,2564 ****
  		 */
  		if (make_ia_stcode(iap->type, iap->val_ia.iaid,
  		    DH6OPT_STCODE_NOBINDING, retlist)) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to make an option list");
  			return (-1);
  		}
--- 2558,2564 ----
  		 */
  		if (make_ia_stcode(iap->type, iap->val_ia.iaid,
  		    DH6OPT_STCODE_NOBINDING, retlist)) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to make an option list");
  			return (-1);
  		}
***************
*** 2580,2586 ****
  			if ((lvia = find_binding_ia(lv, binding)) != NULL) {
  				switch (binding->iatype) {
  					case DHCP6_LISTVAL_IAPD:
! 						dprintf(LOG_DEBUG, FNAME,
  						    "bound prefix %s/%d "
  						    "has been released",
  						    in6addr2str(&lvia->val_prefix6.addr,
--- 2580,2586 ----
  			if ((lvia = find_binding_ia(lv, binding)) != NULL) {
  				switch (binding->iatype) {
  					case DHCP6_LISTVAL_IAPD:
! 						debug_printf(LOG_DEBUG, FNAME,
  						    "bound prefix %s/%d "
  						    "has been released",
  						    in6addr2str(&lvia->val_prefix6.addr,
***************
*** 2589,2595 ****
  						break;
  					case DHCP6_LISTVAL_IANA:
  						release_address(&lvia->val_prefix6.addr);
! 						dprintf(LOG_DEBUG, FNAME,
  						    "bound address %s "
  						    "has been released",
  						    in6addr2str(&lvia->val_prefix6.addr,
--- 2589,2595 ----
  						break;
  					case DHCP6_LISTVAL_IANA:
  						release_address(&lvia->val_prefix6.addr);
! 						debug_printf(LOG_DEBUG, FNAME,
  						    "bound address %s "
  						    "has been released",
  						    in6addr2str(&lvia->val_prefix6.addr,
***************
*** 2633,2639 ****
  		 */
  		if (make_ia_stcode(iap->type, iap->val_ia.iaid,
  		    DH6OPT_STCODE_NOBINDING, retlist)) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to make an option list");
  			return (-1);
  		}
--- 2633,2639 ----
  		 */
  		if (make_ia_stcode(iap->type, iap->val_ia.iaid,
  		    DH6OPT_STCODE_NOBINDING, retlist)) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to make an option list");
  			return (-1);
  		}
***************
*** 2655,2667 ****
  		}
  
  		if ((lvia = find_binding_ia(lv, binding)) == NULL) {
! 			dprintf(LOG_DEBUG, FNAME, "no binding found "
  			    "for address %s",
  			    in6addr2str(&lv->val_statefuladdr6.addr, 0));
  			continue;
  		}
  
! 		dprintf(LOG_DEBUG, FNAME,
  		    "bound address %s has been marked as declined",
  		    in6addr2str(&lvia->val_statefuladdr6.addr, 0));
  		decline_address(&lvia->val_statefuladdr6.addr);
--- 2655,2667 ----
  		}
  
  		if ((lvia = find_binding_ia(lv, binding)) == NULL) {
! 			debug_printf(LOG_DEBUG, FNAME, "no binding found "
  			    "for address %s",
  			    in6addr2str(&lv->val_statefuladdr6.addr, 0));
  			continue;
  		}
  
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "bound address %s has been marked as declined",
  		    in6addr2str(&lvia->val_statefuladdr6.addr, 0));
  		decline_address(&lvia->val_statefuladdr6.addr);
***************
*** 2686,2692 ****
  	int sig;
  {
  
! 	dprintf(LOG_INFO, FNAME, "received a signal (%d)", sig);
  
  	switch (sig) {
  	case SIGTERM:
--- 2686,2692 ----
  	int sig;
  {
  
! 	debug_printf(LOG_INFO, FNAME, "received a signal (%d)", sig);
  
  	switch (sig) {
  	case SIGTERM:
***************
*** 2715,2721 ****
  	struct relayinfo *relayinfo;
  
  	if (sizeof(struct dhcp6) > sizeof(replybuf)) {
! 		dprintf(LOG_ERR, FNAME, "buffer size assumption failed");
  		return (-1);
  	}
  
--- 2715,2721 ----
  	struct relayinfo *relayinfo;
  
  	if (sizeof(struct dhcp6) > sizeof(replybuf)) {
! 		debug_printf(LOG_ERR, FNAME, "buffer size assumption failed");
  		return (-1);
  	}
  
***************
*** 2728,2734 ****
  	/* set options in the reply message */
  	if ((optlen = dhcp6_set_options(type, (struct dhcp6opt *)(dh6 + 1),
  	    (struct dhcp6opt *)(replybuf + sizeof(replybuf)), roptinfo)) < 0) {
! 		dprintf(LOG_INFO, FNAME, "failed to construct reply options");
  		return (-1);
  	}
  	len += optlen;
--- 2728,2734 ----
  	/* set options in the reply message */
  	if ((optlen = dhcp6_set_options(type, (struct dhcp6opt *)(dh6 + 1),
  	    (struct dhcp6opt *)(replybuf + sizeof(replybuf)), roptinfo)) < 0) {
! 		debug_printf(LOG_INFO, FNAME, "failed to construct reply options");
  		return (-1);
  	}
  	len += optlen;
***************
*** 2738,2744 ****
  	case DHCP6_AUTHPROTO_DELAYED:
  		if (client_conf == NULL || client_conf->delayedkey == NULL) {
  			/* This case should have been caught earlier */
! 			dprintf(LOG_ERR, FNAME, "authentication required "
  			    "but not key provided");
  			break;
  		}
--- 2738,2744 ----
  	case DHCP6_AUTHPROTO_DELAYED:
  		if (client_conf == NULL || client_conf->delayedkey == NULL) {
  			/* This case should have been caught earlier */
! 			debug_printf(LOG_ERR, FNAME, "authentication required "
  			    "but not key provided");
  			break;
  		}
***************
*** 2746,2752 ****
  		    roptinfo->authalgorithm,
  		    roptinfo->delayedauth_offset + sizeof(*dh6),
  		    client_conf->delayedkey)) {
! 			dprintf(LOG_WARNING, FNAME, "failed to calculate MAC");
  			return (-1);
  		}
  		break;
--- 2746,2752 ----
  		    roptinfo->authalgorithm,
  		    roptinfo->delayedauth_offset + sizeof(*dh6),
  		    client_conf->delayedkey)) {
! 			debug_printf(LOG_WARNING, FNAME, "failed to calculate MAC");
  			return (-1);
  		}
  		break;
***************
*** 2790,2796 ****
  		    (struct dhcp6opt *)(dh6relay + 1),
  		    (struct dhcp6opt *)(replybuf + sizeof(replybuf)),
  		    &relayopt)) < 0) {
! 			dprintf(LOG_INFO, FNAME,
  			    "failed to construct relay message");
  			dhcp6_clear_options(&relayopt);
  			return (-1);
--- 2790,2796 ----
  		    (struct dhcp6opt *)(dh6relay + 1),
  		    (struct dhcp6opt *)(replybuf + sizeof(replybuf)),
  		    &relayopt)) < 0) {
! 			debug_printf(LOG_INFO, FNAME,
  			    "failed to construct relay message");
  			dhcp6_clear_options(&relayopt);
  			return (-1);
***************
*** 2806,2817 ****
  	dst.sin6_scope_id = ((struct sockaddr_in6 *)from)->sin6_scope_id;
  	if (transmit_sa(outsock, (struct sockaddr *)&dst,
  	    replybuf, len) != 0) {
! 		dprintf(LOG_ERR, FNAME, "transmit %s to %s failed",
  		    dhcp6msgstr(type), addr2str((struct sockaddr *)&dst));
  		return (-1);
  	}
  
! 	dprintf(LOG_DEBUG, FNAME, "transmit %s to %s",
  	    dhcp6msgstr(type), addr2str((struct sockaddr *)&dst));
  
  	return (0);
--- 2806,2817 ----
  	dst.sin6_scope_id = ((struct sockaddr_in6 *)from)->sin6_scope_id;
  	if (transmit_sa(outsock, (struct sockaddr *)&dst,
  	    replybuf, len) != 0) {
! 		debug_printf(LOG_ERR, FNAME, "transmit %s to %s failed",
  		    dhcp6msgstr(type), addr2str((struct sockaddr *)&dst));
  		return (-1);
  	}
  
! 	debug_printf(LOG_DEBUG, FNAME, "transmit %s to %s",
  	    dhcp6msgstr(type), addr2str((struct sockaddr *)&dst));
  
  	return (0);
***************
*** 2833,2845 ****
  	TAILQ_INIT(&stcode_list);
  	if (dhcp6_add_listval(&stcode_list, DHCP6_LISTVAL_STCODE,
  	    &stcode, NULL) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to make an option list");
  		return (-1);
  	}
  
  	if (dhcp6_add_listval(retlist, iatype,
  	    &ia_empty, &stcode_list) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to make an option list");
  		dhcp6_clear_list(&stcode_list);
  		return (-1);
  	}
--- 2833,2845 ----
  	TAILQ_INIT(&stcode_list);
  	if (dhcp6_add_listval(&stcode_list, DHCP6_LISTVAL_STCODE,
  	    &stcode, NULL) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to make an option list");
  		return (-1);
  	}
  
  	if (dhcp6_add_listval(retlist, iatype,
  	    &ia_empty, &stcode_list) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to make an option list");
  		dhcp6_clear_list(&stcode_list);
  		return (-1);
  	}
***************
*** 2870,2876 ****
  		struct dhcp6_list *blist = &binding->val_list;
  		struct dhcp6_listval *bia, *v;
  
! 		dprintf(LOG_DEBUG, FNAME, "we have a binding already: %s",
  		    bindingstr(binding));
  
  		update_binding(binding);
--- 2870,2876 ----
  		struct dhcp6_list *blist = &binding->val_list;
  		struct dhcp6_listval *bia, *v;
  
! 		debug_printf(LOG_DEBUG, FNAME, "we have a binding already: %s",
  		    bindingstr(binding));
  
  		update_binding(binding);
***************
*** 2881,2887 ****
  		calc_ia_timo(&ia, blist, client_conf);
  		if (dhcp6_add_listval(retlist, spec->type, &ia, blist)
  		    == NULL) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to copy binding info");
  			return (0);
  		}
--- 2881,2887 ----
  		calc_ia_timo(&ia, blist, client_conf);
  		if (dhcp6_add_listval(retlist, spec->type, &ia, blist)
  		    == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to copy binding info");
  			return (0);
  		}
***************
*** 2957,2963 ****
  		if (do_binding) {
  			if (add_binding(&client_conf->duid, DHCP6_BINDING_IA,
  			    spec->type, spec->val_ia.iaid, &ialist) == NULL) {
! 				dprintf(LOG_NOTICE, FNAME,
  				    "failed to make a binding");
  				found = 0;
  			}
--- 2957,2963 ----
  		if (do_binding) {
  			if (add_binding(&client_conf->duid, DHCP6_BINDING_IA,
  			    spec->type, spec->val_ia.iaid, &ialist) == NULL) {
! 				debug_printf(LOG_NOTICE, FNAME,
  				    "failed to make a binding");
  				found = 0;
  			}
***************
*** 2998,3004 ****
  				match = 0;
  			break;
  		default:
! 			dprintf(LOG_ERR, FNAME, "unsupported IA type");
  			return (0); /* XXX */
  		}
  	}
--- 2998,3004 ----
  				match = 0;
  			break;
  		default:
! 			debug_printf(LOG_ERR, FNAME, "unsupported IA type");
  			return (0); /* XXX */
  		}
  	}
***************
*** 3030,3039 ****
  	struct pool_conf *pool;
  	int found = 0;
  
! 	dprintf(LOG_DEBUG, FNAME, "called");
  
  	if ((pool = find_pool(poolspec->name)) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "pool '%s' not found", poolspec->name);
  		return (0);
  	}
  
--- 3030,3039 ----
  	struct pool_conf *pool;
  	int found = 0;
  
! 	debug_printf(LOG_DEBUG, FNAME, "called");
  
  	if ((pool = find_pool(poolspec->name)) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "pool '%s' not found", poolspec->name);
  		return (0);
  	}
  
***************
*** 3058,3064 ****
  		}
  	}
  
! 	dprintf(LOG_DEBUG, FNAME, "returns (found=%d)", found);
  
  	return (found);
  }
--- 3058,3064 ----
  		}
  	}
  
! 	debug_printf(LOG_DEBUG, FNAME, "returns (found=%d)", found);
  
  	return (found);
  }
***************
*** 3076,3082 ****
  	iatype = TAILQ_FIRST(ialist)->type;
  	for (iav = TAILQ_FIRST(ialist); iav; iav = TAILQ_NEXT(iav, link)) {
  		if (iav->type != iatype) {
! 			dprintf(LOG_ERR, FNAME,
  			    "assumption failure: IA list is not consistent");
  			exit (1); /* XXX */
  		}
--- 3076,3082 ----
  	iatype = TAILQ_FIRST(ialist)->type;
  	for (iav = TAILQ_FIRST(ialist); iav; iav = TAILQ_NEXT(iav, link)) {
  		if (iav->type != iatype) {
! 			debug_printf(LOG_ERR, FNAME,
  			    "assumption failure: IA list is not consistent");
  			exit (1); /* XXX */
  		}
***************
*** 3142,3148 ****
  				lifetime = iav->val_statefuladdr6.vltime;
  				break;
  			default:
! 				dprintf(LOG_ERR, FNAME, "unsupported IA type");
  				return;	/* XXX */
  			}
  
--- 3142,3148 ----
  				lifetime = iav->val_statefuladdr6.vltime;
  				break;
  			default:
! 				debug_printf(LOG_ERR, FNAME, "unsupported IA type");
  				return;	/* XXX */
  			}
  
***************
*** 3160,3166 ****
  		break;
  	default:
  		/* should be internal error. */
! 		dprintf(LOG_ERR, FNAME, "unknown binding type (%d)",
  		    binding->type);
  		return;
  	}
--- 3160,3166 ----
  		break;
  	default:
  		/* should be internal error. */
! 		debug_printf(LOG_ERR, FNAME, "unknown binding type (%d)",
  		    binding->type);
  		return;
  	}
***************
*** 3180,3192 ****
  	u_int32_t duration = DHCP6_DURATION_INFINITE;
  
  	if ((binding = malloc(sizeof(*binding))) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to allocate memory");
  		return (NULL);
  	}
  	memset(binding, 0, sizeof(*binding));
  	binding->type = btype;
  	if (duidcpy(&binding->clientid, clientid)) {
! 		dprintf(LOG_NOTICE, FNAME, "failed to copy DUID");
  		goto fail;
  	}
  	binding->iatype = iatype;
--- 3180,3192 ----
  	u_int32_t duration = DHCP6_DURATION_INFINITE;
  
  	if ((binding = malloc(sizeof(*binding))) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to allocate memory");
  		return (NULL);
  	}
  	memset(binding, 0, sizeof(*binding));
  	binding->type = btype;
  	if (duidcpy(&binding->clientid, clientid)) {
! 		debug_printf(LOG_NOTICE, FNAME, "failed to copy DUID");
  		goto fail;
  	}
  	binding->iatype = iatype;
***************
*** 3198,3204 ****
  		TAILQ_INIT(&binding->val_list);
  		if (dhcp6_copy_list(&binding->val_list,
  		    (struct dhcp6_list *)val0)) {
! 			dprintf(LOG_NOTICE, FNAME,
  			    "failed to copy binding data");
  			goto fail;
  		}
--- 3198,3204 ----
  		TAILQ_INIT(&binding->val_list);
  		if (dhcp6_copy_list(&binding->val_list,
  		    (struct dhcp6_list *)val0)) {
! 			debug_printf(LOG_NOTICE, FNAME,
  			    "failed to copy binding data");
  			goto fail;
  		}
***************
*** 3211,3223 ****
  				lv_next = TAILQ_NEXT(lv, link);
  
  				if (lv->type != DHCP6_LISTVAL_STATEFULADDR6) {
! 					dprintf(LOG_ERR, FNAME,
  						"unexpected binding value type(%d)", lv->type);
  					continue;
  				}
  
  				if (!lease_address(&lv->val_statefuladdr6.addr)) {
! 					dprintf(LOG_NOTICE, FNAME,
  						"cannot lease address %s",
  						in6addr2str(&lv->val_statefuladdr6.addr, 0));
  					TAILQ_REMOVE(ia_list, lv, link);
--- 3211,3223 ----
  				lv_next = TAILQ_NEXT(lv, link);
  
  				if (lv->type != DHCP6_LISTVAL_STATEFULADDR6) {
! 					debug_printf(LOG_ERR, FNAME,
  						"unexpected binding value type(%d)", lv->type);
  					continue;
  				}
  
  				if (!lease_address(&lv->val_statefuladdr6.addr)) {
! 					debug_printf(LOG_NOTICE, FNAME,
  						"cannot lease address %s",
  						in6addr2str(&lv->val_statefuladdr6.addr, 0));
  					TAILQ_REMOVE(ia_list, lv, link);
***************
*** 3225,3237 ****
  				}
  			}
  			if (TAILQ_EMPTY(ia_list)) {
! 				dprintf(LOG_NOTICE, FNAME, "cannot lease any address");
  				goto fail;
  			}
  		}
  		break;
  	default:
! 		dprintf(LOG_ERR, FNAME, "unexpected binding type(%d)", btype);
  		goto fail;
  	}
  
--- 3225,3237 ----
  				}
  			}
  			if (TAILQ_EMPTY(ia_list)) {
! 				debug_printf(LOG_NOTICE, FNAME, "cannot lease any address");
  				goto fail;
  			}
  		}
  		break;
  	default:
! 		debug_printf(LOG_ERR, FNAME, "unexpected binding type(%d)", btype);
  		goto fail;
  	}
  
***************
*** 3243,3249 ****
  
  		binding->timer = dhcp6_add_timer(binding_timo, binding);
  		if (binding->timer == NULL) {
! 			dprintf(LOG_NOTICE, FNAME, "failed to add timer");
  			goto fail;
  		}
  		timo.tv_sec = (long)duration;
--- 3243,3249 ----
  
  		binding->timer = dhcp6_add_timer(binding_timo, binding);
  		if (binding->timer == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME, "failed to add timer");
  			goto fail;
  		}
  		timo.tv_sec = (long)duration;
***************
*** 3253,3259 ****
  
  	TAILQ_INSERT_TAIL(&dhcp6_binding_head, binding, link);
  
! 	dprintf(LOG_DEBUG, FNAME, "add a new binding %s", bindingstr(binding));
  
  	return (binding);
  
--- 3253,3259 ----
  
  	TAILQ_INSERT_TAIL(&dhcp6_binding_head, binding, link);
  
! 	debug_printf(LOG_DEBUG, FNAME, "add a new binding %s", bindingstr(binding));
  
  	return (binding);
  
***************
*** 3293,3299 ****
  {
  	struct timeval timo;
  
! 	dprintf(LOG_DEBUG, FNAME, "update binding %s for %s",
  	    bindingstr(binding), duidstr(&binding->clientid));
  
  	/* update timestamp and calculate new duration */
--- 3293,3299 ----
  {
  	struct timeval timo;
  
! 	debug_printf(LOG_DEBUG, FNAME, "update binding %s for %s",
  	    bindingstr(binding), duidstr(&binding->clientid));
  
  	/* update timestamp and calculate new duration */
***************
*** 3314,3320 ****
  remove_binding(binding)
  	struct dhcp6_binding *binding;
  {
! 	dprintf(LOG_DEBUG, FNAME, "remove a binding %s",
  	    bindingstr(binding));
  
  	if (binding->timer)
--- 3314,3320 ----
  remove_binding(binding)
  	struct dhcp6_binding *binding;
  {
! 	debug_printf(LOG_DEBUG, FNAME, "remove a binding %s",
  	    bindingstr(binding));
  
  	if (binding->timer)
***************
*** 3341,3347 ****
  
  			for (lv = TAILQ_FIRST(ia_list); lv; lv = TAILQ_NEXT(lv, link)) {
  				if (lv->type != DHCP6_LISTVAL_STATEFULADDR6) {
! 					dprintf(LOG_ERR, FNAME,
  						"unexpected binding value type(%d)", lv->type);
  					continue;
  				}
--- 3341,3347 ----
  
  			for (lv = TAILQ_FIRST(ia_list); lv; lv = TAILQ_NEXT(lv, link)) {
  				if (lv->type != DHCP6_LISTVAL_STATEFULADDR6) {
! 					debug_printf(LOG_ERR, FNAME,
  						"unexpected binding value type(%d)", lv->type);
  					continue;
  				}
***************
*** 3351,3357 ****
  		dhcp6_clear_list(&binding->val_list);
  		break;
  	default:
! 		dprintf(LOG_ERR, FNAME, "unknown binding type %d",
  		    binding->type);
  		break;
  	}
--- 3351,3357 ----
  		dhcp6_clear_list(&binding->val_list);
  		break;
  	default:
! 		debug_printf(LOG_ERR, FNAME, "unknown binding type %d",
  		    binding->type);
  		break;
  	}
***************
*** 3384,3390 ****
  				lifetime = iav->val_prefix6.vltime;
  				break;
  			default:
! 				dprintf(LOG_ERR, FNAME, "internal error: "
  				    "unknown binding type (%d)",
  				    binding->iatype);
  				return (NULL); /* XXX */
--- 3384,3390 ----
  				lifetime = iav->val_prefix6.vltime;
  				break;
  			default:
! 				debug_printf(LOG_ERR, FNAME, "internal error: "
  				    "unknown binding type (%d)",
  				    binding->iatype);
  				return (NULL); /* XXX */
***************
*** 3392,3398 ****
  
  			if (lifetime != DHCP6_DURATION_INFINITE &&
  			    lifetime <= past) {
! 				dprintf(LOG_DEBUG, FNAME, "bound prefix %s/%d"
  				    " in %s has expired",
  				    in6addr2str(&iav->val_prefix6.addr, 0),
  				    iav->val_prefix6.plen,
--- 3392,3398 ----
  
  			if (lifetime != DHCP6_DURATION_INFINITE &&
  			    lifetime <= past) {
! 				debug_printf(LOG_DEBUG, FNAME, "bound prefix %s/%d"
  				    " in %s has expired",
  				    in6addr2str(&iav->val_prefix6.addr, 0),
  				    iav->val_prefix6.plen,
***************
*** 3412,3418 ****
  
  		break;
  	default:
! 		dprintf(LOG_ERR, FNAME, "unknown binding type %d",
  		    binding->type);
  		return (NULL);	/* XXX */
  	}
--- 3412,3418 ----
  
  		break;
  	default:
! 		debug_printf(LOG_ERR, FNAME, "unknown binding type %d",
  		    binding->type);
  		return (NULL);	/* XXX */
  	}
***************
*** 3442,3448 ****
  	case DHCP6_BINDING_IA:
  		return (dhcp6_find_listval(ia_list, key->type, &key->uv, 0));
  	default:
! 		dprintf(LOG_ERR, FNAME, "unknown binding type %d",
  		    binding->type);
  		return (NULL);	/* XXX */
  	}
--- 3442,3448 ----
  	case DHCP6_BINDING_IA:
  		return (dhcp6_find_listval(ia_list, key->type, &key->uv, 0));
  	default:
! 		debug_printf(LOG_ERR, FNAME, "unknown binding type %d",
  		    binding->type);
  		return (NULL);	/* XXX */
  	}
***************
*** 3472,3478 ****
  		    (u_long)binding->duration);
  		break;
  	default:
! 		dprintf(LOG_ERR, FNAME, "unexpected binding type(%d)",
  		    binding->type);
  		return ("???");
  	}
--- 3472,3478 ----
  		    (u_long)binding->duration);
  		break;
  	default:
! 		debug_printf(LOG_ERR, FNAME, "unexpected binding type(%d)",
  		    binding->type);
  		return ("???");
  	}
***************
*** 3506,3512 ****
  		return (0);
  	case DHCP6_AUTHPROTO_DELAYED:
  		if (optinfo->authalgorithm != DHCP6_AUTHALG_HMACMD5) {
! 			dprintf(LOG_INFO, FNAME, "unknown authentication "
  			    "algorithm (%d) required by %s",
  			    optinfo->authalgorithm,
  			    clientstr(client_conf, &optinfo->clientID));
--- 3506,3512 ----
  		return (0);
  	case DHCP6_AUTHPROTO_DELAYED:
  		if (optinfo->authalgorithm != DHCP6_AUTHALG_HMACMD5) {
! 			debug_printf(LOG_INFO, FNAME, "unknown authentication "
  			    "algorithm (%d) required by %s",
  			    optinfo->authalgorithm,
  			    clientstr(client_conf, &optinfo->clientID));
***************
*** 3514,3520 ****
  		}
  
  		if (optinfo->authrdm != DHCP6_AUTHRDM_MONOCOUNTER) {
! 			dprintf(LOG_INFO, FNAME,
  			    "unknown RDM (%d) required by %s",
  			    optinfo->authrdm,
  			    clientstr(client_conf, &optinfo->clientID));
--- 3514,3520 ----
  		}
  
  		if (optinfo->authrdm != DHCP6_AUTHRDM_MONOCOUNTER) {
! 			debug_printf(LOG_INFO, FNAME,
  			    "unknown RDM (%d) required by %s",
  			    optinfo->authrdm,
  			    clientstr(client_conf, &optinfo->clientID));
***************
*** 3523,3535 ****
  
  		/* see if we have a key for the client */
  		if (client_conf == NULL || client_conf->delayedkey == NULL) {
! 			dprintf(LOG_INFO, FNAME, "client %s wanted "
  			    "authentication, but no key found",
  			    clientstr(client_conf, &optinfo->clientID));
  			break;
  		}
  		key = client_conf->delayedkey;
! 		dprintf(LOG_DEBUG, FNAME, "found key %s for client %s",
  		    key->name, clientstr(client_conf, &optinfo->clientID));
  
  		if (msgtype == DH6_SOLICIT) {
--- 3523,3535 ----
  
  		/* see if we have a key for the client */
  		if (client_conf == NULL || client_conf->delayedkey == NULL) {
! 			debug_printf(LOG_INFO, FNAME, "client %s wanted "
  			    "authentication, but no key found",
  			    clientstr(client_conf, &optinfo->clientID));
  			break;
  		}
  		key = client_conf->delayedkey;
! 		debug_printf(LOG_DEBUG, FNAME, "found key %s for client %s",
  		    key->name, clientstr(client_conf, &optinfo->clientID));
  
  		if (msgtype == DH6_SOLICIT) {
***************
*** 3538,3544 ****
  				 * A solicit message should not contain
  				 * authentication information.
  				 */
! 				dprintf(LOG_INFO, FNAME,
  				    "authentication information "
  				    "provided in solicit from %s",
  				    clientstr(client_conf,
--- 3538,3544 ----
  				 * A solicit message should not contain
  				 * authentication information.
  				 */
! 				debug_printf(LOG_INFO, FNAME,
  				    "authentication information "
  				    "provided in solicit from %s",
  				    clientstr(client_conf,
***************
*** 3548,3554 ****
  		} else {
  			/* replay protection */
  			if (!client_conf->saw_previous_rd) {
! 				dprintf(LOG_WARNING, FNAME,
  				    "previous RD value for %s is unknown "
  				    "(accept it)", clientstr(client_conf,
  				    &optinfo->clientID));
--- 3548,3554 ----
  		} else {
  			/* replay protection */
  			if (!client_conf->saw_previous_rd) {
! 				debug_printf(LOG_WARNING, FNAME,
  				    "previous RD value for %s is unknown "
  				    "(accept it)", clientstr(client_conf,
  				    &optinfo->clientID));
***************
*** 3556,3562 ****
  				if (dhcp6_auth_replaycheck(optinfo->authrdm,
  				    client_conf->previous_rd,
  				    optinfo->authrd)) {
! 					dprintf(LOG_INFO, FNAME,
  					    "possible replay attack detected "
  					    "for client %s",
  					    clientstr(client_conf,
--- 3556,3562 ----
  				if (dhcp6_auth_replaycheck(optinfo->authrdm,
  				    client_conf->previous_rd,
  				    optinfo->authrd)) {
! 					debug_printf(LOG_INFO, FNAME,
  					    "possible replay attack detected "
  					    "for client %s",
  					    clientstr(client_conf,
***************
*** 3566,3572 ****
  			}
  
  			if ((optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
! 				dprintf(LOG_INFO, FNAME,
  				    "client %s did not provide authentication "
  				    "information in %s",
  				    clientstr(client_conf, &optinfo->clientID),
--- 3566,3572 ----
  			}
  
  			if ((optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "client %s did not provide authentication "
  				    "information in %s",
  				    clientstr(client_conf, &optinfo->clientID),
***************
*** 3586,3592 ****
  			    optinfo->delayedauth_realmlen != key->realmlen ||
  			    memcmp(optinfo->delayedauth_realmval, key->realm,
  			    key->realmlen) != 0) {
! 				dprintf(LOG_INFO, FNAME, "authentication key "
  				    "mismatch with client %s",
  				    clientstr(client_conf,
  				    &optinfo->clientID));
--- 3586,3592 ----
  			    optinfo->delayedauth_realmlen != key->realmlen ||
  			    memcmp(optinfo->delayedauth_realmval, key->realm,
  			    key->realmlen) != 0) {
! 				debug_printf(LOG_INFO, FNAME, "authentication key "
  				    "mismatch with client %s",
  				    clientstr(client_conf,
  				    &optinfo->clientID));
***************
*** 3595,3601 ****
  
  			/* check for the key lifetime */
  			if (dhcp6_validate_key(key)) {
! 				dprintf(LOG_INFO, FNAME, "key %s has expired",
  				    key->name);
  				break;
  			}
--- 3595,3601 ----
  
  			/* check for the key lifetime */
  			if (dhcp6_validate_key(key)) {
! 				debug_printf(LOG_INFO, FNAME, "key %s has expired",
  				    key->name);
  				break;
  			}
***************
*** 3605,3616 ****
  			    optinfo->authproto, optinfo->authalgorithm,
  			    optinfo->delayedauth_offset + sizeof(*dh6), key)
  			    == 0) {
! 				dprintf(LOG_DEBUG, FNAME,
  				    "message authentication validated for "
  				    "client %s", clientstr(client_conf,
  				    &optinfo->clientID));
  			} else {
! 				dprintf(LOG_INFO, FNAME, "invalid message "
  				    "authentication");
  				break;
  			}
--- 3605,3616 ----
  			    optinfo->authproto, optinfo->authalgorithm,
  			    optinfo->delayedauth_offset + sizeof(*dh6), key)
  			    == 0) {
! 				debug_printf(LOG_DEBUG, FNAME,
  				    "message authentication validated for "
  				    "client %s", clientstr(client_conf,
  				    &optinfo->clientID));
  			} else {
! 				debug_printf(LOG_INFO, FNAME, "invalid message "
  				    "authentication");
  				break;
  			}
***************
*** 3622,3628 ****
  
  		if (get_rdvalue(roptinfo->authrdm, &roptinfo->authrd,
  		    sizeof(roptinfo->authrd))) {
! 			dprintf(LOG_ERR, FNAME, "failed to get a replay "
  			    "detection value for %s",
  			    clientstr(client_conf, &optinfo->clientID));
  			break;	/* XXX: try to recover? */
--- 3622,3628 ----
  
  		if (get_rdvalue(roptinfo->authrdm, &roptinfo->authrd,
  		    sizeof(roptinfo->authrd))) {
! 			debug_printf(LOG_ERR, FNAME, "failed to get a replay "
  			    "detection value for %s",
  			    clientstr(client_conf, &optinfo->clientID));
  			break;	/* XXX: try to recover? */
***************
*** 3633,3639 ****
  		roptinfo->delayedauth_realmval =
  		    malloc(roptinfo->delayedauth_realmlen);
  		if (roptinfo->delayedauth_realmval == NULL) {
! 			dprintf(LOG_ERR, FNAME, "failed to allocate memory "
  			    "for authentication realm for %s",
  			    clientstr(client_conf, &optinfo->clientID));
  			break;
--- 3633,3639 ----
  		roptinfo->delayedauth_realmval =
  		    malloc(roptinfo->delayedauth_realmlen);
  		if (roptinfo->delayedauth_realmval == NULL) {
! 			debug_printf(LOG_ERR, FNAME, "failed to allocate memory "
  			    "for authentication realm for %s",
  			    clientstr(client_conf, &optinfo->clientID));
  			break;
***************
*** 3645,3651 ****
  
  		break;
  	default:
! 		dprintf(LOG_INFO, FNAME, "client %s wanted authentication "
  		    "with unsupported protocol (%d)",
  		    clientstr(client_conf, &optinfo->clientID),
  		    optinfo->authproto);
--- 3645,3651 ----
  
  		break;
  	default:
! 		debug_printf(LOG_INFO, FNAME, "client %s wanted authentication "
  		    "with unsupported protocol (%d)",
  		    clientstr(client_conf, &optinfo->clientID),
  		    optinfo->authproto);
diff -crB wide-dhcpv6-20080615/if.c wide-dhcpv6-20080615-ltrx/if.c
*** wide-dhcpv6-20080615/if.c	2008-06-15 13:18:43.000000000 +0530
--- wide-dhcpv6-20080615-ltrx/if.c	2015-04-22 16:17:46.388967234 +0530
***************
*** 60,71 ****
  	struct dhcp6_if *ifp;
  
  	if ((ifp = find_ifconfbyname(ifname)) != NULL) {
! 		dprintf(LOG_NOTICE, FNAME, "duplicated interface: %s", ifname);
  		return (NULL);
  	}
  
  	if ((ifp = malloc(sizeof(*ifp))) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "malloc failed");
  		goto fail;
  	}
  	memset(ifp, 0, sizeof(*ifp));
--- 60,71 ----
  	struct dhcp6_if *ifp;
  
  	if ((ifp = find_ifconfbyname(ifname)) != NULL) {
! 		debug_printf(LOG_NOTICE, FNAME, "duplicated interface: %s", ifname);
  		return (NULL);
  	}
  
  	if ((ifp = malloc(sizeof(*ifp))) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "malloc failed");
  		goto fail;
  	}
  	memset(ifp, 0, sizeof(*ifp));
***************
*** 73,79 ****
  	TAILQ_INIT(&ifp->event_list);
  
  	if ((ifp->ifname = strdup(ifname)) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "failed to copy ifname");
  		goto fail;
  	}
  
--- 73,79 ----
  	TAILQ_INIT(&ifp->event_list);
  
  	if ((ifp->ifname = strdup(ifname)) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "failed to copy ifname");
  		goto fail;
  	}
  
***************
*** 92,98 ****
  		struct sockaddr_in6 *sin6;
  
  		if (getifaddrs(&ifap) < 0) {
! 			dprintf(LOG_ERR, FNAME, "getifaddrs failed: %s",
  			    strerror(errno));
  			goto fail;
  		}
--- 92,98 ----
  		struct sockaddr_in6 *sin6;
  
  		if (getifaddrs(&ifap) < 0) {
! 			debug_printf(LOG_ERR, FNAME, "getifaddrs failed: %s",
  			    strerror(errno));
  			goto fail;
  		}
***************
*** 134,147 ****
  	u_int32_t linkid;
  
  	if ((ifid = if_nametoindex(ifp->ifname)) == 0) {
! 		dprintf(LOG_ERR, FNAME, "invalid interface(%s): %s",
  			ifp->ifname, strerror(errno));
  		return (-1);
  	}
  
  #ifdef HAVE_SCOPELIB
  	if (inet_zoneid(AF_INET6, 2, ifname, &linkid)) {
! 		dprintf(LOG_ERR, FNAME, "failed to get link ID for %s",
  		    ifname);
  		return (-1);
  	}
--- 134,147 ----
  	u_int32_t linkid;
  
  	if ((ifid = if_nametoindex(ifp->ifname)) == 0) {
! 		debug_printf(LOG_ERR, FNAME, "invalid interface(%s): %s",
  			ifp->ifname, strerror(errno));
  		return (-1);
  	}
  
  #ifdef HAVE_SCOPELIB
  	if (inet_zoneid(AF_INET6, 2, ifname, &linkid)) {
! 		debug_printf(LOG_ERR, FNAME, "failed to get link ID for %s",
  		    ifname);
  		return (-1);
  	}
diff -crB wide-dhcpv6-20080615/lease.c wide-dhcpv6-20080615-ltrx/lease.c
*** wide-dhcpv6-20080615/lease.c	2008-06-15 13:18:43.000000000 +0530
--- wide-dhcpv6-20080615-ltrx/lease.c	2015-04-22 16:17:46.320966751 +0530
***************
*** 93,99 ****
  int
  lease_init(void)
  {
! 	dprintf(LOG_DEBUG, FNAME, "called");
  
  	if (hash_table_init(&dhcp6_lease_table, DHCP6_LEASE_TABLE_SIZE,
  		in6_addr_hash, in6_addr_match) != 0) {
--- 93,99 ----
  int
  lease_init(void)
  {
! 	debug_printf(LOG_DEBUG, FNAME, "called");
  
  	if (hash_table_init(&dhcp6_lease_table, DHCP6_LEASE_TABLE_SIZE,
  		in6_addr_hash, in6_addr_match) != 0) {
***************
*** 116,125 ****
  	if (!addr)
  		return (FALSE);
  
! 	dprintf(LOG_DEBUG, FNAME, "addr=%s", in6addr2str(addr, 0));
  
  	if (hash_table_find(&dhcp6_lease_table, addr)) {
! 		dprintf(LOG_WARNING, FNAME, "already leased: %s",
  			in6addr2str(addr, 0));
  		return (FALSE);
  	}
--- 116,125 ----
  	if (!addr)
  		return (FALSE);
  
! 	debug_printf(LOG_DEBUG, FNAME, "addr=%s", in6addr2str(addr, 0));
  
  	if (hash_table_find(&dhcp6_lease_table, addr)) {
! 		debug_printf(LOG_WARNING, FNAME, "already leased: %s",
  			in6addr2str(addr, 0));
  		return (FALSE);
  	}
***************
*** 138,147 ****
  	if (!addr)
  		return;
  
! 	dprintf(LOG_DEBUG, FNAME, "addr=%s", in6addr2str(addr, 0));
  
  	if (hash_table_remove(&dhcp6_lease_table, addr) != 0) {
! 		dprintf(LOG_WARNING, FNAME, "not found: %s", in6addr2str(addr, 0));
  	}
  }
  
--- 138,147 ----
  	if (!addr)
  		return;
  
! 	debug_printf(LOG_DEBUG, FNAME, "addr=%s", in6addr2str(addr, 0));
  
  	if (hash_table_remove(&dhcp6_lease_table, addr) != 0) {
! 		debug_printf(LOG_WARNING, FNAME, "not found: %s", in6addr2str(addr, 0));
  	}
  }
  
***************
*** 154,164 ****
  	if (!addr)
  		return;
  
! 	dprintf(LOG_DEBUG, FNAME, "addr=%s", in6addr2str(addr, 0));
  
  	entry = hash_table_find(&dhcp6_lease_table, addr);
  	if (entry == NULL) {
! 		dprintf(LOG_WARNING, FNAME, "not found: %s",
  			in6addr2str(addr, 0));
  		return;
  	}
--- 154,164 ----
  	if (!addr)
  		return;
  
! 	debug_printf(LOG_DEBUG, FNAME, "addr=%s", in6addr2str(addr, 0));
  
  	entry = hash_table_find(&dhcp6_lease_table, addr);
  	if (entry == NULL) {
! 		debug_printf(LOG_WARNING, FNAME, "not found: %s",
  			in6addr2str(addr, 0));
  		return;
  	}
diff -crB wide-dhcpv6-20080615/prefixconf.c wide-dhcpv6-20080615-ltrx/prefixconf.c
*** wide-dhcpv6-20080615/prefixconf.c	2007-03-21 15:22:55.000000000 +0530
--- wide-dhcpv6-20080615-ltrx/prefixconf.c	2015-04-22 16:17:46.392967262 +0530
***************
*** 141,147 ****
  	if (pinfo->vltime != DHCP6_DURATION_INFINITE &&
  	    (pinfo->pltime == DHCP6_DURATION_INFINITE ||
  	    pinfo->pltime > pinfo->vltime)) {
! 		dprintf(LOG_INFO, FNAME, "invalid prefix %s/%d: "
  		    "pltime (%lu) is larger than vltime (%lu)",
  		    in6addr2str(&pinfo->addr, 0), pinfo->plen,
  		    pinfo->pltime, pinfo->vltime);
--- 141,147 ----
  	if (pinfo->vltime != DHCP6_DURATION_INFINITE &&
  	    (pinfo->pltime == DHCP6_DURATION_INFINITE ||
  	    pinfo->pltime > pinfo->vltime)) {
! 		debug_printf(LOG_INFO, FNAME, "invalid prefix %s/%d: "
  		    "pltime (%lu) is larger than vltime (%lu)",
  		    in6addr2str(&pinfo->addr, 0), pinfo->plen,
  		    pinfo->pltime, pinfo->vltime);
***************
*** 150,156 ****
  
  	if (iac_pd == NULL) {
  		if ((iac_pd = malloc(sizeof(*iac_pd))) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME, "memory allocation failed");
  			return (-1);
  		}
  		memset(iac_pd, 0, sizeof(*iac_pd));
--- 150,156 ----
  
  	if (iac_pd == NULL) {
  		if ((iac_pd = malloc(sizeof(*iac_pd))) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME, "memory allocation failed");
  			return (-1);
  		}
  		memset(iac_pd, 0, sizeof(*iac_pd));
***************
*** 172,178 ****
  	/* search for the given prefix, and make a new one if it fails */
  	if ((sp = find_siteprefix(&iac_pd->siteprefix_head, pinfo, 1)) == NULL) {
  		if ((sp = malloc(sizeof(*sp))) == NULL) {
! 			dprintf(LOG_NOTICE, FNAME, "memory allocation failed");
  			return (-1);
  		}
  		memset(sp, 0, sizeof(*sp));
--- 172,178 ----
  	/* search for the given prefix, and make a new one if it fails */
  	if ((sp = find_siteprefix(&iac_pd->siteprefix_head, pinfo, 1)) == NULL) {
  		if ((sp = malloc(sizeof(*sp))) == NULL) {
! 			debug_printf(LOG_NOTICE, FNAME, "memory allocation failed");
  			return (-1);
  		}
  		memset(sp, 0, sizeof(*sp));
***************
*** 192,198 ****
  	/* update the prefix according to pinfo */
  	sp->prefix.pltime = pinfo->pltime;
  	sp->prefix.vltime = pinfo->vltime;
! 	dprintf(LOG_DEBUG, FNAME, "%s a prefix %s/%d pltime=%lu, vltime=%lu",
  	    spcreate ? "create" : "update",
  	    in6addr2str(&pinfo->addr, 0), pinfo->plen,
  	    pinfo->pltime, pinfo->vltime);
--- 192,198 ----
  	/* update the prefix according to pinfo */
  	sp->prefix.pltime = pinfo->pltime;
  	sp->prefix.vltime = pinfo->vltime;
! 	debug_printf(LOG_DEBUG, FNAME, "%s a prefix %s/%d pltime=%lu, vltime=%lu",
  	    spcreate ? "create" : "update",
  	    in6addr2str(&pinfo->addr, 0), pinfo->plen,
  	    pinfo->pltime, pinfo->vltime);
***************
*** 209,215 ****
  			 * [RFC3633 Section 12.1]
  			 */
  			if (strcmp(pif->ifname, dhcpifp->ifname) == 0) {
! 				dprintf(LOG_INFO, FNAME,
  				    "skip %s as a prefix interface",
  				    dhcpifp->ifname);
  				continue;
--- 209,215 ----
  			 * [RFC3633 Section 12.1]
  			 */
  			if (strcmp(pif->ifname, dhcpifp->ifname) == 0) {
! 				debug_printf(LOG_INFO, FNAME,
  				    "skip %s as a prefix interface",
  				    dhcpifp->ifname);
  				continue;
***************
*** 235,241 ****
  		if (sp->timer == NULL) {
  			sp->timer = dhcp6_add_timer(siteprefix_timo, sp);
  			if (sp->timer == NULL) {
! 				dprintf(LOG_NOTICE, FNAME,
  				    "failed to add prefix timer");
  				remove_siteprefix(sp); /* XXX */
  				return (-1);
--- 235,241 ----
  		if (sp->timer == NULL) {
  			sp->timer = dhcp6_add_timer(siteprefix_timo, sp);
  			if (sp->timer == NULL) {
! 				debug_printf(LOG_NOTICE, FNAME,
  				    "failed to add prefix timer");
  				remove_siteprefix(sp); /* XXX */
  				return (-1);
***************
*** 276,282 ****
  {
  	struct dhcp6_ifprefix *ip;
  
! 	dprintf(LOG_DEBUG, FNAME, "remove a site prefix %s/%d",
  	    in6addr2str(&sp->prefix.addr, 0), sp->prefix.plen);
  
  	if (sp->timer)
--- 276,282 ----
  {
  	struct dhcp6_ifprefix *ip;
  
! 	debug_printf(LOG_DEBUG, FNAME, "remove a site prefix %s/%d",
  	    in6addr2str(&sp->prefix.addr, 0), sp->prefix.plen);
  
  	if (sp->timer)
***************
*** 390,396 ****
  	struct dhcp6_list *ial;
  
  	if (evd->type != DHCP6_EVDATA_IAPD) {
! 		dprintf(LOG_ERR, FNAME, "assumption failure");
  		exit(1);
  	}
  
--- 390,396 ----
  	struct dhcp6_list *ial;
  
  	if (evd->type != DHCP6_EVDATA_IAPD) {
! 		debug_printf(LOG_ERR, FNAME, "assumption failure");
  		exit(1);
  	}
  
***************
*** 409,415 ****
  	struct ia *ia;
  	void (*callback)__P((struct ia *));
  
! 	dprintf(LOG_DEBUG, FNAME, "prefix timeout for %s/%d",
  	    in6addr2str(&sp->prefix.addr, 0), sp->prefix.plen);
  
  	ia = sp->ctl->iacpd_ia;
--- 409,415 ----
  	struct ia *ia;
  	void (*callback)__P((struct ia *));
  
! 	debug_printf(LOG_DEBUG, FNAME, "prefix timeout for %s/%d",
  	    in6addr2str(&sp->prefix.addr, 0), sp->prefix.plen);
  
  	ia = sp->ctl->iacpd_ia;
***************
*** 438,444 ****
  	int b, i;
  
  	if ((ifpfx = malloc(sizeof(*ifpfx))) == NULL) {
! 		dprintf(LOG_NOTICE, FNAME,
  		    "failed to allocate memory for ifprefix");
  		return (-1);
  	}
--- 438,444 ----
  	int b, i;
  
  	if ((ifpfx = malloc(sizeof(*ifpfx))) == NULL) {
! 		debug_printf(LOG_NOTICE, FNAME,
  		    "failed to allocate memory for ifprefix");
  		return (-1);
  	}
***************
*** 456,468 ****
  	 * XXX: our current implementation assumes ifid len is a multiple of 8
  	 */
  	if ((pconf->ifid_len % 8) != 0) {
! 		dprintf(LOG_ERR, FNAME,
  		    "assumption failure on the length of interface ID");
  		goto bad;
  	}
  	if (ifpfx->plen + pconf->ifid_len < 0 ||
  	    ifpfx->plen + pconf->ifid_len > 128) {
! 		dprintf(LOG_INFO, FNAME,
  			"invalid prefix length %d + %d + %d",
  			prefix->plen, pconf->sla_len, pconf->ifid_len);
  		goto bad;
--- 456,468 ----
  	 * XXX: our current implementation assumes ifid len is a multiple of 8
  	 */
  	if ((pconf->ifid_len % 8) != 0) {
! 		debug_printf(LOG_ERR, FNAME,
  		    "assumption failure on the length of interface ID");
  		goto bad;
  	}
  	if (ifpfx->plen + pconf->ifid_len < 0 ||
  	    ifpfx->plen + pconf->ifid_len > 128) {
! 		debug_printf(LOG_INFO, FNAME,
  			"invalid prefix length %d + %d + %d",
  			prefix->plen, pconf->sla_len, pconf->ifid_len);
  		goto bad;
diff -crB wide-dhcpv6-20080615/timer.c wide-dhcpv6-20080615-ltrx/timer.c
*** wide-dhcpv6-20080615/timer.c	2007-03-21 15:22:56.000000000 +0530
--- wide-dhcpv6-20080615-ltrx/timer.c	2015-04-22 16:17:46.312966697 +0530
***************
*** 71,84 ****
  	struct dhcp6_timer *newtimer;
  
  	if ((newtimer = malloc(sizeof(*newtimer))) == NULL) {
! 		dprintf(LOG_ERR, FNAME, "can't allocate memory");
  		return (NULL);
  	}
  
  	memset(newtimer, 0, sizeof(*newtimer));
  
  	if (timeout == NULL) {
! 		dprintf(LOG_ERR, FNAME, "timeout function unspecified");
  		exit(1);
  	}
  	newtimer->expire = timeout;
--- 71,84 ----
  	struct dhcp6_timer *newtimer;
  
  	if ((newtimer = malloc(sizeof(*newtimer))) == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "can't allocate memory");
  		return (NULL);
  	}
  
  	memset(newtimer, 0, sizeof(*newtimer));
  
  	if (timeout == NULL) {
! 		debug_printf(LOG_ERR, FNAME, "timeout function unspecified");
  		exit(1);
  	}
  	newtimer->expire = timeout;
***************
*** 165,171 ****
  
  	gettimeofday(&now, NULL);
  	if (TIMEVAL_LEQ(timer->tm, now)) {
! 		dprintf(LOG_DEBUG, FNAME,
  		    "a timer must be expired, but not yet");
  		returnval.tv_sec = returnval.tv_usec = 0;
  	} else
--- 165,171 ----
  
  	gettimeofday(&now, NULL);
  	if (TIMEVAL_LEQ(timer->tm, now)) {
! 		debug_printf(LOG_DEBUG, FNAME,
  		    "a timer must be expired, but not yet");
  		returnval.tv_sec = returnval.tv_usec = 0;
  	} else
