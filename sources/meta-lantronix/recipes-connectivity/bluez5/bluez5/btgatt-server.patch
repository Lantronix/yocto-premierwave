diff -ruN --new-file bluez_utils-5.43/attrib/ltrx_gatttool.c bluez_utils-5.43_mod_2/attrib/ltrx_gatttool.c
--- bluez_utils-5.43/attrib/ltrx_gatttool.c	1970-01-01 05:30:00.000000000 +0530
+++ bluez_utils-5.43_mod_2/attrib/ltrx_gatttool.c	2019-08-29 14:39:32.282566356 +0530
@@ -0,0 +1,622 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2010  Nokia Corporation
+ *  Copyright (C) 2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include <glib.h>
+
+#include "lib/bluetooth.h"
+#include "lib/hci.h"
+#include "lib/hci_lib.h"
+#include "lib/sdp.h"
+#include "lib/uuid.h"
+
+#include "src/shared/util.h"
+#include "att.h"
+#include "btio/btio.h"
+#include "gattrib.h"
+#include "gatt.h"
+#include "gatttool.h"
+
+static char *opt_src = NULL;
+static char *opt_dst = NULL;
+static char *opt_dst_type = NULL;
+static char *opt_value = NULL;
+static char *opt_sec_level = NULL;
+static bt_uuid_t *opt_uuid = NULL;
+static int opt_start = 0x0001;
+static int opt_end = 0xffff;
+static int opt_handle = -1;
+static int opt_mtu = 0;
+static int opt_psm = 0;
+static gboolean opt_primary = FALSE;
+static gboolean opt_characteristics = FALSE;
+static gboolean opt_char_read = FALSE;
+static gboolean opt_listen = FALSE;
+static gboolean opt_char_desc = FALSE;
+static gboolean opt_char_write = FALSE;
+static gboolean opt_char_write_req = FALSE;
+static gboolean opt_interactive = FALSE;
+static GMainLoop *event_loop;
+static gboolean got_error = FALSE;
+static GSourceFunc operation;
+
+struct characteristic_data {
+	GAttrib *attrib;
+	uint16_t start;
+	uint16_t end;
+};
+
+static void events_handler(const uint8_t *pdu, uint16_t len, gpointer user_data)
+{
+	GAttrib *attrib = user_data;
+	uint8_t *opdu;
+	uint16_t handle, i, olen = 0;
+	size_t plen;
+
+	handle = get_le16(&pdu[1]);
+
+	switch (pdu[0]) {
+	case ATT_OP_HANDLE_NOTIFY:
+		g_print("Notification handle = 0x%04x value: ", handle);
+		break;
+	case ATT_OP_HANDLE_IND:
+		g_print("Indication   handle = 0x%04x value: ", handle);
+		break;
+	default:
+		g_print("Invalid opcode\n");
+		return;
+	}
+
+	for (i = 3; i < len; i++)
+		g_print("%02x ", pdu[i]);
+
+	g_print("\n");
+
+	if (pdu[0] == ATT_OP_HANDLE_NOTIFY)
+		return;
+
+	opdu = g_attrib_get_buffer(attrib, &plen);
+	olen = enc_confirmation(opdu, plen);
+
+	if (olen > 0)
+		g_attrib_send(attrib, 0, opdu, olen, NULL, NULL, NULL);
+}
+
+static gboolean listen_start(gpointer user_data)
+{
+	GAttrib *attrib = user_data;
+
+	g_attrib_register(attrib, ATT_OP_HANDLE_NOTIFY, GATTRIB_ALL_HANDLES,
+						events_handler, attrib, NULL);
+	g_attrib_register(attrib, ATT_OP_HANDLE_IND, GATTRIB_ALL_HANDLES,
+						events_handler, attrib, NULL);
+
+	return FALSE;
+}
+
+static void connect_cb(GIOChannel *io, GError *err, gpointer user_data)
+{
+	GAttrib *attrib;
+	uint16_t mtu;
+	uint16_t cid;
+	GError *gerr = NULL;
+	if (err) {
+		g_printerr("%s\n", err->message);
+		got_error = TRUE;
+		g_main_loop_quit(event_loop);
+	}
+
+	bt_io_get(io, &gerr, BT_IO_OPT_IMTU, &mtu,
+				BT_IO_OPT_CID, &cid, BT_IO_OPT_INVALID);
+
+	if (gerr) {
+		g_printerr("Can't detect MTU, using default: %s",
+								gerr->message);
+		g_error_free(gerr);
+		mtu = ATT_DEFAULT_LE_MTU;
+	}
+
+	if (cid == ATT_CID)
+		mtu = ATT_DEFAULT_LE_MTU;
+
+	attrib = g_attrib_new(io, mtu, false);
+
+	if (opt_listen)
+		g_idle_add(listen_start, attrib);
+	operation(attrib);
+}
+
+static void primary_all_cb(uint8_t status, GSList *services, void *user_data)
+{
+	GSList *l;
+
+	if (status) {
+		g_printerr("Discover all primary services failed: %s\n",
+							att_ecode2str(status));
+		goto done;
+	}
+
+	for (l = services; l; l = l->next) {
+		struct gatt_primary *prim = l->data;
+		g_print("attr handle = 0x%04x, end grp handle = 0x%04x "
+			"uuid: %s\n", prim->range.start, prim->range.end, prim->uuid);
+	}
+
+done:
+	g_main_loop_quit(event_loop);
+}
+
+static void primary_by_uuid_cb(uint8_t status, GSList *ranges, void *user_data)
+{
+	GSList *l;
+
+	if (status != 0) {
+		g_printerr("Discover primary services by UUID failed: %s\n",
+							att_ecode2str(status));
+		goto done;
+	}
+
+	for (l = ranges; l; l = l->next) {
+		struct att_range *range = l->data;
+		g_print("Starting handle: %04x Ending handle: %04x\n",
+						range->start, range->end);
+	}
+
+done:
+	g_main_loop_quit(event_loop);
+}
+
+static gboolean primary(gpointer user_data)
+{
+	GAttrib *attrib = user_data;
+
+	if (opt_uuid)
+		gatt_discover_primary(attrib, opt_uuid, primary_by_uuid_cb,
+									NULL);
+	else
+		gatt_discover_primary(attrib, NULL, primary_all_cb, NULL);
+
+	return FALSE;
+}
+
+static void char_discovered_cb(uint8_t status, GSList *characteristics,
+								void *user_data)
+{
+	GSList *l;
+
+	if (status) {
+		g_printerr("Discover all characteristics failed: %s\n",
+							att_ecode2str(status));
+		goto done;
+	}
+
+	for (l = characteristics; l; l = l->next) {
+		struct gatt_char *chars = l->data;
+
+		g_print("handle = 0x%04x, char properties = 0x%02x, char value "
+			"handle = 0x%04x, uuid = %s\n", chars->handle,
+			chars->properties, chars->value_handle, chars->uuid);
+	}
+
+done:
+	g_main_loop_quit(event_loop);
+}
+
+static gboolean characteristics(gpointer user_data)
+{
+	GAttrib *attrib = user_data;
+
+	gatt_discover_char(attrib, opt_start, opt_end, opt_uuid,
+						char_discovered_cb, NULL);
+
+	return FALSE;
+}
+
+static void char_read_cb(guint8 status, const guint8 *pdu, guint16 plen,
+							gpointer user_data)
+{
+	uint8_t value[plen];
+	ssize_t vlen;
+	int i;
+
+	if (status != 0) {
+		g_printerr("Characteristic value/descriptor read failed: %s\n",
+							att_ecode2str(status));
+		goto done;
+	}
+
+	vlen = dec_read_resp(pdu, plen, value, sizeof(value));
+	if (vlen < 0) {
+		g_printerr("Protocol error\n");
+		goto done;
+	}
+	g_print("Characteristic value/descriptor: ");
+	for (i = 0; i < vlen; i++)
+		g_print("%02x ", value[i]);
+	g_print("\n");
+
+done:
+	if (!opt_listen)
+		g_main_loop_quit(event_loop);
+}
+
+static void char_read_by_uuid_cb(guint8 status, const guint8 *pdu,
+					guint16 plen, gpointer user_data)
+{
+	struct att_data_list *list;
+	int i;
+
+	if (status != 0) {
+		g_printerr("Read characteristics by UUID failed: %s\n",
+							att_ecode2str(status));
+		goto done;
+	}
+
+	list = dec_read_by_type_resp(pdu, plen);
+	if (list == NULL)
+		goto done;
+
+	for (i = 0; i < list->num; i++) {
+		uint8_t *value = list->data[i];
+		int j;
+
+		g_print("handle: 0x%04x \t value: ", get_le16(value));
+		value += 2;
+		for (j = 0; j < list->len - 2; j++, value++)
+			g_print("%02x ", *value);
+		g_print("\n");
+	}
+
+	att_data_list_free(list);
+
+done:
+	g_main_loop_quit(event_loop);
+}
+
+static gboolean characteristics_read(gpointer user_data)
+{
+	GAttrib *attrib = user_data;
+
+	if (opt_uuid != NULL) {
+
+		gatt_read_char_by_uuid(attrib, opt_start, opt_end, opt_uuid,
+						char_read_by_uuid_cb, NULL);
+
+		return FALSE;
+	}
+
+	if (opt_handle <= 0) {
+		g_printerr("A valid handle is required\n");
+		g_main_loop_quit(event_loop);
+		return FALSE;
+	}
+
+	gatt_read_char(attrib, opt_handle, char_read_cb, attrib);
+
+	return FALSE;
+}
+
+static void mainloop_quit(gpointer user_data)
+{
+	uint8_t *value = user_data;
+
+	g_free(value);
+	g_main_loop_quit(event_loop);
+}
+
+static gboolean characteristics_write(gpointer user_data)
+{
+	GAttrib *attrib = user_data;
+	uint8_t *value;
+	size_t len;
+
+	if (opt_handle <= 0) {
+		g_printerr("A valid handle is required\n");
+		goto error;
+	}
+
+	if (opt_value == NULL || opt_value[0] == '\0') {
+		g_printerr("A value is required\n");
+		goto error;
+	}
+
+	len = gatt_attr_data_from_string(opt_value, &value);
+	if (len == 0) {
+		g_printerr("Invalid value\n");
+		goto error;
+	}
+
+	gatt_write_cmd(attrib, opt_handle, value, len, mainloop_quit, value);
+
+	g_free(value);
+	return FALSE;
+
+error:
+	g_main_loop_quit(event_loop);
+	return FALSE;
+}
+
+static void char_write_req_cb(guint8 status, const guint8 *pdu, guint16 plen,
+							gpointer user_data)
+{
+	if (status != 0) {
+		g_printerr("Characteristic Write Request failed: "
+						"%s\n", att_ecode2str(status));
+		goto done;
+	}
+
+	if (!dec_write_resp(pdu, plen) && !dec_exec_write_resp(pdu, plen)) {
+		g_printerr("Protocol error\n");
+		goto done;
+	}
+
+	g_print("Characteristic value was written successfully\n");
+
+done:
+	if (!opt_listen)
+		g_main_loop_quit(event_loop);
+}
+
+static gboolean characteristics_write_req(gpointer user_data)
+{
+	GAttrib *attrib = user_data;
+	uint8_t *value;
+	size_t len;
+
+	if (opt_handle <= 0) {
+		g_printerr("A valid handle is required\n");
+		goto error;
+	}
+
+	if (opt_value == NULL || opt_value[0] == '\0') {
+		g_printerr("A value is required\n");
+		goto error;
+	}
+
+	len = gatt_attr_data_from_string(opt_value, &value);
+	if (len == 0) {
+		g_printerr("Invalid value\n");
+		goto error;
+	}
+
+	gatt_write_char(attrib, opt_handle, value, len, char_write_req_cb,
+									NULL);
+
+	g_free(value);
+	return FALSE;
+
+error:
+	g_main_loop_quit(event_loop);
+	return FALSE;
+}
+
+static void char_desc_cb(uint8_t status, GSList *descriptors, void *user_data)
+{
+	GSList *l;
+
+	if (status) {
+		g_printerr("Discover descriptors failed: %s\n",
+							att_ecode2str(status));
+		return;
+	}
+
+	for (l = descriptors; l; l = l->next) {
+		struct gatt_desc *desc = l->data;
+
+		g_print("handle = 0x%04x, uuid = %s\n", desc->handle,
+								desc->uuid);
+	}
+
+	if (!opt_listen)
+		g_main_loop_quit(event_loop);
+}
+
+static gboolean characteristics_desc(gpointer user_data)
+{
+	GAttrib *attrib = user_data;
+
+	gatt_discover_desc(attrib, opt_start, opt_end, NULL, char_desc_cb,
+									NULL);
+
+	return FALSE;
+}
+
+static gboolean parse_uuid(const char *key, const char *value,
+				gpointer user_data, GError **error)
+{
+	if (!value)
+		return FALSE;
+
+	opt_uuid = g_try_malloc(sizeof(bt_uuid_t));
+	if (opt_uuid == NULL)
+		return FALSE;
+
+	if (bt_string_to_uuid(opt_uuid, value) < 0)
+		return FALSE;
+
+	return TRUE;
+}
+
+static GOptionEntry primary_char_options[] = {
+	{ "start", 's' , 0, G_OPTION_ARG_INT, &opt_start,
+		"Starting handle(optional)", "0x0001" },
+	{ "end", 'e' , 0, G_OPTION_ARG_INT, &opt_end,
+		"Ending handle(optional)", "0xffff" },
+	{ "uuid", 'u', G_OPTION_FLAG_OPTIONAL_ARG, G_OPTION_ARG_CALLBACK,
+		parse_uuid, "UUID16 or UUID128(optional)", "0x1801"},
+	{ NULL },
+};
+
+static GOptionEntry char_rw_options[] = {
+	{ "handle", 'a' , 0, G_OPTION_ARG_INT, &opt_handle,
+		"Read/Write characteristic by handle(required)", "0x0001" },
+	{ "value", 'n' , 0, G_OPTION_ARG_STRING, &opt_value,
+		"Write characteristic value (required for write operation)",
+		"0x0001" },
+	{NULL},
+};
+
+static GOptionEntry gatt_options[] = {
+	{ "primary", 0, 0, G_OPTION_ARG_NONE, &opt_primary,
+		"Primary Service Discovery", NULL },
+	{ "characteristics", 0, 0, G_OPTION_ARG_NONE, &opt_characteristics,
+		"Characteristics Discovery", NULL },
+	{ "char-read", 0, 0, G_OPTION_ARG_NONE, &opt_char_read,
+		"Characteristics Value/Descriptor Read", NULL },
+	{ "char-write", 0, 0, G_OPTION_ARG_NONE, &opt_char_write,
+		"Characteristics Value Write Without Response (Write Command)",
+		NULL },
+	{ "char-write-req", 0, 0, G_OPTION_ARG_NONE, &opt_char_write_req,
+		"Characteristics Value Write (Write Request)", NULL },
+	{ "char-desc", 0, 0, G_OPTION_ARG_NONE, &opt_char_desc,
+		"Characteristics Descriptor Discovery", NULL },
+	{ "listen", 0, 0, G_OPTION_ARG_NONE, &opt_listen,
+		"Listen for notifications and indications", NULL },
+	{ "interactive", 'I', G_OPTION_FLAG_IN_MAIN, G_OPTION_ARG_NONE,
+		&opt_interactive, "Use interactive mode", NULL },
+	{ NULL },
+};
+
+static GOptionEntry options[] = {
+	{ "adapter", 'i', 0, G_OPTION_ARG_STRING, &opt_src,
+		"Specify local adapter interface", "hciX" },
+	{ "device", 'b', 0, G_OPTION_ARG_STRING, &opt_dst,
+		"Specify remote Bluetooth address", "MAC" },
+	{ "addr-type", 't', 0, G_OPTION_ARG_STRING, &opt_dst_type,
+		"Set LE address type. Default: public", "[public | random]"},
+	{ "mtu", 'm', 0, G_OPTION_ARG_INT, &opt_mtu,
+		"Specify the MTU size", "MTU" },
+	{ "psm", 'p', 0, G_OPTION_ARG_INT, &opt_psm,
+		"Specify the PSM for GATT/ATT over BR/EDR", "PSM" },
+	{ "sec-level", 'l', 0, G_OPTION_ARG_STRING, &opt_sec_level,
+		"Set security level. Default: low", "[low | medium | high]"},
+	{ NULL },
+};
+
+int main(int argc, char *argv[])
+{
+	GOptionContext *context;
+	GOptionGroup *gatt_group, *params_group, *char_rw_group;
+	GError *gerr = NULL;
+	GIOChannel *chan;
+
+	opt_dst_type = g_strdup("public");
+	opt_sec_level = g_strdup("low");
+
+	context = g_option_context_new(NULL);
+	g_option_context_add_main_entries(context, options, NULL);
+
+	/* GATT commands */
+	gatt_group = g_option_group_new("gatt", "GATT commands",
+					"Show all GATT commands", NULL, NULL);
+	g_option_context_add_group(context, gatt_group);
+	g_option_group_add_entries(gatt_group, gatt_options);
+
+	/* Primary Services and Characteristics arguments */
+	params_group = g_option_group_new("params",
+			"Primary Services/Characteristics arguments",
+			"Show all Primary Services/Characteristics arguments",
+			NULL, NULL);
+	g_option_context_add_group(context, params_group);
+	g_option_group_add_entries(params_group, primary_char_options);
+
+	/* Characteristics value/descriptor read/write arguments */
+	char_rw_group = g_option_group_new("char-read-write",
+		"Characteristics Value/Descriptor Read/Write arguments",
+		"Show all Characteristics Value/Descriptor Read/Write "
+		"arguments",
+		NULL, NULL);
+	g_option_context_add_group(context, char_rw_group);
+	g_option_group_add_entries(char_rw_group, char_rw_options);
+
+	if (!g_option_context_parse(context, &argc, &argv, &gerr)) {
+		g_printerr("%s\n", gerr->message);
+		g_clear_error(&gerr);
+	}
+
+	if (opt_interactive) {
+		interactive(opt_src, opt_dst, opt_dst_type, opt_psm);
+		goto done;
+	}
+
+	if (opt_primary)
+		operation = primary;
+	else if (opt_characteristics)
+		operation = characteristics;
+	else if (opt_char_read)
+		operation = characteristics_read;
+	else if (opt_char_write)
+		operation = characteristics_write;
+	else if (opt_char_write_req)
+		operation = characteristics_write_req;
+	else if (opt_char_desc)
+		operation = characteristics_desc;
+	else {
+		char *help = g_option_context_get_help(context, TRUE, NULL);
+		g_print("%s\n", help);
+		g_free(help);
+		got_error = TRUE;
+		goto done;
+	}
+
+	if (opt_dst == NULL) {
+		g_print("Remote Bluetooth address required\n");
+		got_error = TRUE;
+		goto done;
+	}
+
+	chan = gatt_connect(opt_src, opt_dst, opt_dst_type, opt_sec_level,
+					opt_psm, opt_mtu, connect_cb, &gerr);
+	if (chan == NULL) {
+		g_printerr("%s\n", gerr->message);
+		g_clear_error(&gerr);
+		got_error = TRUE;
+		goto done;
+	}
+
+	event_loop = g_main_loop_new(NULL, FALSE);
+
+	g_main_loop_run(event_loop);
+
+	g_main_loop_unref(event_loop);
+
+done:
+	g_option_context_free(context);
+	g_free(opt_src);
+	g_free(opt_dst);
+	g_free(opt_uuid);
+	g_free(opt_sec_level);
+
+	if (got_error)
+		exit(EXIT_FAILURE);
+	else
+		exit(EXIT_SUCCESS);
+}
diff -ruN --new-file bluez_utils-5.43/attrib/ltrx_interactive.c bluez_utils-5.43_mod_2/attrib/ltrx_interactive.c
--- bluez_utils-5.43/attrib/ltrx_interactive.c	1970-01-01 05:30:00.000000000 +0530
+++ bluez_utils-5.43_mod_2/attrib/ltrx_interactive.c	2019-08-29 14:39:32.282566356 +0530
@@ -0,0 +1,1057 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2011  Nokia Corporation
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/signalfd.h>
+#include <glib.h>
+
+#include <readline/readline.h>
+#include <readline/history.h>
+
+#include "lib/bluetooth.h"
+#include "lib/sdp.h"
+#include "lib/uuid.h"
+
+#include "src/shared/util.h"
+#include "btio/btio.h"
+#include "att.h"
+#include "gattrib.h"
+#include "gatt.h"
+#include "gatttool.h"
+#include "client/display.h"
+
+static GIOChannel *iochannel = NULL;
+static GAttrib *attrib = NULL;
+static GMainLoop *event_loop;
+static GString *prompt;
+
+static char *opt_src = NULL;
+static char *opt_dst = NULL;
+static char *opt_dst_type = NULL;
+static char *opt_sec_level = NULL;
+static int opt_psm = 0;
+static int opt_mtu = 0;
+static int start;
+static int end;
+
+static void cmd_help(int argcp, char **argvp);
+
+static enum state {
+	STATE_DISCONNECTED,
+	STATE_CONNECTING,
+	STATE_CONNECTED
+} conn_state;
+
+#define error(fmt, arg...) \
+	rl_printf(COLOR_RED "Error: " COLOR_OFF fmt, ## arg)
+
+#define failed(fmt, arg...) \
+	rl_printf(COLOR_RED "Command Failed: " COLOR_OFF fmt, ## arg)
+
+static char *get_prompt(void)
+{
+	if (conn_state == STATE_CONNECTED)
+		g_string_assign(prompt, COLOR_BLUE);
+	else
+		g_string_assign(prompt, "");
+
+	if (opt_dst)
+		g_string_append_printf(prompt, "[%17s]", opt_dst);
+	else
+		g_string_append_printf(prompt, "[%17s]", "");
+
+	if (conn_state == STATE_CONNECTED)
+		g_string_append(prompt, COLOR_OFF);
+
+	if (opt_psm)
+		g_string_append(prompt, "[BR]");
+	else
+		g_string_append(prompt, "[LE]");
+
+	g_string_append(prompt, "> ");
+
+	return prompt->str;
+}
+
+
+static void set_state(enum state st)
+{
+	conn_state = st;
+	rl_set_prompt(get_prompt());
+}
+
+static void events_handler(const uint8_t *pdu, uint16_t len, gpointer user_data)
+{
+	uint8_t *opdu;
+	uint16_t handle, i, olen;
+	size_t plen;
+	GString *s;
+
+	handle = get_le16(&pdu[1]);
+
+	switch (pdu[0]) {
+	case ATT_OP_HANDLE_NOTIFY:
+		s = g_string_new(NULL);
+		g_string_printf(s, "Notification handle = 0x%04x value: ",
+									handle);
+		break;
+	case ATT_OP_HANDLE_IND:
+		s = g_string_new(NULL);
+		g_string_printf(s, "Indication   handle = 0x%04x value: ",
+									handle);
+		break;
+	default:
+		error("Invalid opcode\n");
+		return;
+	}
+
+	for (i = 3; i < len; i++)
+		g_string_append_printf(s, "%02x ", pdu[i]);
+
+	rl_printf("%s\n", s->str);
+	g_string_free(s, TRUE);
+
+	if (pdu[0] == ATT_OP_HANDLE_NOTIFY)
+		return;
+
+	opdu = g_attrib_get_buffer(attrib, &plen);
+	olen = enc_confirmation(opdu, plen);
+
+	if (olen > 0)
+		g_attrib_send(attrib, 0, opdu, olen, NULL, NULL, NULL);
+}
+
+static void connect_cb(GIOChannel *io, GError *err, gpointer user_data)
+{
+	uint16_t mtu;
+	uint16_t cid;
+
+	if (err) {
+		set_state(STATE_DISCONNECTED);
+		error("%s\n", err->message);
+		return;
+	}
+
+	bt_io_get(io, &err, BT_IO_OPT_IMTU, &mtu,
+				BT_IO_OPT_CID, &cid, BT_IO_OPT_INVALID);
+
+	if (err) {
+		g_printerr("Can't detect MTU, using default: %s", err->message);
+		g_error_free(err);
+		mtu = ATT_DEFAULT_LE_MTU;
+	}
+
+	if (cid == ATT_CID)
+		mtu = ATT_DEFAULT_LE_MTU;
+
+	attrib = g_attrib_new(iochannel, mtu, false);
+	g_attrib_register(attrib, ATT_OP_HANDLE_NOTIFY, GATTRIB_ALL_HANDLES,
+						events_handler, attrib, NULL);
+	g_attrib_register(attrib, ATT_OP_HANDLE_IND, GATTRIB_ALL_HANDLES,
+						events_handler, attrib, NULL);
+	set_state(STATE_CONNECTED);
+        system("hciconfig hci0 noscan");
+	rl_printf("Connection successful\n");
+}
+
+static void disconnect_io()
+{
+	if (conn_state == STATE_DISCONNECTED)
+		return;
+
+	g_attrib_unref(attrib);
+	attrib = NULL;
+	opt_mtu = 0;
+
+	g_io_channel_shutdown(iochannel, FALSE, NULL);
+	g_io_channel_unref(iochannel);
+	iochannel = NULL;
+
+	set_state(STATE_DISCONNECTED);
+}
+
+static void primary_all_cb(uint8_t status, GSList *services, void *user_data)
+{
+	GSList *l;
+
+	if (status) {
+		error("Discover all primary services failed: %s\n",
+						att_ecode2str(status));
+		return;
+	}
+
+	if (services == NULL) {
+		error("No primary service found\n");
+		return;
+	}
+
+	for (l = services; l; l = l->next) {
+		struct gatt_primary *prim = l->data;
+		rl_printf("attr handle: 0x%04x, end grp handle: 0x%04x uuid: %s\n",
+				prim->range.start, prim->range.end, prim->uuid);
+	}
+}
+
+static void primary_by_uuid_cb(uint8_t status, GSList *ranges, void *user_data)
+{
+	GSList *l;
+
+	if (status) {
+		error("Discover primary services by UUID failed: %s\n",
+							att_ecode2str(status));
+		return;
+	}
+
+	if (ranges == NULL) {
+		error("No service UUID found\n");
+		return;
+	}
+
+	for (l = ranges; l; l = l->next) {
+		struct att_range *range = l->data;
+		rl_printf("Starting handle: 0x%04x Ending handle: 0x%04x\n",
+						range->start, range->end);
+	}
+}
+
+static void included_cb(uint8_t status, GSList *includes, void *user_data)
+{
+	GSList *l;
+
+	if (status) {
+		error("Find included services failed: %s\n",
+							att_ecode2str(status));
+		return;
+	}
+
+	if (includes == NULL) {
+		rl_printf("No included services found for this range\n");
+		return;
+	}
+
+	for (l = includes; l; l = l->next) {
+		struct gatt_included *incl = l->data;
+		rl_printf("handle: 0x%04x, start handle: 0x%04x, "
+					"end handle: 0x%04x uuid: %s\n",
+					incl->handle, incl->range.start,
+					incl->range.end, incl->uuid);
+	}
+}
+
+static void char_cb(uint8_t status, GSList *characteristics, void *user_data)
+{
+	GSList *l;
+
+	if (status) {
+		error("Discover all characteristics failed: %s\n",
+							att_ecode2str(status));
+		return;
+	}
+
+	for (l = characteristics; l; l = l->next) {
+		struct gatt_char *chars = l->data;
+
+		rl_printf("handle: 0x%04x, char properties: 0x%02x, char value "
+				"handle: 0x%04x, uuid: %s\n", chars->handle,
+				chars->properties, chars->value_handle,
+				chars->uuid);
+	}
+}
+
+static void char_desc_cb(uint8_t status, GSList *descriptors, void *user_data)
+{
+	GSList *l;
+
+	if (status) {
+		error("Discover descriptors failed: %s\n",
+							att_ecode2str(status));
+		return;
+	}
+
+	for (l = descriptors; l; l = l->next) {
+		struct gatt_desc *desc = l->data;
+
+		rl_printf("handle: 0x%04x, uuid: %s\n", desc->handle,
+								desc->uuid);
+	}
+}
+
+static void char_read_cb(guint8 status, const guint8 *pdu, guint16 plen,
+							gpointer user_data)
+{
+	uint8_t value[plen];
+	ssize_t vlen;
+	int i;
+	GString *s;
+
+	if (status != 0) {
+		error("Characteristic value/descriptor read failed: %s\n",
+							att_ecode2str(status));
+		return;
+	}
+
+	vlen = dec_read_resp(pdu, plen, value, sizeof(value));
+	if (vlen < 0) {
+		error("Protocol error\n");
+		return;
+	}
+
+	s = g_string_new("Characteristic value/descriptor: ");
+	for (i = 0; i < vlen; i++)
+		g_string_append_printf(s, "%02x ", value[i]);
+
+	rl_printf("%s\n", s->str);
+	g_string_free(s, TRUE);
+}
+
+static void char_read_by_uuid_cb(guint8 status, const guint8 *pdu,
+					guint16 plen, gpointer user_data)
+{
+	struct att_data_list *list;
+	int i;
+	GString *s;
+
+	if (status != 0) {
+		error("Read characteristics by UUID failed: %s\n",
+							att_ecode2str(status));
+		return;
+	}
+
+	list = dec_read_by_type_resp(pdu, plen);
+	if (list == NULL)
+		return;
+
+	s = g_string_new(NULL);
+	for (i = 0; i < list->num; i++) {
+		uint8_t *value = list->data[i];
+		int j;
+
+		g_string_printf(s, "handle: 0x%04x \t value: ",
+							get_le16(value));
+		value += 2;
+		for (j = 0; j < list->len - 2; j++, value++)
+			g_string_append_printf(s, "%02x ", *value);
+
+		rl_printf("%s\n", s->str);
+	}
+
+	att_data_list_free(list);
+	g_string_free(s, TRUE);
+}
+
+static void cmd_exit(int argcp, char **argvp)
+{
+	rl_callback_handler_remove();
+	g_main_loop_quit(event_loop);
+}
+
+static gboolean channel_watcher(GIOChannel *chan, GIOCondition cond,
+				gpointer user_data)
+{
+	disconnect_io();
+
+	return FALSE;
+}
+static void cmd_lescan(int argcp, char **argvp)
+{
+     rl_printf("Scanning Le devices...\n");
+     system("hcitool lescan > /ltrx_user/lescan_result &");
+     sleep(11);
+     system("kill -2 $(ps | grep -m 1 'hcitool lescan'| cut -d ' ' -f 2)");
+     system("sort -r /ltrx_user/lescan_result | uniq -w 17 | sed -n '1!p' > /ltrx_user/lescan_result_sorted");
+     FILE *fp;
+     char line[256];
+     fp = fopen("/ltrx_user/lescan_result_sorted", "r");
+     if (fp == NULL)
+     {
+        perror("Error while opening the file.\n");
+     }
+     else
+     { 
+        printf("Device Address   \tName    \t\t Adreess Type\n");
+        printf("--------------   \t----    \t\t ------------\n");
+        while (fgets(line, sizeof(line), fp)) 
+            printf("%s", line);
+     }
+     fclose(fp);
+     system("rm /ltrx_user/lescan_result /ltrx_user/lescan_result_sorted"); 
+}
+static void cmd_connect(int argcp, char **argvp)
+{
+	GError *gerr = NULL;
+
+	if (conn_state != STATE_DISCONNECTED)
+		return;
+
+	if (argcp > 1) {
+		g_free(opt_dst);
+		opt_dst = g_strdup(argvp[1]);
+
+		g_free(opt_dst_type);
+		if (argcp > 2)
+			opt_dst_type = g_strdup(argvp[2]);
+		else
+			opt_dst_type = g_strdup("public");
+	}
+
+	if (opt_dst == NULL) {
+		error("Remote Bluetooth address required\n");
+		return;
+	}
+
+	rl_printf("Attempting to connect to %s\n", opt_dst);
+	set_state(STATE_CONNECTING);
+	iochannel = gatt_connect(opt_src, opt_dst, opt_dst_type, opt_sec_level,
+					opt_psm, opt_mtu, connect_cb, &gerr);
+	if (iochannel == NULL) {
+		set_state(STATE_DISCONNECTED);
+		error("%s\n", gerr->message);
+		g_error_free(gerr);
+	} else
+		g_io_add_watch(iochannel, G_IO_HUP, channel_watcher, NULL);
+}
+
+static void cmd_disconnect(int argcp, char **argvp)
+{
+	disconnect_io();
+}
+
+static void cmd_primary(int argcp, char **argvp)
+{
+	bt_uuid_t uuid;
+
+	if (conn_state != STATE_CONNECTED) {
+		failed("Disconnected\n");
+		return;
+	}
+
+	if (argcp == 1) {
+		gatt_discover_primary(attrib, NULL, primary_all_cb, NULL);
+		return;
+	}
+
+	if (bt_string_to_uuid(&uuid, argvp[1]) < 0) {
+		error("Invalid UUID\n");
+		return;
+	}
+
+	gatt_discover_primary(attrib, &uuid, primary_by_uuid_cb, NULL);
+}
+
+static int strtohandle(const char *src)
+{
+	char *e;
+	int dst;
+
+	errno = 0;
+	dst = strtoll(src, &e, 16);
+	if (errno != 0 || *e != '\0')
+		return -EINVAL;
+
+	return dst;
+}
+
+static void cmd_included(int argcp, char **argvp)
+{
+	int start = 0x0001;
+	int end = 0xffff;
+
+	if (conn_state != STATE_CONNECTED) {
+		failed("Disconnected\n");
+		return;
+	}
+
+	if (argcp > 1) {
+		start = strtohandle(argvp[1]);
+		if (start < 0) {
+			error("Invalid start handle: %s\n", argvp[1]);
+			return;
+		}
+		end = start;
+	}
+
+	if (argcp > 2) {
+		end = strtohandle(argvp[2]);
+		if (end < 0) {
+			error("Invalid end handle: %s\n", argvp[2]);
+			return;
+		}
+	}
+
+	gatt_find_included(attrib, start, end, included_cb, NULL);
+}
+
+static void cmd_char(int argcp, char **argvp)
+{
+	int start = 0x0001;
+	int end = 0xffff;
+
+	if (conn_state != STATE_CONNECTED) {
+		failed("Disconnected\n");
+		return;
+	}
+
+	if (argcp > 1) {
+		start = strtohandle(argvp[1]);
+		if (start < 0) {
+			error("Invalid start handle: %s\n", argvp[1]);
+			return;
+		}
+	}
+
+	if (argcp > 2) {
+		end = strtohandle(argvp[2]);
+		if (end < 0) {
+			error("Invalid end handle: %s\n", argvp[2]);
+			return;
+		}
+	}
+
+	if (argcp > 3) {
+		bt_uuid_t uuid;
+
+		if (bt_string_to_uuid(&uuid, argvp[3]) < 0) {
+			error("Invalid UUID\n");
+			return;
+		}
+
+		gatt_discover_char(attrib, start, end, &uuid, char_cb, NULL);
+		return;
+	}
+
+	gatt_discover_char(attrib, start, end, NULL, char_cb, NULL);
+}
+
+static void cmd_char_desc(int argcp, char **argvp)
+{
+	if (conn_state != STATE_CONNECTED) {
+		failed("Disconnected\n");
+		return;
+	}
+
+	if (argcp > 1) {
+		start = strtohandle(argvp[1]);
+		if (start < 0) {
+			error("Invalid start handle: %s\n", argvp[1]);
+			return;
+		}
+	} else
+		start = 0x0001;
+
+	if (argcp > 2) {
+		end = strtohandle(argvp[2]);
+		if (end < 0) {
+			error("Invalid end handle: %s\n", argvp[2]);
+			return;
+		}
+	} else
+		end = 0xffff;
+
+	gatt_discover_desc(attrib, start, end, NULL, char_desc_cb, NULL);
+}
+
+static void cmd_read_hnd(int argcp, char **argvp)
+{
+	int handle;
+
+	if (conn_state != STATE_CONNECTED) {
+		failed("Disconnected\n");
+		return;
+	}
+
+	if (argcp < 2) {
+		error("Missing argument: handle\n");
+		return;
+	}
+
+	handle = strtohandle(argvp[1]);
+	if (handle < 0) {
+		error("Invalid handle: %s\n", argvp[1]);
+		return;
+	}
+
+	gatt_read_char(attrib, handle, char_read_cb, attrib);
+}
+
+static void cmd_read_uuid(int argcp, char **argvp)
+{
+	int start = 0x0001;
+	int end = 0xffff;
+	bt_uuid_t uuid;
+
+	if (conn_state != STATE_CONNECTED) {
+		failed("Disconnected\n");
+		return;
+	}
+
+	if (argcp < 2) {
+		error("Missing argument: UUID\n");
+		return;
+	}
+
+	if (bt_string_to_uuid(&uuid, argvp[1]) < 0) {
+		error("Invalid UUID\n");
+		return;
+	}
+
+	if (argcp > 2) {
+		start = strtohandle(argvp[2]);
+		if (start < 0) {
+			error("Invalid start handle: %s\n", argvp[1]);
+			return;
+		}
+	}
+
+	if (argcp > 3) {
+		end = strtohandle(argvp[3]);
+		if (end < 0) {
+			error("Invalid end handle: %s\n", argvp[2]);
+			return;
+		}
+	}
+
+	gatt_read_char_by_uuid(attrib, start, end, &uuid, char_read_by_uuid_cb,
+									NULL);
+}
+
+static void char_write_req_cb(guint8 status, const guint8 *pdu, guint16 plen,
+							gpointer user_data)
+{
+	if (status != 0) {
+		error("Characteristic Write Request failed: "
+						"%s\n", att_ecode2str(status));
+		return;
+	}
+
+	if (!dec_write_resp(pdu, plen) && !dec_exec_write_resp(pdu, plen)) {
+		error("Protocol error\n");
+		return;
+	}
+
+	rl_printf("Characteristic value was written successfully\n");
+}
+
+static void cmd_char_write(int argcp, char **argvp)
+{
+	uint8_t *value;
+	size_t plen;
+	int handle;
+
+	if (conn_state != STATE_CONNECTED) {
+		failed("Disconnected\n");
+		return;
+	}
+
+	if (argcp < 3) {
+		rl_printf("Usage: %s <handle> <new value>\n", argvp[0]);
+		return;
+	}
+
+	handle = strtohandle(argvp[1]);
+	if (handle <= 0) {
+		error("A valid handle is required\n");
+		return;
+	}
+
+	plen = gatt_attr_data_from_string(argvp[2], &value);
+	if (plen == 0) {
+		error("Invalid value\n");
+		return;
+	}
+
+	if (g_strcmp0("char-write-req", argvp[0]) == 0)
+		gatt_write_char(attrib, handle, value, plen,
+					char_write_req_cb, NULL);
+	else
+		gatt_write_cmd(attrib, handle, value, plen, NULL, NULL);
+
+	g_free(value);
+}
+
+static void cmd_sec_level(int argcp, char **argvp)
+{
+	GError *gerr = NULL;
+	BtIOSecLevel sec_level;
+
+	if (argcp < 2) {
+		rl_printf("sec-level: %s\n", opt_sec_level);
+		return;
+	}
+
+	if (strcasecmp(argvp[1], "medium") == 0)
+		sec_level = BT_IO_SEC_MEDIUM;
+	else if (strcasecmp(argvp[1], "high") == 0)
+		sec_level = BT_IO_SEC_HIGH;
+	else if (strcasecmp(argvp[1], "low") == 0)
+		sec_level = BT_IO_SEC_LOW;
+	else {
+		rl_printf("Allowed values: low | medium | high\n");
+		return;
+	}
+
+	g_free(opt_sec_level);
+	opt_sec_level = g_strdup(argvp[1]);
+
+	if (conn_state != STATE_CONNECTED)
+		return;
+
+	if (opt_psm) {
+		rl_printf("Change will take effect on reconnection\n");
+		return;
+	}
+
+	bt_io_set(iochannel, &gerr,
+			BT_IO_OPT_SEC_LEVEL, sec_level,
+			BT_IO_OPT_INVALID);
+	if (gerr) {
+		error("%s\n", gerr->message);
+		g_error_free(gerr);
+	}
+}
+
+static void exchange_mtu_cb(guint8 status, const guint8 *pdu, guint16 plen,
+							gpointer user_data)
+{
+	uint16_t mtu;
+
+	if (status != 0) {
+		error("Exchange MTU Request failed: %s\n",
+						att_ecode2str(status));
+		return;
+	}
+
+	if (!dec_mtu_resp(pdu, plen, &mtu)) {
+		error("Protocol error\n");
+		return;
+	}
+
+	mtu = MIN(mtu, opt_mtu);
+	/* Set new value for MTU in client */
+	if (g_attrib_set_mtu(attrib, mtu))
+		rl_printf("MTU was exchanged successfully: %d\n", mtu);
+	else
+		error("Error exchanging MTU\n");
+}
+
+static void cmd_mtu(int argcp, char **argvp)
+{
+	if (conn_state != STATE_CONNECTED) {
+		failed("Disconnected\n");
+		return;
+	}
+
+	if (opt_psm) {
+		failed("Operation is only available for LE transport.\n");
+		return;
+	}
+
+	if (argcp < 2) {
+		rl_printf("Usage: mtu <value>\n");
+		return;
+	}
+
+	if (opt_mtu) {
+		failed("MTU exchange can only occur once per connection.\n");
+		return;
+	}
+
+	errno = 0;
+	opt_mtu = strtoll(argvp[1], NULL, 0);
+	if (errno != 0 || opt_mtu < ATT_DEFAULT_LE_MTU) {
+		error("Invalid value. Minimum MTU size is %d\n",
+							ATT_DEFAULT_LE_MTU);
+		return;
+	}
+
+	gatt_exchange_mtu(attrib, opt_mtu, exchange_mtu_cb, NULL);
+}
+
+static struct {
+	const char *cmd;
+	void (*func)(int argcp, char **argvp);
+	const char *params;
+	const char *desc;
+} commands[] = {
+	{ "help",		cmd_help,	"",
+		"Show this help"},
+	{ "exit",		cmd_exit,	"",
+		"Exit interactive mode" },
+	{ "quit",		cmd_exit,	"",
+		"Exit interactive mode" },
+	{ "lescan",		cmd_lescan,	"",
+		"Scans LE devices advertising"}, 
+	{ "connect",		cmd_connect,	"[address [address type]]",
+		"Connect to a remote device" },
+	{ "disconnect",		cmd_disconnect,	"",
+		"Disconnect from a remote device" },
+	{ "primary",		cmd_primary,	"[UUID]",
+		"Primary Service Discovery" },
+	{ "included",		cmd_included,	"[start hnd [end hnd]]",
+		"Find Included Services" },
+	{ "characteristics",	cmd_char,	"[start hnd [end hnd [UUID]]]",
+		"Characteristics Discovery" },
+	{ "char-desc",		cmd_char_desc,	"[start hnd] [end hnd]",
+		"Characteristics Descriptor Discovery" },
+	{ "char-read-hnd",	cmd_read_hnd,	"<handle>",
+		"Characteristics Value/Descriptor Read by handle" },
+	{ "char-read-uuid",	cmd_read_uuid,	"<UUID> [start hnd] [end hnd]",
+		"Characteristics Value/Descriptor Read by UUID" },
+	{ "char-write-req",	cmd_char_write,	"<handle> <new value>",
+		"Characteristic Value Write (Write Request)" },
+	{ "char-write-cmd",	cmd_char_write,	"<handle> <new value>",
+		"Characteristic Value Write (No response)" },
+	{ "sec-level",		cmd_sec_level,	"[low | medium | high]",
+		"Set security level. Default: low" },
+	{ "mtu",		cmd_mtu,	"<value>",
+		"Exchange MTU for GATT/ATT" },
+	{ NULL, NULL, NULL}
+};
+
+static void cmd_help(int argcp, char **argvp)
+{
+	int i;
+
+	for (i = 0; commands[i].cmd; i++)
+		rl_printf("%-15s %-30s %s\n", commands[i].cmd,
+				commands[i].params, commands[i].desc);
+}
+
+static void parse_line(char *line_read)
+{
+	char **argvp;
+	int argcp;
+	int i;
+
+	if (line_read == NULL) {
+		rl_printf("\n");
+		cmd_exit(0, NULL);
+		return;
+	}
+
+	line_read = g_strstrip(line_read);
+
+	if (*line_read == '\0')
+		goto done;
+
+	add_history(line_read);
+
+	if (g_shell_parse_argv(line_read, &argcp, &argvp, NULL) == FALSE)
+		goto done;
+
+	for (i = 0; commands[i].cmd; i++)
+		if (strcasecmp(commands[i].cmd, argvp[0]) == 0)
+			break;
+
+	if (commands[i].cmd)
+		commands[i].func(argcp, argvp);
+	else
+		error("%s: command not found\n", argvp[0]);
+
+	g_strfreev(argvp);
+
+done:
+	free(line_read);
+}
+
+static gboolean prompt_read(GIOChannel *chan, GIOCondition cond,
+							gpointer user_data)
+{
+	if (cond & (G_IO_HUP | G_IO_ERR | G_IO_NVAL)) {
+		g_io_channel_unref(chan);
+		return FALSE;
+	}
+
+	rl_callback_read_char();
+
+	return TRUE;
+}
+
+static char *completion_generator(const char *text, int state)
+{
+	static int index = 0, len = 0;
+	const char *cmd = NULL;
+
+	if (state == 0) {
+		index = 0;
+		len = strlen(text);
+	}
+
+	while ((cmd = commands[index].cmd) != NULL) {
+		index++;
+		if (strncmp(cmd, text, len) == 0)
+			return strdup(cmd);
+	}
+
+	return NULL;
+}
+
+static char **commands_completion(const char *text, int start, int end)
+{
+	if (start == 0)
+		return rl_completion_matches(text, &completion_generator);
+	else
+		return NULL;
+}
+
+static guint setup_standard_input(void)
+{
+	GIOChannel *channel;
+	guint source;
+
+	channel = g_io_channel_unix_new(fileno(stdin));
+
+	source = g_io_add_watch(channel,
+				G_IO_IN | G_IO_HUP | G_IO_ERR | G_IO_NVAL,
+				prompt_read, NULL);
+
+	g_io_channel_unref(channel);
+
+	return source;
+}
+
+static gboolean signal_handler(GIOChannel *channel, GIOCondition condition,
+							gpointer user_data)
+{
+	static unsigned int __terminated = 0;
+	struct signalfd_siginfo si;
+	ssize_t result;
+	int fd;
+
+	if (condition & (G_IO_NVAL | G_IO_ERR | G_IO_HUP)) {
+		g_main_loop_quit(event_loop);
+		return FALSE;
+	}
+
+	fd = g_io_channel_unix_get_fd(channel);
+
+	result = read(fd, &si, sizeof(si));
+	if (result != sizeof(si))
+		return FALSE;
+
+	switch (si.ssi_signo) {
+	case SIGINT:
+		rl_replace_line("", 0);
+		rl_crlf();
+		rl_on_new_line();
+		rl_redisplay();
+		break;
+	case SIGTERM:
+		if (__terminated == 0) {
+			rl_replace_line("", 0);
+			rl_crlf();
+			g_main_loop_quit(event_loop);
+		}
+
+		__terminated = 1;
+		break;
+	}
+
+	return TRUE;
+}
+
+static guint setup_signalfd(void)
+{
+	GIOChannel *channel;
+	guint source;
+	sigset_t mask;
+	int fd;
+
+	sigemptyset(&mask);
+	sigaddset(&mask, SIGINT);
+	sigaddset(&mask, SIGTERM);
+
+	if (sigprocmask(SIG_BLOCK, &mask, NULL) < 0) {
+		perror("Failed to set signal mask");
+		return 0;
+	}
+
+	fd = signalfd(-1, &mask, 0);
+	if (fd < 0) {
+		perror("Failed to create signal descriptor");
+		return 0;
+	}
+
+	channel = g_io_channel_unix_new(fd);
+
+	g_io_channel_set_close_on_unref(channel, TRUE);
+	g_io_channel_set_encoding(channel, NULL, NULL);
+	g_io_channel_set_buffered(channel, FALSE);
+
+	source = g_io_add_watch(channel,
+				G_IO_IN | G_IO_HUP | G_IO_ERR | G_IO_NVAL,
+				signal_handler, NULL);
+
+	g_io_channel_unref(channel);
+
+	return source;
+}
+
+int interactive(const char *src, const char *dst,
+		const char *dst_type, int psm)
+{
+	guint input;
+	guint signal;
+
+	opt_sec_level = g_strdup("low");
+
+	opt_src = g_strdup(src);
+	opt_dst = g_strdup(dst);
+	opt_dst_type = g_strdup(dst_type);
+	opt_psm = psm;
+
+	prompt = g_string_new(NULL);
+
+	event_loop = g_main_loop_new(NULL, FALSE);
+
+	input = setup_standard_input();
+	signal = setup_signalfd();
+
+	rl_attempted_completion_function = commands_completion;
+	rl_erase_empty_line = 1;
+	rl_callback_handler_install(get_prompt(), parse_line);
+
+	g_main_loop_run(event_loop);
+
+	rl_callback_handler_remove();
+	cmd_disconnect(0, NULL);
+	g_source_remove(input);
+	g_source_remove(signal);
+	g_main_loop_unref(event_loop);
+	g_string_free(prompt, TRUE);
+
+	g_free(opt_src);
+	g_free(opt_dst);
+	g_free(opt_sec_level);
+
+	return 0;
+}
diff -ruN --new-file bluez_utils-5.43/btio/btio.c bluez_utils-5.43_mod_2/btio/btio.c
--- bluez_utils-5.43/btio/btio.c	2017-06-14 18:25:33.843679806 +0530
+++ bluez_utils-5.43_mod_2/btio/btio.c	2019-05-08 17:26:24.092147903 +0530
@@ -40,7 +40,7 @@
 #include "lib/l2cap.h"
 #include "lib/rfcomm.h"
 #include "lib/sco.h"
-
+#include "src/log.h"
 #include "btio.h"
 
 #ifndef BT_FLUSHABLE
@@ -138,6 +138,7 @@
 	default:
 		g_set_error(gerr, BT_IO_ERROR, EINVAL,
 					"Unknown BtIO socket type");
+		DBG_ERR("BT: BT_IO_ERROR");
 		return BT_IO_INVALID;
 	}
 }
@@ -1431,6 +1432,7 @@
 	default:
 		g_set_error(err, BT_IO_ERROR, EINVAL,
 				"Unknown BtIO type %d", type);
+		DBG_ERR("BT: ERR %s: BT_IO_INVALID",__func__);
 		return FALSE;
 	}
 }
@@ -1511,13 +1513,14 @@
 	BtIOType type;
 
 	type = bt_io_get_type(io, err);
+	DBG_ERR("BT: type = %d",type);
 	if (type == BT_IO_INVALID)
 		return FALSE;
 
 	va_start(args, opt1);
 	ret = get_valist(io, type, err, opt1, args);
 	va_end(args);
-
+	DBG_ERR("BT: bt_io_get ret = %x",ret);
 	return ret;
 }
 
diff -ruN --new-file bluez_utils-5.43/client/ltrx_beacon_scanner.c bluez_utils-5.43_mod_2/client/ltrx_beacon_scanner.c
--- bluez_utils-5.43/client/ltrx_beacon_scanner.c	1970-01-01 05:30:00.000000000 +0530
+++ bluez_utils-5.43_mod_2/client/ltrx_beacon_scanner.c	2019-08-01 10:37:59.651969092 +0530
@@ -0,0 +1,2714 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2012  Intel Corporation. All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <signal.h>
+#include <sys/signalfd.h>
+#include <wordexp.h>
+
+#include <readline/readline.h>
+#include <readline/history.h>
+#include <glib.h>
+
+#include "src/shared/util.h"
+#include "gdbus/gdbus.h"
+#include "monitor/uuid.h"
+#include "agent.h"
+#include "display.h"
+#include "gatt.h"
+#include "advertising.h"
+
+/* String display constants */
+#define COLORED_NEW	COLOR_GREEN "NEW" COLOR_OFF
+#define COLORED_CHG	COLOR_YELLOW "CHG" COLOR_OFF
+#define COLORED_DEL	COLOR_RED "DEL" COLOR_OFF
+
+#define PROMPT_ON	COLOR_BLUE "[bluetooth]" COLOR_OFF "# "
+#define PROMPT_OFF	"Waiting to connect to bluetoothd..."
+
+static GMainLoop *main_loop;
+static DBusConnection *dbus_conn;
+
+static GDBusProxy *agent_manager;
+static char *auto_register_agent = NULL;
+
+struct adapter {
+	GDBusProxy *proxy;
+	GList *devices;
+};
+
+static struct adapter *default_ctrl;
+static GDBusProxy *default_dev;
+static GDBusProxy *default_attr;
+static GDBusProxy *ad_manager;
+static GList *ctrl_list;
+
+static guint input = 0;
+static void cmd_info(const char *arg);
+uint16_t manufacture_key = 0;
+uint8_t manu_or_service_data[30] = {0};
+uint8_t manu_or_service_data_index;
+static uint8_t multi_byte_value_flag = 0;
+static uint8_t manufacture_first_value_flag = 0;
+uint8_t manufature_first_value_byte = 0;
+bool is_EddystoneBeacon = false;
+uint8_t is_discovering;
+static const char * const agent_arguments[] = {
+	"on",
+	"off",
+	"DisplayOnly",
+	"DisplayYesNo",
+	"KeyboardDisplay",
+	"KeyboardOnly",
+	"NoInputNoOutput",
+	NULL
+};
+
+static const char * const ad_arguments[] = {
+	"on",
+	"off",
+	"peripheral",
+	"broadcast",
+	NULL
+};
+
+static void proxy_leak(gpointer data)
+{
+	printf("Leaking proxy %p\n", data);
+}
+
+static gboolean input_handler(GIOChannel *channel, GIOCondition condition,
+							gpointer user_data)
+{
+	if (condition & G_IO_IN) {
+		rl_callback_read_char();
+		return TRUE;
+	}
+
+	if (condition & (G_IO_HUP | G_IO_ERR | G_IO_NVAL)) {
+		g_main_loop_quit(main_loop);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static guint setup_standard_input(void)
+{
+	GIOChannel *channel;
+	guint source;
+
+	channel = g_io_channel_unix_new(fileno(stdin));
+
+	source = g_io_add_watch(channel,
+				G_IO_IN | G_IO_HUP | G_IO_ERR | G_IO_NVAL,
+				input_handler, NULL);
+
+	g_io_channel_unref(channel);
+
+	return source;
+}
+
+static void connect_handler(DBusConnection *connection, void *user_data)
+{
+	rl_set_prompt(PROMPT_ON);
+	printf("\r");
+	rl_on_new_line();
+	rl_redisplay();
+}
+
+static void disconnect_handler(DBusConnection *connection, void *user_data)
+{
+	if (input > 0) {
+		g_source_remove(input);
+		input = 0;
+	}
+
+	rl_set_prompt(PROMPT_OFF);
+	printf("\r");
+	rl_on_new_line();
+	rl_redisplay();
+
+	g_list_free_full(ctrl_list, proxy_leak);
+	ctrl_list = NULL;
+
+	default_ctrl = NULL;
+}
+
+static void print_adapter(GDBusProxy *proxy, const char *description)
+{
+	DBusMessageIter iter;
+	const char *address, *name;
+
+	if (g_dbus_proxy_get_property(proxy, "Address", &iter) == FALSE)
+		return;
+
+	dbus_message_iter_get_basic(&iter, &address);
+
+	if (g_dbus_proxy_get_property(proxy, "Alias", &iter) == TRUE)
+		dbus_message_iter_get_basic(&iter, &name);
+	else
+		name = "<unknown>";
+
+	rl_printf("%s%s%sController %s %s %s\n",
+				description ? "[" : "",
+				description ? : "",
+				description ? "] " : "",
+				address, name,
+				default_ctrl &&
+				default_ctrl->proxy == proxy ?
+				"[default]" : "");
+
+}
+
+static void print_device(GDBusProxy *proxy, const char *description)
+{
+	DBusMessageIter iter;
+	const char *address, *name;
+
+	if (g_dbus_proxy_get_property(proxy, "Address", &iter) == FALSE)
+		return;
+
+	dbus_message_iter_get_basic(&iter, &address);
+
+	if (g_dbus_proxy_get_property(proxy, "Alias", &iter) == TRUE)
+		dbus_message_iter_get_basic(&iter, &name);
+	else
+		name = "<unknown>";
+
+	rl_printf("%s%s%sDevice %s %s\n",
+				description ? "[" : "",
+				description ? : "",
+				description ? "] " : "",
+				address, name);
+}
+static void get_key_iter(const char *label, const char *name,
+                                                DBusMessageIter *iter)
+{
+        dbus_bool_t valbool;
+        dbus_uint32_t valu32;
+        dbus_uint16_t valu16;
+        dbus_int16_t vals16;
+        unsigned char byte;
+        const char *valstr;
+        DBusMessageIter subiter;
+        char *entry;
+
+        if (iter == NULL) {
+                rl_printf("%s%s is nil\n", label, name);
+                return;
+        }
+
+        switch (dbus_message_iter_get_arg_type(iter)) {
+        case DBUS_TYPE_INVALID:
+                rl_printf("%s%s is invalid\n", label, name);
+                break;
+        case DBUS_TYPE_STRING:
+        case DBUS_TYPE_OBJECT_PATH:
+                dbus_message_iter_get_basic(iter, &valstr);
+                //rl_printf("%s%s: %s\n", label, name, valstr);
+                break;
+        case DBUS_TYPE_BOOLEAN:
+                dbus_message_iter_get_basic(iter, &valbool);
+                /*rl_printf("%s%s: %s\n", label, name,
+                                        valbool == TRUE ? "yes" : "no");*/
+                break;
+        case DBUS_TYPE_UINT32:
+                dbus_message_iter_get_basic(iter, &valu32);
+                //rl_printf("%s%s: 0x%06x\n", label, name, valu32);
+                break;
+        case DBUS_TYPE_UINT16:
+                dbus_message_iter_get_basic(iter, &valu16);
+                manufacture_key = (uint16_t)valu16; 
+                //rl_printf("%s%s: 0x%04x\n", label, name, valu16);
+                break;
+        case DBUS_TYPE_INT16:
+                dbus_message_iter_get_basic(iter, &vals16);
+                //rl_printf("%s%s: %d\n", label, name, vals16);
+                break;
+        case DBUS_TYPE_BYTE:
+                dbus_message_iter_get_basic(iter, &byte);
+                if(manufacture_first_value_flag)
+                {
+                    manufature_first_value_byte = byte;
+                    //rl_printf("manufature_first_value_byte : 0x%02x\n", manufature_first_value_byte ); 
+                    manufacture_first_value_flag = 0;
+                }
+                //rl_printf("%s%s: 0x%02x\n", label, name, byte);
+                break;
+        case DBUS_TYPE_VARIANT:
+                dbus_message_iter_recurse(iter, &subiter);
+                get_key_iter(label, name, &subiter);
+                break;
+        case DBUS_TYPE_ARRAY:
+                dbus_message_iter_recurse(iter, &subiter);
+                while (dbus_message_iter_get_arg_type(&subiter) !=
+                                                        DBUS_TYPE_INVALID) {
+                        get_key_iter(label, name, &subiter);
+                        dbus_message_iter_next(&subiter);
+                }
+                break;
+        case DBUS_TYPE_DICT_ENTRY:
+                dbus_message_iter_recurse(iter, &subiter);
+                entry = g_strconcat(name, " Key", NULL);
+                get_key_iter(label, entry, &subiter);
+                g_free(entry);
+                
+                entry = g_strconcat(name, " Value", NULL);
+                dbus_message_iter_next(&subiter);
+                manufacture_first_value_flag = 1;
+                get_key_iter(label, entry, &subiter);
+                g_free(entry);
+                break;
+        default:
+                rl_printf("%s%s has unsupported type\n", label, name);
+                break;
+        }
+}
+
+
+static void print_iter(const char *label, const char *name,
+						DBusMessageIter *iter)
+{
+	dbus_bool_t valbool;
+	dbus_uint32_t valu32;
+	dbus_uint16_t valu16;
+	dbus_int16_t vals16;
+	unsigned char byte;
+	const char *valstr;
+	DBusMessageIter subiter;
+	char *entry;
+
+	if (iter == NULL) {
+		rl_printf("%s%s is nil\n", label, name);
+		return;
+	}
+
+	switch (dbus_message_iter_get_arg_type(iter)) {
+	case DBUS_TYPE_INVALID:
+		rl_printf("%s%s is invalid\n", label, name);
+		break;
+	case DBUS_TYPE_STRING:
+	case DBUS_TYPE_OBJECT_PATH:
+		dbus_message_iter_get_basic(iter, &valstr);
+		rl_printf("%s%s: %s\n", label, name, valstr);
+		break;
+	case DBUS_TYPE_BOOLEAN:
+		dbus_message_iter_get_basic(iter, &valbool);
+                if(!strcmp(name, "Discovering"))
+                {
+                    rl_printf("%s%s: %s\n", label, name,
+                                        is_discovering == 1 ? "yes" : "no");
+                }
+                else
+		    rl_printf("%s%s: %s\n", label, name,
+					valbool == TRUE ? "yes" : "no");
+		break;
+	case DBUS_TYPE_UINT32:
+		dbus_message_iter_get_basic(iter, &valu32);
+		rl_printf("%s%s: 0x%06x\n", label, name, valu32);
+		break;
+	case DBUS_TYPE_UINT16:
+		dbus_message_iter_get_basic(iter, &valu16);
+		rl_printf("%s%s: 0x%04x\n", label, name, valu16);
+		break;
+	case DBUS_TYPE_INT16:
+		dbus_message_iter_get_basic(iter, &vals16);
+		rl_printf("%s%s: %d\n", label, name, vals16);
+		break;
+	case DBUS_TYPE_BYTE:
+		dbus_message_iter_get_basic(iter, &byte);
+		rl_printf("%s%s: 0x%02x\n", label, name, byte);
+                if(multi_byte_value_flag)
+                {
+                     manu_or_service_data[manu_or_service_data_index++] = byte;
+                }
+		break;
+	case DBUS_TYPE_VARIANT:
+		dbus_message_iter_recurse(iter, &subiter);
+		print_iter(label, name, &subiter);
+		break;
+	case DBUS_TYPE_ARRAY:
+		dbus_message_iter_recurse(iter, &subiter);
+		while (dbus_message_iter_get_arg_type(&subiter) !=
+							DBUS_TYPE_INVALID) {
+			print_iter(label, name, &subiter);
+			dbus_message_iter_next(&subiter);
+		}
+		break;
+	case DBUS_TYPE_DICT_ENTRY:
+		dbus_message_iter_recurse(iter, &subiter);
+		entry = g_strconcat(name, " Key", NULL);
+		print_iter(label, entry, &subiter);
+		g_free(entry);
+
+		entry = g_strconcat(name, " Value", NULL);
+		dbus_message_iter_next(&subiter);
+		print_iter(label, entry, &subiter);
+		g_free(entry);
+		break;
+	default:
+		rl_printf("%s%s has unsupported type\n", label, name);
+		break;
+	}
+}
+static void get_key_property(GDBusProxy *proxy)
+{
+        DBusMessageIter iter;
+
+        if (g_dbus_proxy_get_property(proxy, "ManufacturerData", &iter) == FALSE)
+                return;
+
+        get_key_iter("\t", "ManufacturerData", &iter);
+}
+
+static void print_property(GDBusProxy *proxy, const char *name)
+{
+	DBusMessageIter iter;
+
+	if (g_dbus_proxy_get_property(proxy, name, &iter) == FALSE)
+		return;
+
+	print_iter("\t", name, &iter);
+}
+static char *get_uuids(GDBusProxy *proxy)
+{
+        DBusMessageIter iter, value;
+
+        if (g_dbus_proxy_get_property(proxy, "UUIDs", &iter) == FALSE)
+                return;
+
+        dbus_message_iter_recurse(&iter, &value);
+        char match_uuid [40]; 
+        match_uuid[0] = '\0';
+        while (dbus_message_iter_get_arg_type(&value) == DBUS_TYPE_STRING) {
+                const char *uuid, *text;
+
+                dbus_message_iter_get_basic(&value, &uuid);
+
+                text = uuidstr_to_str(uuid);
+                if (text) {
+                        char str[26];
+                        unsigned int n;
+
+                        str[sizeof(str) - 1] = '\0';
+
+                        n = snprintf(str, sizeof(str), "%s", text);
+                        if (n > sizeof(str) - 1) {
+                                str[sizeof(str) - 2] = '.';
+                                str[sizeof(str) - 3] = '.';
+                                if (str[sizeof(str) - 4] == ' ')
+                                        str[sizeof(str) - 4] = '.';
+
+                                n = sizeof(str) - 1;
+                        }
+
+                        /*rl_printf("\tUUID: %s%*c(%s)\n",
+                                                str, 26 - n, ' ', uuid);*/
+                } /*else
+                        rl_printf("\tUUID: %*c(%s)\n", 26, ' ', uuid);*/
+                if(!memcmp(uuid, "0000feaa-0000-1000-8000-00805f9b34fb", 36))
+                {     
+                     memcpy(match_uuid, uuid, 36);
+                     match_uuid[36] = '\0';
+                }
+                dbus_message_iter_next(&value); 
+        }
+        return &match_uuid;
+}
+static void print_uuids(GDBusProxy *proxy)
+{
+	DBusMessageIter iter, value;
+
+	if (g_dbus_proxy_get_property(proxy, "UUIDs", &iter) == FALSE)
+		return;
+
+	dbus_message_iter_recurse(&iter, &value);
+
+	while (dbus_message_iter_get_arg_type(&value) == DBUS_TYPE_STRING) {
+		const char *uuid, *text;
+
+		dbus_message_iter_get_basic(&value, &uuid);
+
+		text = uuidstr_to_str(uuid);
+		if (text) {
+			char str[26];
+			unsigned int n;
+
+			str[sizeof(str) - 1] = '\0';
+
+			n = snprintf(str, sizeof(str), "%s", text);
+			if (n > sizeof(str) - 1) {
+				str[sizeof(str) - 2] = '.';
+				str[sizeof(str) - 3] = '.';
+				if (str[sizeof(str) - 4] == ' ')
+					str[sizeof(str) - 4] = '.';
+
+				n = sizeof(str) - 1;
+			}
+
+			rl_printf("\tUUID: %s%*c(%s)\n",
+						str, 26 - n, ' ', uuid);
+		} else
+			rl_printf("\tUUID: %*c(%s)\n", 26, ' ', uuid);
+                if(!memcmp(uuid, "0000feaa-0000-1000-8000-00805f9b34fb", 36))
+                    is_EddystoneBeacon = true; 
+
+		dbus_message_iter_next(&value);
+	}
+}
+
+static gboolean device_is_child(GDBusProxy *device, GDBusProxy *master)
+{
+	DBusMessageIter iter;
+	const char *adapter, *path;
+
+	if (!master)
+		return FALSE;
+
+	if (g_dbus_proxy_get_property(device, "Adapter", &iter) == FALSE)
+		return FALSE;
+
+	dbus_message_iter_get_basic(&iter, &adapter);
+	path = g_dbus_proxy_get_path(master);
+
+	if (!strcmp(path, adapter))
+		return TRUE;
+
+	return FALSE;
+}
+
+static gboolean service_is_child(GDBusProxy *service)
+{
+	GList *l;
+	DBusMessageIter iter;
+	const char *device, *path;
+
+	if (g_dbus_proxy_get_property(service, "Device", &iter) == FALSE)
+		return FALSE;
+
+	dbus_message_iter_get_basic(&iter, &device);
+
+	if (!default_ctrl)
+		return FALSE;
+
+	for (l = default_ctrl->devices; l; l = g_list_next(l)) {
+		struct GDBusProxy *proxy = l->data;
+
+		path = g_dbus_proxy_get_path(proxy);
+
+		if (!strcmp(path, device))
+			return TRUE;
+	}
+
+	return FALSE;
+}
+
+static struct adapter *find_parent(GDBusProxy *device)
+{
+	GList *list;
+
+	for (list = g_list_first(ctrl_list); list; list = g_list_next(list)) {
+		struct adapter *adapter = list->data;
+
+		if (device_is_child(device, adapter->proxy) == TRUE)
+			return adapter;
+	}
+	return NULL;
+}
+
+static void set_default_device(GDBusProxy *proxy, const char *attribute)
+{
+	char *desc = NULL;
+	DBusMessageIter iter;
+	const char *path;
+
+	default_dev = proxy;
+
+	if (proxy == NULL) {
+		default_attr = NULL;
+		goto done;
+	}
+
+	if (!g_dbus_proxy_get_property(proxy, "Alias", &iter)) {
+		if (!g_dbus_proxy_get_property(proxy, "Address", &iter))
+			goto done;
+	}
+
+	path = g_dbus_proxy_get_path(proxy);
+
+	dbus_message_iter_get_basic(&iter, &desc);
+	desc = g_strdup_printf(COLOR_BLUE "[%s%s%s]" COLOR_OFF "# ", desc,
+				attribute ? ":" : "",
+				attribute ? attribute + strlen(path) : "");
+
+done:
+	rl_set_prompt(desc ? desc : PROMPT_ON);
+	printf("\r");
+	rl_on_new_line();
+	g_free(desc);
+}
+
+static void device_added(GDBusProxy *proxy)
+{
+	DBusMessageIter iter;
+	struct adapter *adapter = find_parent(proxy);
+
+	if (!adapter) {
+		/* TODO: Error */
+		return;
+	}
+
+        get_key_property(proxy);
+        if(!memcmp(get_uuids(proxy), "0000feaa-0000-1000-8000-00805f9b34fb", 36) || (manufacture_key == 0x4c && manufature_first_value_byte == 0x02))
+	{
+          
+            adapter->devices = g_list_append(adapter->devices, proxy);
+            const char *address;
+            DBusMessageIter addr_iter;
+            if (g_dbus_proxy_get_property(proxy, "Address",
+                 &addr_iter) == TRUE) {
+
+                                dbus_message_iter_get_basic(&addr_iter,
+                                                                &address);
+            }
+               
+            print_device(proxy, COLORED_NEW);
+            cmd_info(address);
+            manufacture_key = 0;
+            manufature_first_value_byte = 0x00;
+        }
+        else
+        {
+            manufacture_key = 0;
+            manufature_first_value_byte = 0x00;
+        }
+	if (default_dev)
+		return;
+
+	if (g_dbus_proxy_get_property(proxy, "Connected", &iter)) {
+		dbus_bool_t connected;
+
+		dbus_message_iter_get_basic(&iter, &connected);
+
+		if (connected)
+			set_default_device(proxy, NULL);
+	}
+}
+
+static void adapter_added(GDBusProxy *proxy)
+{
+	struct adapter *adapter = g_malloc0(sizeof(struct adapter));
+
+	adapter->proxy = proxy;
+	ctrl_list = g_list_append(ctrl_list, adapter);
+
+	if (!default_ctrl)
+		default_ctrl = adapter;
+
+	print_adapter(proxy, COLORED_NEW);
+}
+
+static void proxy_added(GDBusProxy *proxy, void *user_data)
+{
+	const char *interface;
+
+	interface = g_dbus_proxy_get_interface(proxy);
+
+	if (!strcmp(interface, "org.bluez.Device1")) {
+		device_added(proxy);
+	} else if (!strcmp(interface, "org.bluez.Adapter1")) {
+		adapter_added(proxy);
+	} else if (!strcmp(interface, "org.bluez.AgentManager1")) {
+		if (!agent_manager) {
+			agent_manager = proxy;
+
+			if (auto_register_agent)
+				agent_register(dbus_conn, agent_manager,
+							auto_register_agent);
+		}
+	} else if (!strcmp(interface, "org.bluez.GattService1")) {
+		if (service_is_child(proxy))
+			gatt_add_service(proxy);
+	} else if (!strcmp(interface, "org.bluez.GattCharacteristic1")) {
+		gatt_add_characteristic(proxy);
+	} else if (!strcmp(interface, "org.bluez.GattDescriptor1")) {
+		gatt_add_descriptor(proxy);
+	} else if (!strcmp(interface, "org.bluez.GattManager1")) {
+		gatt_add_manager(proxy);
+	} else if (!strcmp(interface, "org.bluez.LEAdvertisingManager1")) {
+		ad_manager = proxy;
+	}
+}
+
+static void set_default_attribute(GDBusProxy *proxy)
+{
+	const char *path;
+
+	default_attr = proxy;
+
+	path = g_dbus_proxy_get_path(proxy);
+
+	set_default_device(default_dev, path);
+}
+
+static void device_removed(GDBusProxy *proxy)
+{
+	struct adapter *adapter = find_parent(proxy);
+	if (!adapter) {
+		/* TODO: Error */
+		return;
+	}
+
+	adapter->devices = g_list_remove(adapter->devices, proxy);
+
+	print_device(proxy, COLORED_DEL);
+
+	if (default_dev == proxy)
+		set_default_device(NULL, NULL);
+}
+
+static void adapter_removed(GDBusProxy *proxy)
+{
+	GList *ll;
+
+	for (ll = g_list_first(ctrl_list); ll; ll = g_list_next(ll)) {
+		struct adapter *adapter = ll->data;
+
+		if (adapter->proxy == proxy) {
+			print_adapter(proxy, COLORED_DEL);
+
+			if (default_ctrl && default_ctrl->proxy == proxy) {
+				default_ctrl = NULL;
+				set_default_device(NULL, NULL);
+			}
+
+			ctrl_list = g_list_remove_link(ctrl_list, ll);
+			g_list_free(adapter->devices);
+			g_free(adapter);
+			g_list_free(ll);
+			return;
+		}
+	}
+}
+
+static void proxy_removed(GDBusProxy *proxy, void *user_data)
+{
+	const char *interface;
+
+	interface = g_dbus_proxy_get_interface(proxy);
+
+	if (!strcmp(interface, "org.bluez.Device1")) {
+		device_removed(proxy);
+	} else if (!strcmp(interface, "org.bluez.Adapter1")) {
+		adapter_removed(proxy);
+	} else if (!strcmp(interface, "org.bluez.AgentManager1")) {
+		if (agent_manager == proxy) {
+			agent_manager = NULL;
+			if (auto_register_agent)
+				agent_unregister(dbus_conn, NULL);
+		}
+	} else if (!strcmp(interface, "org.bluez.GattService1")) {
+		gatt_remove_service(proxy);
+
+		if (default_attr == proxy)
+			set_default_attribute(NULL);
+	} else if (!strcmp(interface, "org.bluez.GattCharacteristic1")) {
+		gatt_remove_characteristic(proxy);
+
+		if (default_attr == proxy)
+			set_default_attribute(NULL);
+	} else if (!strcmp(interface, "org.bluez.GattDescriptor1")) {
+		gatt_remove_descriptor(proxy);
+
+		if (default_attr == proxy)
+			set_default_attribute(NULL);
+	} else if (!strcmp(interface, "org.bluez.GattManager1")) {
+		gatt_remove_manager(proxy);
+	} else if (!strcmp(interface, "org.bluez.LEAdvertisingManager1")) {
+		if (ad_manager == proxy) {
+			agent_manager = NULL;
+			ad_unregister(dbus_conn, NULL);
+		}
+	}
+}
+
+static void property_changed(GDBusProxy *proxy, const char *name,
+					DBusMessageIter *iter, void *user_data)
+{
+	const char *interface;
+
+	interface = g_dbus_proxy_get_interface(proxy);
+
+	if (!strcmp(interface, "org.bluez.Device1")) {
+		if (default_ctrl && device_is_child(proxy,
+					default_ctrl->proxy) == TRUE) {
+			DBusMessageIter addr_iter;
+			char *str;
+
+			if (g_dbus_proxy_get_property(proxy, "Address",
+							&addr_iter) == TRUE) {
+				const char *address;
+
+				dbus_message_iter_get_basic(&addr_iter,
+								&address);
+             
+                                get_key_property(proxy);
+                                if(!memcmp(get_uuids(proxy), "0000feaa-0000-1000-8000-00805f9b34fb", 36) || 
+                                    (manufacture_key == 0x4c && manufature_first_value_byte == 0x02))
+                                {
+				     str = g_strdup_printf("[" COLORED_CHG
+						"] Device %s ", address);
+                                     manufacture_key = 0;
+                                     manufature_first_value_byte = 0x00;
+                                }
+                                else 
+                                {
+                                     manufature_first_value_byte = 0x00;
+                                     manufacture_key = 0;
+                                     return;
+                                }
+			} else
+				str = g_strdup("");
+
+			if (strcmp(name, "Connected") == 0) {
+				dbus_bool_t connected;
+
+				dbus_message_iter_get_basic(iter, &connected);
+
+				if (connected && default_dev == NULL)
+					set_default_device(proxy, NULL);
+				else if (!connected && default_dev == proxy)
+					set_default_device(NULL, NULL);
+			}
+
+			print_iter(str, name, iter);
+			g_free(str);
+		}
+	} else if (!strcmp(interface, "org.bluez.Adapter1")) {
+		DBusMessageIter addr_iter;
+		char *str;
+
+		if (g_dbus_proxy_get_property(proxy, "Address",
+						&addr_iter) == TRUE) {
+			const char *address;
+
+			dbus_message_iter_get_basic(&addr_iter, &address);
+			str = g_strdup_printf("[" COLORED_CHG
+						"] Controller %s ", address);
+		} else
+			str = g_strdup("");
+
+		print_iter(str, name, iter);
+		g_free(str);
+	} else if (proxy == default_attr) {
+		char *str;
+
+		str = g_strdup_printf("[" COLORED_CHG "] Attribute %s ",
+						g_dbus_proxy_get_path(proxy));
+
+		print_iter(str, name, iter);
+		g_free(str);
+	}
+}
+
+static void message_handler(DBusConnection *connection,
+					DBusMessage *message, void *user_data)
+{
+	rl_printf("[SIGNAL] %s.%s\n", dbus_message_get_interface(message),
+					dbus_message_get_member(message));
+}
+
+static struct adapter *find_ctrl_by_address(GList *source, const char *address)
+{
+	GList *list;
+
+	for (list = g_list_first(source); list; list = g_list_next(list)) {
+		struct adapter *adapter = list->data;
+		DBusMessageIter iter;
+		const char *str;
+
+		if (g_dbus_proxy_get_property(adapter->proxy,
+					"Address", &iter) == FALSE)
+			continue;
+
+		dbus_message_iter_get_basic(&iter, &str);
+
+		if (!strcmp(str, address))
+			return adapter;
+	}
+
+	return NULL;
+}
+
+static GDBusProxy *find_proxy_by_address(GList *source, const char *address)
+{
+	GList *list;
+
+	for (list = g_list_first(source); list; list = g_list_next(list)) {
+		GDBusProxy *proxy = list->data;
+		DBusMessageIter iter;
+		const char *str;
+
+		if (g_dbus_proxy_get_property(proxy, "Address", &iter) == FALSE)
+			continue;
+
+		dbus_message_iter_get_basic(&iter, &str);
+
+		if (!strcmp(str, address))
+			return proxy;
+	}
+
+	return NULL;
+}
+
+static gboolean check_default_ctrl(void)
+{
+	if (!default_ctrl) {
+		rl_printf("No default controller available\n");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static gboolean parse_argument_on_off(const char *arg, dbus_bool_t *value)
+{
+	if (!arg || !strlen(arg)) {
+		rl_printf("Missing on/off argument\n");
+		return FALSE;
+	}
+
+	if (!strcmp(arg, "on") || !strcmp(arg, "yes")) {
+		*value = TRUE;
+		return TRUE;
+	}
+
+	if (!strcmp(arg, "off") || !strcmp(arg, "no")) {
+		*value = FALSE;
+		return TRUE;
+	}
+
+	rl_printf("Invalid argument %s\n", arg);
+	return FALSE;
+}
+
+static gboolean parse_argument_agent(const char *arg, dbus_bool_t *value,
+							const char **capability)
+{
+	const char * const *opt;
+
+	if (arg == NULL || strlen(arg) == 0) {
+		rl_printf("Missing on/off/capability argument\n");
+		return FALSE;
+	}
+
+	if (strcmp(arg, "on") == 0 || strcmp(arg, "yes") == 0) {
+		*value = TRUE;
+		*capability = "";
+		return TRUE;
+	}
+
+	if (strcmp(arg, "off") == 0 || strcmp(arg, "no") == 0) {
+		*value = FALSE;
+		return TRUE;
+	}
+
+	for (opt = agent_arguments; *opt; opt++) {
+		if (strcmp(arg, *opt) == 0) {
+			*value = TRUE;
+			*capability = *opt;
+			return TRUE;
+		}
+	}
+
+	rl_printf("Invalid argument %s\n", arg);
+	return FALSE;
+}
+
+static void cmd_list(const char *arg)
+{
+	GList *list;
+
+	for (list = g_list_first(ctrl_list); list; list = g_list_next(list)) {
+		struct adapter *adapter = list->data;
+		print_adapter(adapter->proxy, NULL);
+	}
+}
+
+static void cmd_show(const char *arg)
+{
+	struct adapter *adapter;
+	GDBusProxy *proxy;
+	DBusMessageIter iter;
+	const char *address;
+
+	if (!arg || !strlen(arg)) {
+		if (check_default_ctrl() == FALSE)
+			return;
+
+		proxy = default_ctrl->proxy;
+	} else {
+		adapter = find_ctrl_by_address(ctrl_list, arg);
+		if (!adapter) {
+			rl_printf("Controller %s not available\n", arg);
+			return;
+		}
+		proxy = adapter->proxy;
+	}
+
+	if (g_dbus_proxy_get_property(proxy, "Address", &iter) == FALSE)
+		return;
+
+	dbus_message_iter_get_basic(&iter, &address);
+	rl_printf("Controller %s\n", address);
+
+	print_property(proxy, "Name");
+	print_property(proxy, "Alias");
+	print_property(proxy, "Class");
+	print_property(proxy, "Powered");
+	print_property(proxy, "Discoverable");
+	print_property(proxy, "Pairable");
+	print_uuids(proxy);
+	print_property(proxy, "Modalias");
+	print_property(proxy, "Discovering");
+}
+
+static void cmd_select(const char *arg)
+{
+	struct adapter *adapter;
+
+	if (!arg || !strlen(arg)) {
+		rl_printf("Missing controller address argument\n");
+		return;
+	}
+
+	adapter = find_ctrl_by_address(ctrl_list, arg);
+	if (!adapter) {
+		rl_printf("Controller %s not available\n", arg);
+		return;
+	}
+
+	if (default_ctrl && default_ctrl->proxy == adapter->proxy)
+		return;
+
+	default_ctrl = adapter;
+	print_adapter(adapter->proxy, NULL);
+}
+
+static void cmd_devices(const char *arg)
+{
+	GList *ll;
+
+	if (check_default_ctrl() == FALSE)
+		return;
+
+	for (ll = g_list_first(default_ctrl->devices);
+			ll; ll = g_list_next(ll)) {
+		GDBusProxy *proxy = ll->data;
+		print_device(proxy, NULL);
+	}
+}
+
+static void cmd_paired_devices(const char *arg)
+{
+	GList *ll;
+
+	if (check_default_ctrl() == FALSE)
+		return;
+
+	for (ll = g_list_first(default_ctrl->devices);
+			ll; ll = g_list_next(ll)) {
+		GDBusProxy *proxy = ll->data;
+		DBusMessageIter iter;
+		dbus_bool_t paired;
+
+		if (g_dbus_proxy_get_property(proxy, "Paired", &iter) == FALSE)
+			continue;
+
+		dbus_message_iter_get_basic(&iter, &paired);
+		if (!paired)
+			continue;
+
+		print_device(proxy, NULL);
+	}
+}
+
+static void generic_callback(const DBusError *error, void *user_data)
+{
+	char *str = user_data;
+
+	if (dbus_error_is_set(error))
+		rl_printf("Failed to set %s: %s\n", str, error->name);
+	else
+		rl_printf("Changing %s succeeded\n", str);
+}
+
+static void cmd_system_alias(const char *arg)
+{
+	char *name;
+
+	if (!arg || !strlen(arg)) {
+		rl_printf("Missing name argument\n");
+		return;
+	}
+
+	if (check_default_ctrl() == FALSE)
+		return;
+
+	name = g_strdup(arg);
+
+	if (g_dbus_proxy_set_property_basic(default_ctrl->proxy, "Alias",
+					DBUS_TYPE_STRING, &name,
+					generic_callback, name, g_free) == TRUE)
+		return;
+
+	g_free(name);
+}
+
+static void cmd_reset_alias(const char *arg)
+{
+	char *name;
+
+	if (check_default_ctrl() == FALSE)
+		return;
+
+	name = g_strdup("");
+
+	if (g_dbus_proxy_set_property_basic(default_ctrl->proxy, "Alias",
+					DBUS_TYPE_STRING, &name,
+					generic_callback, name, g_free) == TRUE)
+		return;
+
+	g_free(name);
+}
+
+static void cmd_power(const char *arg)
+{
+	dbus_bool_t powered;
+	char *str;
+
+	if (parse_argument_on_off(arg, &powered) == FALSE)
+		return;
+
+	if (check_default_ctrl() == FALSE)
+		return;
+
+	str = g_strdup_printf("power %s", powered == TRUE ? "on" : "off");
+
+	if (g_dbus_proxy_set_property_basic(default_ctrl->proxy, "Powered",
+					DBUS_TYPE_BOOLEAN, &powered,
+					generic_callback, str, g_free) == TRUE)
+		return;
+
+	g_free(str);
+}
+
+static void cmd_pairable(const char *arg)
+{
+	dbus_bool_t pairable;
+	char *str;
+
+	if (parse_argument_on_off(arg, &pairable) == FALSE)
+		return;
+
+	if (check_default_ctrl() == FALSE)
+		return;
+
+	str = g_strdup_printf("pairable %s", pairable == TRUE ? "on" : "off");
+
+	if (g_dbus_proxy_set_property_basic(default_ctrl->proxy, "Pairable",
+					DBUS_TYPE_BOOLEAN, &pairable,
+					generic_callback, str, g_free) == TRUE)
+		return;
+
+	g_free(str);
+}
+
+static void cmd_discoverable(const char *arg)
+{
+	dbus_bool_t discoverable;
+	char *str;
+
+	if (parse_argument_on_off(arg, &discoverable) == FALSE)
+		return;
+
+	if (check_default_ctrl() == FALSE)
+		return;
+
+	str = g_strdup_printf("discoverable %s",
+				discoverable == TRUE ? "on" : "off");
+
+	if (g_dbus_proxy_set_property_basic(default_ctrl->proxy, "Discoverable",
+					DBUS_TYPE_BOOLEAN, &discoverable,
+					generic_callback, str, g_free) == TRUE)
+		return;
+
+	g_free(str);
+}
+
+static void cmd_agent(const char *arg)
+{
+	dbus_bool_t enable;
+	const char *capability;
+
+	if (parse_argument_agent(arg, &enable, &capability) == FALSE)
+		return;
+
+	if (enable == TRUE) {
+		g_free(auto_register_agent);
+		auto_register_agent = g_strdup(capability);
+
+		if (agent_manager)
+			agent_register(dbus_conn, agent_manager,
+						auto_register_agent);
+		else
+			rl_printf("Agent registration enabled\n");
+	} else {
+		g_free(auto_register_agent);
+		auto_register_agent = NULL;
+
+		if (agent_manager)
+			agent_unregister(dbus_conn, agent_manager);
+		else
+			rl_printf("Agent registration disabled\n");
+	}
+}
+
+static void cmd_default_agent(const char *arg)
+{
+	agent_default(dbus_conn, agent_manager);
+}
+
+static void start_discovery_reply(DBusMessage *message, void *user_data)
+{
+	dbus_bool_t enable = GPOINTER_TO_UINT(user_data);
+	DBusError error;
+
+	dbus_error_init(&error);
+
+	if (dbus_set_error_from_message(&error, message) == TRUE) {
+		rl_printf("Failed to %s discovery: %s\n",
+				enable == TRUE ? "start" : "stop", error.name);
+		dbus_error_free(&error);
+		return;
+	}
+	rl_printf("Discovery %s\n", enable == TRUE ? "started" : "stopped");
+}
+
+static void cmd_scan(const char *arg)
+{
+	dbus_bool_t enable;
+	const char *method;
+        uint8_t is_discovering_cpy = is_discovering;
+	if (parse_argument_on_off(arg, &enable) == FALSE)
+		return;
+
+	if (check_default_ctrl() == FALSE)
+		return;
+
+	if (enable == TRUE)
+	{
+        	method = "StartDiscovery";
+                is_discovering = 1;
+        }
+	else
+	{
+        	method = "StopDiscovery";
+                is_discovering = 0;
+        }
+	if (g_dbus_proxy_method_call(default_ctrl->proxy, method,
+				NULL, start_discovery_reply,
+				GUINT_TO_POINTER(enable), NULL) == FALSE) {
+		rl_printf("Failed to %s discovery\n",
+					enable == TRUE ? "start" : "stop");
+                is_discovering = is_discovering_cpy;
+		return;
+	}
+}
+
+static void append_variant(DBusMessageIter *iter, int type, void *val)
+{
+	DBusMessageIter value;
+	char sig[2] = { type, '\0' };
+
+	dbus_message_iter_open_container(iter, DBUS_TYPE_VARIANT, sig, &value);
+
+	dbus_message_iter_append_basic(&value, type, val);
+
+	dbus_message_iter_close_container(iter, &value);
+}
+
+static void append_array_variant(DBusMessageIter *iter, int type, void *val,
+							int n_elements)
+{
+	DBusMessageIter variant, array;
+	char type_sig[2] = { type, '\0' };
+	char array_sig[3] = { DBUS_TYPE_ARRAY, type, '\0' };
+
+	dbus_message_iter_open_container(iter, DBUS_TYPE_VARIANT,
+						array_sig, &variant);
+
+	dbus_message_iter_open_container(&variant, DBUS_TYPE_ARRAY,
+						type_sig, &array);
+
+	if (dbus_type_is_fixed(type) == TRUE) {
+		dbus_message_iter_append_fixed_array(&array, type, val,
+							n_elements);
+	} else if (type == DBUS_TYPE_STRING || type == DBUS_TYPE_OBJECT_PATH) {
+		const char ***str_array = val;
+		int i;
+
+		for (i = 0; i < n_elements; i++)
+			dbus_message_iter_append_basic(&array, type,
+							&((*str_array)[i]));
+	}
+
+	dbus_message_iter_close_container(&variant, &array);
+
+	dbus_message_iter_close_container(iter, &variant);
+}
+
+static void dict_append_entry(DBusMessageIter *dict, const char *key,
+							int type, void *val)
+{
+	DBusMessageIter entry;
+
+	if (type == DBUS_TYPE_STRING) {
+		const char *str = *((const char **) val);
+
+		if (str == NULL)
+			return;
+	}
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+							NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &key);
+
+	append_variant(&entry, type, val);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
+static void dict_append_basic_array(DBusMessageIter *dict, int key_type,
+					const void *key, int type, void *val,
+					int n_elements)
+{
+	DBusMessageIter entry;
+
+	dbus_message_iter_open_container(dict, DBUS_TYPE_DICT_ENTRY,
+						NULL, &entry);
+
+	dbus_message_iter_append_basic(&entry, key_type, key);
+
+	append_array_variant(&entry, type, val, n_elements);
+
+	dbus_message_iter_close_container(dict, &entry);
+}
+
+static void dict_append_array(DBusMessageIter *dict, const char *key, int type,
+						void *val, int n_elements)
+{
+	dict_append_basic_array(dict, DBUS_TYPE_STRING, &key, type, val,
+								n_elements);
+}
+
+#define	DISTANCE_VAL_INVALID	0x7FFF
+
+struct set_discovery_filter_args {
+	char *transport;
+	dbus_uint16_t rssi;
+	dbus_int16_t pathloss;
+	char **uuids;
+	size_t uuids_len;
+};
+
+static void set_discovery_filter_setup(DBusMessageIter *iter, void *user_data)
+{
+	struct set_discovery_filter_args *args = user_data;
+	DBusMessageIter dict;
+
+	dbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,
+				DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+				DBUS_TYPE_STRING_AS_STRING
+				DBUS_TYPE_VARIANT_AS_STRING
+				DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	dict_append_array(&dict, "UUIDs", DBUS_TYPE_STRING, &args->uuids,
+							args->uuids_len);
+
+	if (args->pathloss != DISTANCE_VAL_INVALID)
+		dict_append_entry(&dict, "Pathloss", DBUS_TYPE_UINT16,
+						&args->pathloss);
+
+	if (args->rssi != DISTANCE_VAL_INVALID)
+		dict_append_entry(&dict, "RSSI", DBUS_TYPE_INT16, &args->rssi);
+
+	if (args->transport != NULL)
+		dict_append_entry(&dict, "Transport", DBUS_TYPE_STRING,
+						&args->transport);
+
+	dbus_message_iter_close_container(iter, &dict);
+}
+
+
+static void set_discovery_filter_reply(DBusMessage *message, void *user_data)
+{
+	DBusError error;
+
+	dbus_error_init(&error);
+	if (dbus_set_error_from_message(&error, message) == TRUE) {
+		rl_printf("SetDiscoveryFilter failed: %s\n", error.name);
+		dbus_error_free(&error);
+		return;
+	}
+
+	rl_printf("SetDiscoveryFilter success\n");
+}
+
+static gint filtered_scan_rssi = DISTANCE_VAL_INVALID;
+static gint filtered_scan_pathloss = DISTANCE_VAL_INVALID;
+static char **filtered_scan_uuids;
+static size_t filtered_scan_uuids_len;
+static char *filtered_scan_transport;
+
+static void cmd_set_scan_filter_commit(void)
+{
+	struct set_discovery_filter_args args;
+
+	args.uuids = NULL;
+	args.pathloss = filtered_scan_pathloss;
+	args.rssi = filtered_scan_rssi;
+	args.transport = filtered_scan_transport;
+	args.uuids = filtered_scan_uuids;
+	args.uuids_len = filtered_scan_uuids_len;
+
+	if (check_default_ctrl() == FALSE)
+		return;
+
+	if (g_dbus_proxy_method_call(default_ctrl->proxy, "SetDiscoveryFilter",
+		set_discovery_filter_setup, set_discovery_filter_reply,
+		&args, NULL) == FALSE) {
+		rl_printf("Failed to set discovery filter\n");
+		return;
+	}
+}
+
+static void cmd_set_scan_filter_uuids(const char *arg)
+{
+	g_strfreev(filtered_scan_uuids);
+	filtered_scan_uuids = NULL;
+	filtered_scan_uuids_len = 0;
+
+	if (!arg || !strlen(arg))
+		goto commit;
+
+	filtered_scan_uuids = g_strsplit(arg, " ", -1);
+	if (!filtered_scan_uuids) {
+		rl_printf("Failed to parse input\n");
+		return;
+	}
+
+	filtered_scan_uuids_len = g_strv_length(filtered_scan_uuids);
+
+commit:
+	cmd_set_scan_filter_commit();
+}
+
+static void cmd_set_scan_filter_rssi(const char *arg)
+{
+	filtered_scan_pathloss = DISTANCE_VAL_INVALID;
+
+	if (!arg || !strlen(arg))
+		filtered_scan_rssi = DISTANCE_VAL_INVALID;
+	else
+		filtered_scan_rssi = atoi(arg);
+
+	cmd_set_scan_filter_commit();
+}
+
+static void cmd_set_scan_filter_pathloss(const char *arg)
+{
+	filtered_scan_rssi = DISTANCE_VAL_INVALID;
+
+	if (!arg || !strlen(arg))
+		filtered_scan_pathloss = DISTANCE_VAL_INVALID;
+	else
+		filtered_scan_pathloss = atoi(arg);
+
+	cmd_set_scan_filter_commit();
+}
+
+static void cmd_set_scan_filter_transport(const char *arg)
+{
+	g_free(filtered_scan_transport);
+
+	if (!arg || !strlen(arg))
+		filtered_scan_transport = NULL;
+	else
+		filtered_scan_transport = g_strdup(arg);
+
+	cmd_set_scan_filter_commit();
+}
+
+static void clear_discovery_filter_setup(DBusMessageIter *iter, void *user_data)
+{
+	DBusMessageIter dict;
+
+	dbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,
+				DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+				DBUS_TYPE_STRING_AS_STRING
+				DBUS_TYPE_VARIANT_AS_STRING
+				DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+
+	dbus_message_iter_close_container(iter, &dict);
+}
+
+static void cmd_set_scan_filter_clear(const char *arg)
+{
+	/* set default values for all options */
+	filtered_scan_rssi = DISTANCE_VAL_INVALID;
+	filtered_scan_pathloss = DISTANCE_VAL_INVALID;
+	g_strfreev(filtered_scan_uuids);
+	filtered_scan_uuids = NULL;
+	filtered_scan_uuids_len = 0;
+	g_free(filtered_scan_transport);
+	filtered_scan_transport = NULL;
+
+	if (check_default_ctrl() == FALSE)
+		return;
+
+	if (g_dbus_proxy_method_call(default_ctrl->proxy, "SetDiscoveryFilter",
+		clear_discovery_filter_setup, set_discovery_filter_reply,
+		NULL, NULL) == FALSE) {
+		rl_printf("Failed to clear discovery filter\n");
+	}
+}
+
+static struct GDBusProxy *find_device(const char *arg)
+{
+	GDBusProxy *proxy;
+
+	if (!arg || !strlen(arg)) {
+		if (default_dev)
+			return default_dev;
+		rl_printf("Missing device address argument\n");
+		return NULL;
+	}
+
+	if (check_default_ctrl() == FALSE)
+		return NULL;
+
+	proxy = find_proxy_by_address(default_ctrl->devices, arg);
+	if (!proxy) {
+		rl_printf("Device %s not available\n", arg);
+		return NULL;
+	}
+
+	return proxy;
+}
+
+static void cmd_info(const char *arg)
+{
+	GDBusProxy *proxy;
+	DBusMessageIter iter;
+	const char *address;
+
+	proxy = find_device(arg);
+	if (!proxy)
+		return;
+
+	if (g_dbus_proxy_get_property(proxy, "Address", &iter) == FALSE)
+		return;
+
+	dbus_message_iter_get_basic(&iter, &address);
+	rl_printf("Device %s\n", address);
+
+	print_property(proxy, "Name");
+	print_property(proxy, "Alias");
+	print_property(proxy, "Class");
+	print_property(proxy, "Appearance");
+	print_property(proxy, "Icon");
+	print_property(proxy, "Paired");
+	print_property(proxy, "Trusted");
+	print_property(proxy, "Blocked");
+	print_property(proxy, "Connected");
+	print_property(proxy, "LegacyPairing");
+        is_EddystoneBeacon = false;
+	print_uuids(proxy);
+	print_property(proxy, "Modalias");
+        manu_or_service_data_index = 0;
+        multi_byte_value_flag = 1;        
+	print_property(proxy, "ManufacturerData");
+        multi_byte_value_flag = 1;
+	print_property(proxy, "ServiceData");
+        multi_byte_value_flag = 0;
+        uint8_t index;
+        rl_printf("\tManufacture/Service Data: ");
+        for(index = 0; index < manu_or_service_data_index; index++)
+            rl_printf("%02x", manu_or_service_data[index]);
+        rl_printf("\n");
+        if(is_EddystoneBeacon == true && manu_or_service_data[0] == 0x10)
+        { 
+            uint8_t prefix[20], site_name[50], domain[10];
+            if(manu_or_service_data[2] == 0x00)
+                 sprintf(prefix, "http://www.");
+            else if(manu_or_service_data[2] == 0x01)
+                 sprintf(prefix, "https://www.");
+            else if(manu_or_service_data[2] == 0x02)
+                 sprintf(prefix, "http://");
+            else if(manu_or_service_data[2] == 0x03)
+                 sprintf(prefix, "https://");
+            else 
+                 sprintf(prefix, "invalid prefix");
+            if(manu_or_service_data[manu_or_service_data_index - 1] == 0x00)
+                 sprintf(domain, ".com/");
+            else if(manu_or_service_data[manu_or_service_data_index - 1] == 0x00)
+                 sprintf(domain, ".com/");
+            else if(manu_or_service_data[manu_or_service_data_index - 1] == 0x01)
+                 sprintf(domain, ".org/");
+            else if(manu_or_service_data[manu_or_service_data_index - 1] == 0x02)
+                 sprintf(domain, ".edu/");
+            else if(manu_or_service_data[manu_or_service_data_index - 1] == 0x03)
+                 sprintf(domain, ".net/");
+            else if(manu_or_service_data[manu_or_service_data_index - 1] == 0x04)
+                 sprintf(domain, ".info/");
+            else if(manu_or_service_data[manu_or_service_data_index - 1] == 0x05)
+                 sprintf(domain, ".biz/");
+            else if(manu_or_service_data[manu_or_service_data_index - 1] == 0x06)
+                 sprintf(domain, ".gov/");
+            else if(manu_or_service_data[manu_or_service_data_index - 1] == 0x07)
+                 sprintf(domain, ".com");
+            else if(manu_or_service_data[manu_or_service_data_index - 1] == 0x08)
+                 sprintf(domain, ".org");
+            else if(manu_or_service_data[manu_or_service_data_index - 1] == 0x09)
+                 sprintf(domain, ".edu");
+            else if(manu_or_service_data[manu_or_service_data_index - 1] == 0x0a)
+                 sprintf(domain, ".net");
+            else if(manu_or_service_data[manu_or_service_data_index - 1] == 0x0b)
+                 sprintf(domain, ".info");
+            else if(manu_or_service_data[manu_or_service_data_index - 1] == 0x0c)
+                 sprintf(domain, ".biz");
+            else if(manu_or_service_data[manu_or_service_data_index - 1] == 0x0d)
+                 sprintf(domain, ".gov");
+            else
+                 sprintf(domain, "");
+            for(index = 0; index < (manu_or_service_data_index - 4); index++)
+                 site_name[index] = manu_or_service_data[index + 3];
+            if(!strcmp(domain, ""))
+            {
+                site_name[index] = manu_or_service_data[index + 3];
+                site_name[index + 1] = '\0';
+            }
+            else
+                 site_name[index] = '\0';
+            rl_printf("\tURL : %s%s%s\n", prefix, site_name, domain);
+        }
+        manu_or_service_data_index = 0;
+	print_property(proxy, "RSSI");
+	print_property(proxy, "TxPower");
+        is_EddystoneBeacon = false;
+}
+
+static void pair_reply(DBusMessage *message, void *user_data)
+{
+	DBusError error;
+
+	dbus_error_init(&error);
+
+	if (dbus_set_error_from_message(&error, message) == TRUE) {
+		rl_printf("Failed to pair: %s\n", error.name);
+		dbus_error_free(&error);
+		return;
+	}
+
+	rl_printf("Pairing successful\n");
+}
+
+static void cmd_pair(const char *arg)
+{
+	GDBusProxy *proxy;
+
+	proxy = find_device(arg);
+	if (!proxy)
+		return;
+
+	if (g_dbus_proxy_method_call(proxy, "Pair", NULL, pair_reply,
+							NULL, NULL) == FALSE) {
+		rl_printf("Failed to pair\n");
+		return;
+	}
+
+	rl_printf("Attempting to pair with %s\n", arg);
+}
+
+static void cmd_trust(const char *arg)
+{
+	GDBusProxy *proxy;
+	dbus_bool_t trusted;
+	char *str;
+
+	proxy = find_device(arg);
+	if (!proxy)
+		return;
+
+	trusted = TRUE;
+
+	str = g_strdup_printf("%s trust", arg);
+
+	if (g_dbus_proxy_set_property_basic(proxy, "Trusted",
+					DBUS_TYPE_BOOLEAN, &trusted,
+					generic_callback, str, g_free) == TRUE)
+		return;
+
+	g_free(str);
+}
+
+static void cmd_untrust(const char *arg)
+{
+	GDBusProxy *proxy;
+	dbus_bool_t trusted;
+	char *str;
+
+	proxy = find_device(arg);
+	if (!proxy)
+		return;
+
+	trusted = FALSE;
+
+	str = g_strdup_printf("%s untrust", arg);
+
+	if (g_dbus_proxy_set_property_basic(proxy, "Trusted",
+					DBUS_TYPE_BOOLEAN, &trusted,
+					generic_callback, str, g_free) == TRUE)
+		return;
+
+	g_free(str);
+}
+
+static void cmd_block(const char *arg)
+{
+	GDBusProxy *proxy;
+	dbus_bool_t blocked;
+	char *str;
+
+	proxy = find_device(arg);
+	if (!proxy)
+		return;
+
+	blocked = TRUE;
+
+	str = g_strdup_printf("%s block", arg);
+
+	if (g_dbus_proxy_set_property_basic(proxy, "Blocked",
+					DBUS_TYPE_BOOLEAN, &blocked,
+					generic_callback, str, g_free) == TRUE)
+		return;
+
+	g_free(str);
+}
+
+static void cmd_unblock(const char *arg)
+{
+	GDBusProxy *proxy;
+	dbus_bool_t blocked;
+	char *str;
+
+	proxy = find_device(arg);
+	if (!proxy)
+		return;
+
+	blocked = FALSE;
+
+	str = g_strdup_printf("%s unblock", arg);
+
+	if (g_dbus_proxy_set_property_basic(proxy, "Blocked",
+					DBUS_TYPE_BOOLEAN, &blocked,
+					generic_callback, str, g_free) == TRUE)
+		return;
+
+	g_free(str);
+}
+
+static void remove_device_reply(DBusMessage *message, void *user_data)
+{
+	DBusError error;
+
+	dbus_error_init(&error);
+
+	if (dbus_set_error_from_message(&error, message) == TRUE) {
+		rl_printf("Failed to remove device: %s\n", error.name);
+		dbus_error_free(&error);
+		return;
+	}
+
+	rl_printf("Device has been removed\n");
+}
+
+static void remove_device_setup(DBusMessageIter *iter, void *user_data)
+{
+	const char *path = user_data;
+
+	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH, &path);
+}
+
+static void remove_device(GDBusProxy *proxy)
+{
+	char *path;
+
+	path = g_strdup(g_dbus_proxy_get_path(proxy));
+
+	if (!default_ctrl)
+		return;
+
+	if (g_dbus_proxy_method_call(default_ctrl->proxy, "RemoveDevice",
+						remove_device_setup,
+						remove_device_reply,
+						path, g_free) == FALSE) {
+		rl_printf("Failed to remove device\n");
+		g_free(path);
+	}
+}
+
+static void cmd_remove(const char *arg)
+{
+	GDBusProxy *proxy;
+
+	if (!arg || !strlen(arg)) {
+		rl_printf("Missing device address argument\n");
+		return;
+	}
+
+	if (check_default_ctrl() == FALSE)
+		return;
+
+	if (strcmp(arg, "*") == 0) {
+		GList *list;
+
+		for (list = default_ctrl->devices; list;
+						list = g_list_next(list)) {
+			GDBusProxy *proxy = list->data;
+
+			remove_device(proxy);
+		}
+		return;
+	}
+
+	proxy = find_proxy_by_address(default_ctrl->devices, arg);
+	if (!proxy) {
+		rl_printf("Device %s not available\n", arg);
+		return;
+	}
+
+	remove_device(proxy);
+}
+
+static void connect_reply(DBusMessage *message, void *user_data)
+{
+	GDBusProxy *proxy = user_data;
+	DBusError error;
+
+	dbus_error_init(&error);
+
+	if (dbus_set_error_from_message(&error, message) == TRUE) {
+		rl_printf("Failed to connect: %s\n", error.name);
+		dbus_error_free(&error);
+		return;
+	}
+
+	rl_printf("Connection successful\n");
+
+	set_default_device(proxy, NULL);
+}
+
+static void cmd_connect(const char *arg)
+{
+	GDBusProxy *proxy;
+
+	if (!arg || !strlen(arg)) {
+		rl_printf("Missing device address argument\n");
+		return;
+	}
+
+	if (check_default_ctrl() == FALSE)
+		return;
+
+	proxy = find_proxy_by_address(default_ctrl->devices, arg);
+	if (!proxy) {
+		rl_printf("Device %s not available\n", arg);
+		return;
+	}
+
+	if (g_dbus_proxy_method_call(proxy, "Connect", NULL, connect_reply,
+							proxy, NULL) == FALSE) {
+		rl_printf("Failed to connect\n");
+		return;
+	}
+
+	rl_printf("Attempting to connect to %s\n", arg);
+}
+
+static void disconn_reply(DBusMessage *message, void *user_data)
+{
+	GDBusProxy *proxy = user_data;
+	DBusError error;
+
+	dbus_error_init(&error);
+
+	if (dbus_set_error_from_message(&error, message) == TRUE) {
+		rl_printf("Failed to disconnect: %s\n", error.name);
+		dbus_error_free(&error);
+		return;
+	}
+
+	rl_printf("Successful disconnected\n");
+
+	if (proxy != default_dev)
+		return;
+
+	set_default_device(NULL, NULL);
+}
+
+static void cmd_disconn(const char *arg)
+{
+	GDBusProxy *proxy;
+
+	proxy = find_device(arg);
+	if (!proxy)
+		return;
+
+	if (g_dbus_proxy_method_call(proxy, "Disconnect", NULL, disconn_reply,
+							proxy, NULL) == FALSE) {
+		rl_printf("Failed to disconnect\n");
+		return;
+	}
+	if (strlen(arg) == 0) {
+		DBusMessageIter iter;
+
+		if (g_dbus_proxy_get_property(proxy, "Address", &iter) == TRUE)
+			dbus_message_iter_get_basic(&iter, &arg);
+	}
+	rl_printf("Attempting to disconnect from %s\n", arg);
+}
+
+static void cmd_list_attributes(const char *arg)
+{
+	GDBusProxy *proxy;
+
+	proxy = find_device(arg);
+	if (!proxy)
+		return;
+
+	gatt_list_attributes(g_dbus_proxy_get_path(proxy));
+}
+
+static void cmd_set_alias(const char *arg)
+{
+	char *name;
+
+	if (!arg || !strlen(arg)) {
+		rl_printf("Missing name argument\n");
+		return;
+	}
+
+	if (!default_dev) {
+		rl_printf("No device connected\n");
+		return;
+	}
+
+	name = g_strdup(arg);
+
+	if (g_dbus_proxy_set_property_basic(default_dev, "Alias",
+					DBUS_TYPE_STRING, &name,
+					generic_callback, name, g_free) == TRUE)
+		return;
+
+	g_free(name);
+}
+
+static void cmd_select_attribute(const char *arg)
+{
+	GDBusProxy *proxy;
+
+	if (!arg || !strlen(arg)) {
+		rl_printf("Missing attribute argument\n");
+		return;
+	}
+
+	if (!default_dev) {
+		rl_printf("No device connected\n");
+		return;
+	}
+
+	proxy = gatt_select_attribute(arg);
+	if (proxy)
+		set_default_attribute(proxy);
+}
+
+static struct GDBusProxy *find_attribute(const char *arg)
+{
+	GDBusProxy *proxy;
+
+	if (!arg || !strlen(arg)) {
+		if (default_attr)
+			return default_attr;
+		rl_printf("Missing attribute argument\n");
+		return NULL;
+	}
+
+	proxy = gatt_select_attribute(arg);
+	if (!proxy) {
+		rl_printf("Attribute %s not available\n", arg);
+		return NULL;
+	}
+
+	return proxy;
+}
+
+static void cmd_attribute_info(const char *arg)
+{
+	GDBusProxy *proxy;
+	DBusMessageIter iter;
+	const char *iface, *uuid, *text;
+
+	proxy = find_attribute(arg);
+	if (!proxy)
+		return;
+
+	if (g_dbus_proxy_get_property(proxy, "UUID", &iter) == FALSE)
+		return;
+
+	dbus_message_iter_get_basic(&iter, &uuid);
+
+	text = uuidstr_to_str(uuid);
+	if (!text)
+		text = g_dbus_proxy_get_path(proxy);
+
+	iface = g_dbus_proxy_get_interface(proxy);
+	if (!strcmp(iface, "org.bluez.GattService1")) {
+		rl_printf("Service - %s\n", text);
+
+		print_property(proxy, "UUID");
+		print_property(proxy, "Primary");
+		print_property(proxy, "Characteristics");
+		print_property(proxy, "Includes");
+	} else if (!strcmp(iface, "org.bluez.GattCharacteristic1")) {
+		rl_printf("Characteristic - %s\n", text);
+
+		print_property(proxy, "UUID");
+		print_property(proxy, "Service");
+		print_property(proxy, "Value");
+		print_property(proxy, "Notifying");
+		print_property(proxy, "Flags");
+		print_property(proxy, "Descriptors");
+	} else if (!strcmp(iface, "org.bluez.GattDescriptor1")) {
+		rl_printf("Descriptor - %s\n", text);
+
+		print_property(proxy, "UUID");
+		print_property(proxy, "Characteristic");
+		print_property(proxy, "Value");
+	}
+}
+
+static void cmd_read(const char *arg)
+{
+	if (!default_attr) {
+		rl_printf("No attribute selected\n");
+		return;
+	}
+
+	gatt_read_attribute(default_attr);
+}
+
+static void cmd_write(const char *arg)
+{
+	if (!arg || !strlen(arg)) {
+		rl_printf("Missing data argument\n");
+		return;
+	}
+
+	if (!default_attr) {
+		rl_printf("No attribute selected\n");
+		return;
+	}
+
+	gatt_write_attribute(default_attr, arg);
+}
+
+static void cmd_notify(const char *arg)
+{
+	dbus_bool_t enable;
+
+	if (parse_argument_on_off(arg, &enable) == FALSE)
+		return;
+
+	if (!default_attr) {
+		rl_printf("No attribute selected\n");
+		return;
+	}
+
+	gatt_notify_attribute(default_attr, enable ? true : false);
+}
+
+static void cmd_register_profile(const char *arg)
+{
+	wordexp_t w;
+
+	if (check_default_ctrl() == FALSE)
+		return;
+
+	if (wordexp(arg, &w, WRDE_NOCMD)) {
+		rl_printf("Invalid argument\n");
+		return;
+	}
+
+	if (w.we_wordc == 0) {
+		rl_printf("Missing argument\n");
+		return;
+	}
+
+	gatt_register_profile(dbus_conn, default_ctrl->proxy, &w);
+
+	wordfree(&w);
+}
+
+static void cmd_unregister_profile(const char *arg)
+{
+	if (check_default_ctrl() == FALSE)
+		return;
+
+	gatt_unregister_profile(dbus_conn, default_ctrl->proxy);
+}
+
+static void cmd_version(const char *arg)
+{
+	rl_printf("Version %s\n", VERSION);
+}
+
+static void cmd_quit(const char *arg)
+{
+	g_main_loop_quit(main_loop);
+}
+
+static char *generic_generator(const char *text, int state,
+					GList *source, const char *property)
+{
+	static int index, len;
+	GList *list;
+
+	if (!state) {
+		index = 0;
+		len = strlen(text);
+	}
+
+	for (list = g_list_nth(source, index); list;
+						list = g_list_next(list)) {
+		GDBusProxy *proxy = list->data;
+		DBusMessageIter iter;
+		const char *str;
+
+		index++;
+
+		if (g_dbus_proxy_get_property(proxy, property, &iter) == FALSE)
+			continue;
+
+		dbus_message_iter_get_basic(&iter, &str);
+
+		if (!strncmp(str, text, len))
+			return strdup(str);
+        }
+
+	return NULL;
+}
+
+static char *ctrl_generator(const char *text, int state)
+{
+	static int index = 0;
+	static int len = 0;
+	GList *list;
+
+	if (!state) {
+		index = 0;
+		len = strlen(text);
+	}
+
+	for (list = g_list_nth(ctrl_list, index); list;
+						list = g_list_next(list)) {
+		struct adapter *adapter = list->data;
+		DBusMessageIter iter;
+		const char *str;
+
+		index++;
+
+		if (g_dbus_proxy_get_property(adapter->proxy,
+					"Address", &iter) == FALSE)
+			continue;
+
+		dbus_message_iter_get_basic(&iter, &str);
+
+		if (!strncmp(str, text, len))
+			return strdup(str);
+	}
+
+	return NULL;
+}
+
+static char *dev_generator(const char *text, int state)
+{
+	return generic_generator(text, state,
+			default_ctrl ? default_ctrl->devices : NULL, "Address");
+}
+
+static char *attribute_generator(const char *text, int state)
+{
+	return gatt_attribute_generator(text, state);
+}
+
+static char *capability_generator(const char *text, int state)
+{
+	static int index, len;
+	const char *arg;
+
+	if (!state) {
+		index = 0;
+		len = strlen(text);
+	}
+
+	while ((arg = agent_arguments[index])) {
+		index++;
+
+		if (!strncmp(arg, text, len))
+			return strdup(arg);
+	}
+
+	return NULL;
+}
+
+static gboolean parse_argument_advertise(const char *arg, dbus_bool_t *value,
+							const char **type)
+{
+	const char * const *opt;
+
+	if (arg == NULL || strlen(arg) == 0) {
+		rl_printf("Missing on/off/type argument\n");
+		return FALSE;
+	}
+
+	if (strcmp(arg, "on") == 0 || strcmp(arg, "yes") == 0) {
+		*value = TRUE;
+		*type = "";
+		return TRUE;
+	}
+
+	if (strcmp(arg, "off") == 0 || strcmp(arg, "no") == 0) {
+		*value = FALSE;
+		return TRUE;
+	}
+
+	for (opt = ad_arguments; *opt; opt++) {
+		if (strcmp(arg, *opt) == 0) {
+			*value = TRUE;
+			*type = *opt;
+			return TRUE;
+		}
+	}
+
+	rl_printf("Invalid argument %s\n", arg);
+	return FALSE;
+}
+
+static void cmd_advertise(const char *arg)
+{
+	dbus_bool_t enable;
+	const char *type;
+
+	if (parse_argument_advertise(arg, &enable, &type) == FALSE)
+		return;
+
+	if (!ad_manager) {
+		rl_printf("LEAdvertisingManager not found\n");
+		return;
+	}
+
+	if (enable == TRUE)
+		ad_register(dbus_conn, ad_manager, type);
+	else
+		ad_unregister(dbus_conn, ad_manager);
+}
+
+static char *ad_generator(const char *text, int state)
+{
+	static int index, len;
+	const char *arg;
+
+	if (!state) {
+		index = 0;
+		len = strlen(text);
+	}
+
+	while ((arg = ad_arguments[index])) {
+		index++;
+
+		if (!strncmp(arg, text, len))
+			return strdup(arg);
+	}
+
+	return NULL;
+}
+
+static void cmd_set_advertise_uuids(const char *arg)
+{
+	ad_advertise_uuids(arg);
+}
+
+static void cmd_set_advertise_service(const char *arg)
+{
+	ad_advertise_service(arg);
+}
+
+static void cmd_set_advertise_manufacturer(const char *arg)
+{
+	ad_advertise_manufacturer(arg);
+}
+
+static void cmd_set_advertise_tx_power(const char *arg)
+{
+	if (arg == NULL || strlen(arg) == 0) {
+		rl_printf("Missing on/off argument\n");
+		return;
+	}
+
+	if (strcmp(arg, "on") == 0 || strcmp(arg, "yes") == 0) {
+		ad_advertise_tx_power(TRUE);
+		return;
+	}
+
+	if (strcmp(arg, "off") == 0 || strcmp(arg, "no") == 0) {
+		ad_advertise_tx_power(FALSE);
+		return;
+	}
+
+	rl_printf("Invalid argument\n");
+}
+
+static const struct {
+	const char *cmd;
+	const char *arg;
+	void (*func) (const char *arg);
+	const char *desc;
+	char * (*gen) (const char *text, int state);
+	void (*disp) (char **matches, int num_matches, int max_length);
+} cmd_table[] = {
+	{ "list",         NULL,       cmd_list, "List available controllers" },
+	{ "show",         "[ctrl]",   cmd_show, "Controller information",
+							ctrl_generator },
+	{ "select",       "<ctrl>",   cmd_select, "Select default controller",
+							ctrl_generator },
+	{ "devices",      NULL,       cmd_devices, "List available devices" },
+	/*{ "paired-devices", NULL,     cmd_paired_devices,
+					"List paired devices"},
+	{ "system-alias", "<name>",   cmd_system_alias },
+	{ "reset-alias",  NULL,       cmd_reset_alias },
+	{ "power",        "<on/off>", cmd_power, "Set controller power" },
+	{ "pairable",     "<on/off>", cmd_pairable,
+					"Set controller pairable mode" },
+	{ "discoverable", "<on/off>", cmd_discoverable,
+					"Set controller discoverable mode" },
+	{ "agent",        "<on/off/capability>", cmd_agent,
+				"Enable/disable agent with given capability",
+							capability_generator},
+	{ "default-agent",NULL,       cmd_default_agent,
+				"Set agent as the default one" },
+	{ "advertise",    "<on/off/type>", cmd_advertise,
+				"Enable/disable advertising with given type",
+							ad_generator},
+	{ "set-advertise-uuids", "[uuid1 uuid2 ...]",
+			cmd_set_advertise_uuids, "Set advertise uuids" },
+	{ "set-advertise-service", "[uuid][data=[xx xx ...]",
+			cmd_set_advertise_service,
+			"Set advertise service data" },
+	{ "set-advertise-manufacturer", "[id][data=[xx xx ...]",
+			cmd_set_advertise_manufacturer,
+			"Set advertise manufacturer data" },
+	{ "set-advertise-tx-power", "<on/off>",
+			cmd_set_advertise_tx_power,
+			"Enable/disable TX power to be advertised" },
+	{ "set-scan-filter-uuids", "[uuid1 uuid2 ...]",
+			cmd_set_scan_filter_uuids, "Set scan filter uuids" },
+	{ "set-scan-filter-rssi", "[rssi]", cmd_set_scan_filter_rssi,
+				"Set scan filter rssi, and clears pathloss" },
+	{ "set-scan-filter-pathloss", "[pathloss]",
+						cmd_set_scan_filter_pathloss,
+				"Set scan filter pathloss, and clears rssi" },
+	{ "set-scan-filter-transport", "[transport]",
+		cmd_set_scan_filter_transport, "Set scan filter transport" },
+	{ "set-scan-filter-clear", "", cmd_set_scan_filter_clear,
+						"Clears discovery filter." },*/
+	{ "scan",         "<on/off>", cmd_scan, "Scan for devices" },
+	{ "info",         "[dev]",    cmd_info, "Device information",
+							dev_generator },
+	/*{ "pair",         "[dev]",    cmd_pair, "Pair with device",
+							dev_generator },
+	{ "trust",        "[dev]",    cmd_trust, "Trust device",
+							dev_generator },
+	{ "untrust",      "[dev]",    cmd_untrust, "Untrust device",
+							dev_generator },
+	{ "block",        "[dev]",    cmd_block, "Block device",
+								dev_generator },
+	{ "unblock",      "[dev]",    cmd_unblock, "Unblock device",
+								dev_generator },*/
+	{ "remove",       "<dev>",    cmd_remove, "Remove device",
+							dev_generator },
+	/*{ "connect",      "<dev>",    cmd_connect, "Connect device",
+							dev_generator },
+	{ "disconnect",   "[dev]",    cmd_disconn, "Disconnect device",
+							dev_generator },
+	{ "list-attributes", "[dev]", cmd_list_attributes, "List attributes",
+							dev_generator },
+	{ "set-alias",    "<alias>",  cmd_set_alias, "Set device alias" },
+	{ "select-attribute", "<attribute>",  cmd_select_attribute,
+				"Select attribute", attribute_generator },
+	{ "attribute-info", "[attribute]",  cmd_attribute_info,
+				"Select attribute", attribute_generator },
+	{ "read",         NULL,       cmd_read, "Read attribute value" },
+	{ "write",        "<data=[xx xx ...]>", cmd_write,
+						"Write attribute value" },
+	{ "notify",       "<on/off>", cmd_notify, "Notify attribute value" },
+	{ "register-profile", "<UUID ...>", cmd_register_profile,
+						"Register profile to connect" },
+	{ "unregister-profile", NULL, cmd_unregister_profile,
+						"Unregister profile" },*/
+	{ "version",      NULL,       cmd_version, "Display version" },
+	{ "quit",         NULL,       cmd_quit, "Quit program" },
+	{ "exit",         NULL,       cmd_quit },
+	{ "help" },
+	{ }
+};
+
+static char *cmd_generator(const char *text, int state)
+{
+	static int index, len;
+	const char *cmd;
+
+	if (!state) {
+		index = 0;
+		len = strlen(text);
+	}
+
+	while ((cmd = cmd_table[index].cmd)) {
+		index++;
+
+		if (!strncmp(cmd, text, len))
+			return strdup(cmd);
+	}
+
+	return NULL;
+}
+
+static char **cmd_completion(const char *text, int start, int end)
+{
+	char **matches = NULL;
+
+	if (agent_completion() == TRUE) {
+		rl_attempted_completion_over = 1;
+		return NULL;
+	}
+
+	if (start > 0) {
+		int i;
+
+		for (i = 0; cmd_table[i].cmd; i++) {
+			if (strncmp(cmd_table[i].cmd,
+					rl_line_buffer, start - 1))
+				continue;
+
+			if (!cmd_table[i].gen)
+				continue;
+
+			rl_completion_display_matches_hook = cmd_table[i].disp;
+			matches = rl_completion_matches(text, cmd_table[i].gen);
+			break;
+		}
+	} else {
+		rl_completion_display_matches_hook = NULL;
+		matches = rl_completion_matches(text, cmd_generator);
+	}
+
+	if (!matches)
+		rl_attempted_completion_over = 1;
+
+	return matches;
+}
+
+static void rl_handler(char *input)
+{
+	char *cmd, *arg;
+	int i;
+
+	if (!input) {
+		rl_insert_text("quit");
+		rl_redisplay();
+		rl_crlf();
+		g_main_loop_quit(main_loop);
+		return;
+	}
+
+	if (!strlen(input))
+		goto done;
+
+	if (agent_input(dbus_conn, input) == TRUE)
+		goto done;
+
+	add_history(input);
+
+	cmd = strtok_r(input, " ", &arg);
+	if (!cmd)
+		goto done;
+
+	if (arg) {
+		int len = strlen(arg);
+		if (len > 0 && arg[len - 1] == ' ')
+			arg[len - 1] = '\0';
+	}
+
+	for (i = 0; cmd_table[i].cmd; i++) {
+		if (strcmp(cmd, cmd_table[i].cmd))
+			continue;
+
+		if (cmd_table[i].func) {
+			cmd_table[i].func(arg);
+			goto done;
+		}
+	}
+
+	if (strcmp(cmd, "help")) {
+		printf("Invalid command\n");
+		goto done;
+	}
+
+	printf("Available commands:\n");
+
+	for (i = 0; cmd_table[i].cmd; i++) {
+		if (cmd_table[i].desc)
+			printf("  %s %-*s %s\n", cmd_table[i].cmd,
+					(int)(25 - strlen(cmd_table[i].cmd)),
+					cmd_table[i].arg ? : "",
+					cmd_table[i].desc ? : "");
+	}
+
+done:
+	free(input);
+}
+
+static gboolean signal_handler(GIOChannel *channel, GIOCondition condition,
+							gpointer user_data)
+{
+	static bool terminated = false;
+	struct signalfd_siginfo si;
+	ssize_t result;
+	int fd;
+
+	if (condition & (G_IO_NVAL | G_IO_ERR | G_IO_HUP)) {
+		g_main_loop_quit(main_loop);
+		return FALSE;
+	}
+
+	fd = g_io_channel_unix_get_fd(channel);
+
+	result = read(fd, &si, sizeof(si));
+	if (result != sizeof(si))
+		return FALSE;
+
+	switch (si.ssi_signo) {
+	case SIGINT:
+		if (input) {
+			rl_replace_line("", 0);
+			rl_crlf();
+			rl_on_new_line();
+			rl_redisplay();
+			break;
+		}
+
+		/*
+		 * If input was not yet setup up that means signal was received
+		 * while daemon was not yet running. Since user is not able
+		 * to terminate client by CTRL-D or typing exit treat this as
+		 * exit and fall through.
+		 */
+	case SIGTERM:
+		if (!terminated) {
+			rl_replace_line("", 0);
+			rl_crlf();
+			g_main_loop_quit(main_loop);
+		}
+
+		terminated = true;
+		break;
+	}
+
+	return TRUE;
+}
+
+static guint setup_signalfd(void)
+{
+	GIOChannel *channel;
+	guint source;
+	sigset_t mask;
+	int fd;
+
+	sigemptyset(&mask);
+	sigaddset(&mask, SIGINT);
+	sigaddset(&mask, SIGTERM);
+
+	if (sigprocmask(SIG_BLOCK, &mask, NULL) < 0) {
+		perror("Failed to set signal mask");
+		return 0;
+	}
+
+	fd = signalfd(-1, &mask, 0);
+	if (fd < 0) {
+		perror("Failed to create signal descriptor");
+		return 0;
+	}
+
+	channel = g_io_channel_unix_new(fd);
+
+	g_io_channel_set_close_on_unref(channel, TRUE);
+	g_io_channel_set_encoding(channel, NULL, NULL);
+	g_io_channel_set_buffered(channel, FALSE);
+
+	source = g_io_add_watch(channel,
+				G_IO_IN | G_IO_HUP | G_IO_ERR | G_IO_NVAL,
+				signal_handler, NULL);
+
+	g_io_channel_unref(channel);
+
+	return source;
+}
+
+static gboolean option_version = FALSE;
+
+static gboolean parse_agent(const char *key, const char *value,
+					gpointer user_data, GError **error)
+{
+	if (value)
+		auto_register_agent = g_strdup(value);
+	else
+		auto_register_agent = g_strdup("");
+
+	return TRUE;
+}
+
+static GOptionEntry options[] = {
+	{ "version", 'v', 0, G_OPTION_ARG_NONE, &option_version,
+				"Show version information and exit" },
+	{ "agent", 'a', G_OPTION_FLAG_OPTIONAL_ARG,
+				G_OPTION_ARG_CALLBACK, parse_agent,
+				"Register agent handler", "CAPABILITY" },
+	{ NULL },
+};
+
+static void client_ready(GDBusClient *client, void *user_data)
+{
+	if (!input)
+		input = setup_standard_input();
+}
+
+int main(int argc, char *argv[])
+{
+	GOptionContext *context;
+	GError *error = NULL;
+	GDBusClient *client;
+	guint signal;
+
+	context = g_option_context_new(NULL);
+	g_option_context_add_main_entries(context, options, NULL);
+
+	if (g_option_context_parse(context, &argc, &argv, &error) == FALSE) {
+		if (error != NULL) {
+			g_printerr("%s\n", error->message);
+			g_error_free(error);
+		} else
+			g_printerr("An unknown error occurred\n");
+		exit(1);
+	}
+
+	g_option_context_free(context);
+
+	if (option_version == TRUE) {
+		printf("%s\n", VERSION);
+		exit(0);
+	}
+
+	main_loop = g_main_loop_new(NULL, FALSE);
+	dbus_conn = g_dbus_setup_bus(DBUS_BUS_SYSTEM, NULL, NULL);
+
+	setlinebuf(stdout);
+	rl_attempted_completion_function = cmd_completion;
+
+	rl_erase_empty_line = 1;
+	rl_callback_handler_install(NULL, rl_handler);
+
+	rl_set_prompt(PROMPT_OFF);
+	rl_redisplay();
+
+	signal = setup_signalfd();
+	client = g_dbus_client_new(dbus_conn, "org.bluez", "/org/bluez");
+
+	g_dbus_client_set_connect_watch(client, connect_handler, NULL);
+	g_dbus_client_set_disconnect_watch(client, disconnect_handler, NULL);
+	g_dbus_client_set_signal_watch(client, message_handler, NULL);
+
+	g_dbus_client_set_proxy_handlers(client, proxy_added, proxy_removed,
+							property_changed, NULL);
+
+	g_dbus_client_set_ready_watch(client, client_ready, NULL);
+
+	g_main_loop_run(main_loop);
+
+	g_dbus_client_unref(client);
+	g_source_remove(signal);
+	if (input > 0)
+		g_source_remove(input);
+
+	rl_message("");
+	rl_callback_handler_remove();
+
+	dbus_connection_unref(dbus_conn);
+	g_main_loop_unref(main_loop);
+
+	g_list_free_full(ctrl_list, proxy_leak);
+
+	g_free(auto_register_agent);
+
+	return 0;
+}
diff -ruN --new-file bluez_utils-5.43/Makefile.in bluez_utils-5.43_mod_2/Makefile.in
--- bluez_utils-5.43/Makefile.in	2017-06-14 18:25:33.843679806 +0530
+++ bluez_utils-5.43_mod_2/Makefile.in	2019-09-03 14:59:41.924975978 +0530
@@ -83,8 +83,8 @@
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
-bin_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2) $(am__EXEEXT_3) \
-	$(am__EXEEXT_4)
+bin_PROGRAMS = tools/btgatt-server$(EXTEXT) tools/hciattach$(EXEEXT) tools/hciconfig$(EXEEXT) tools/hcitool$(EXEEXT) tools/bdaddr$(EXTEXT) tools/rfcomm$(EXTEXT) \
+               tools/sdptool$(EXTEXT) client/bluetoothctl$(EXTEXT) client/ltrx_beacon_scanner$(EXTEXT) attrib/ltrx_gatttool$(EXTEXT)
 noinst_PROGRAMS = $(am__EXEEXT_5) $(am__EXEEXT_6) $(am__EXEEXT_7) \
 	$(am__EXEEXT_8) $(am__EXEEXT_11)
 libexec_PROGRAMS = src/bluetoothd$(EXEEXT) obexd/src/obexd$(EXEEXT)
@@ -118,7 +118,7 @@
 
 @SIXAXIS_TRUE@am__append_10 = plugins/sixaxis.la
 @MAINTAINER_MODE_TRUE@am__append_11 = plugins/external-dummy.la
-@CLIENT_TRUE@am__append_12 = client/bluetoothctl
+@CLIENT_TRUE@am__append_12 = client/bluetoothctl client/ltrx_beacon_scanner lib/libltrx-beacon.so
 @MONITOR_TRUE@am__append_13 = monitor/btmon
 @EXPERIMENTAL_TRUE@am__append_14 = emulator/btvirt emulator/b1ee \
 @EXPERIMENTAL_TRUE@	emulator/hfp peripheral/btsensor tools/3dsp \
@@ -159,7 +159,7 @@
 @EXPERIMENTAL_TRUE@am__append_21 = tools/btattach.1
 @EXPERIMENTAL_TRUE@am__append_22 = tools/bdaddr.1
 @EXPERIMENTAL_FALSE@am__append_23 = tools/btattach.1
-@READLINE_TRUE@am__append_24 = attrib/gatttool tools/btmgmt \
+@READLINE_TRUE@am__append_24 = attrib/gatttool attrib/ltrx_gatttool lib/libltrx-gattclient.so tools/btmgmt \
 @READLINE_TRUE@			tools/obex-client-tool tools/obex-server-tool \
 @READLINE_TRUE@			tools/bluetooth-player tools/obexctl
 
@@ -397,7 +397,8 @@
 	src/shared/mainloop.lo
 src_libshared_mainloop_la_OBJECTS =  \
 	$(am_src_libshared_mainloop_la_OBJECTS)
-@CLIENT_TRUE@am__EXEEXT_1 = client/bluetoothctl$(EXEEXT)
+@CLIENT_TRUE@am__EXEEXT_1 = client/bluetoothctl$(EXEEXT) client/ltrx_beacon_scanner$(EXTEXT) \
+@EXPERIMENTAL_TRUE@    tools/btgatt-server$(EXTEXT)
 @MONITOR_TRUE@am__EXEEXT_2 = monitor/btmon$(EXEEXT)
 @TOOLS_TRUE@am__EXEEXT_3 = tools/hciattach$(EXEEXT) \
 @TOOLS_TRUE@	tools/hciconfig$(EXEEXT) tools/hcitool$(EXEEXT) \
@@ -445,7 +446,7 @@
 @EXPERIMENTAL_TRUE@	tools/btgatt-server$(EXEEXT) \
 @EXPERIMENTAL_TRUE@	tools/test-runner$(EXEEXT) \
 @EXPERIMENTAL_TRUE@	tools/check-selftest$(EXEEXT)
-@READLINE_TRUE@am__EXEEXT_6 = attrib/gatttool$(EXEEXT) \
+@READLINE_TRUE@am__EXEEXT_6 = attrib/gatttool$(EXEEXT) attrib/ltrx_gatttool$(EXEEXT)\
 @READLINE_TRUE@	tools/btmgmt$(EXEEXT) \
 @READLINE_TRUE@	tools/obex-client-tool$(EXEEXT) \
 @READLINE_TRUE@	tools/obex-server-tool$(EXEEXT) \
@@ -686,17 +687,56 @@
 @READLINE_TRUE@attrib_gatttool_DEPENDENCIES =  \
 @READLINE_TRUE@	lib/libbluetooth-internal.la \
 @READLINE_TRUE@	src/libshared-glib.la
+am__attrib_ltrx_gatttool_SOURCES_DIST = attrib/ltrx_gatttool.c attrib/att.c \
+	attrib/gatt.c attrib/gattrib.c btio/btio.c attrib/gatttool.h \
+	attrib/ltrx_interactive.c attrib/utils.c src/log.c client/display.c \
+	client/display.h
+@READLINE_TRUE@am_attrib_ltrx_gatttool_OBJECTS = attrib/ltrx_gatttool.$(OBJEXT) \
+@READLINE_TRUE@ attrib/att.$(OBJEXT) attrib/gatt.$(OBJEXT) \
+@READLINE_TRUE@ attrib/gattrib.$(OBJEXT) btio/btio.$(OBJEXT) \
+@READLINE_TRUE@ attrib/ltrx_interactive.$(OBJEXT) \
+@READLINE_TRUE@ attrib/utils.$(OBJEXT) src/log.$(OBJEXT) \
+@READLINE_TRUE@ client/display.$(OBJEXT)
+@READLINE_TRUE@tools_ltrx_gattclient_lib_OBJECTS = attrib/att.$(OBJEXT) \
+@READLINE_TRUE@	attrib/gatt.$(OBJEXT) \
+@READLINE_TRUE@	attrib/gattrib.$(OBJEXT) btio/btio.$(OBJEXT) \
+@READLINE_TRUE@	attrib/ltrx_interactive.$(OBJEXT) attrib/utils.$(OBJEXT) \
+@READLINE_TRUE@	src/shared/att.$(OBJEXT) src/shared/queue.$(OBJEXT) src/shared/util.$(OBJEXT) src/shared/crypto.$(OBJEXT) \
+@READLINE_TRUE@	lib/hci.$(OBJEXT) lib/sdp.$(OBJEXT) lib/uuid.$(OBJEXT) lib/bluetooth.$(OBJEXT) \
+@READLINE_TRUE@	src/shared/io-glib.$(OBJEXT) src/shared/timeout-glib.$(OBJEXT) src/log.$(OBJEXT) \
+@READLINE_TRUE@	client/display.$(OBJEXT) \
+@READLINE_TRUE@	gdbus/client.o gdbus/mainloop.o gdbus/object.o gdbus/polkit.o gdbus/watch.o
+attrib_ltrx_gatttool_OBJECTS = $(am_attrib_ltrx_gatttool_OBJECTS)
+@READLINE_TRUE@attrib_ltrx_gatttool_DEPENDENCIES =  \
+@READLINE_TRUE@ lib/libbluetooth-internal.la \
+@READLINE_TRUE@ src/libshared-glib.la
 am__client_bluetoothctl_SOURCES_DIST = client/main.c client/display.h \
 	client/display.c client/agent.h client/agent.c \
 	client/advertising.h client/advertising.c client/gatt.h \
 	client/gatt.c monitor/uuid.h monitor/uuid.c
+am__client_ltrx_beacon_scanner_SOURCES_DIST = client/ltrx_beacon_scanner.c client/display.h \
+	client/display.c client/agent.h client/agent.c \
+	client/advertising.h client/advertising.c client/gatt.h \
+	client/gatt.c monitor/uuid.h monitor/uuid.c
 @CLIENT_TRUE@am_client_bluetoothctl_OBJECTS = client/main.$(OBJEXT) \
 @CLIENT_TRUE@	client/display.$(OBJEXT) client/agent.$(OBJEXT) \
 @CLIENT_TRUE@	client/advertising.$(OBJEXT) \
 @CLIENT_TRUE@	client/gatt.$(OBJEXT) monitor/uuid.$(OBJEXT)
+@CLIENT_TRUE@am_client_ltrx_beacon_scanner_OBJECTS = client/ltrx_beacon_scanner.$(OBJEXT) \
+@CLIENT_TRUE@	client/display.$(OBJEXT) client/agent.$(OBJEXT) \
+@CLIENT_TRUE@	client/advertising.$(OBJEXT) \
+@CLIENT_TRUE@	client/gatt.$(OBJEXT) monitor/uuid.$(OBJEXT)
 client_bluetoothctl_OBJECTS = $(am_client_bluetoothctl_OBJECTS)
+client_ltrx_beacon_scanner_OBJECTS = $(am_client_ltrx_beacon_scanner_OBJECTS)
 @CLIENT_TRUE@client_bluetoothctl_DEPENDENCIES =  \
 @CLIENT_TRUE@	gdbus/libgdbus-internal.la
+@CLIENT_TRUE@client_ltrx_beacon_scanner_DEPENDENCIES =  \
+@CLIENT_TRUE@	gdbus/libgdbus-internal.la
+@CLIENT_TRUE@tools_ltrx_beacon_lib_OBJECTS = client/display.$(OBJEXT) \
+@CLIENT_TRUE@	client/agent.$(OBJEXT) \
+@CLIENT_TRUE@	client/advertising.$(OBJEXT) \
+@CLIENT_TRUE@	client/gatt.$(OBJEXT) monitor/uuid.$(OBJEXT) \
+@CLIENT_TRUE@	gdbus/client.o gdbus/mainloop.o gdbus/object.o gdbus/polkit.o gdbus/watch.o
 am__emulator_b1ee_SOURCES_DIST = emulator/b1ee.c
 @EXPERIMENTAL_TRUE@am_emulator_b1ee_OBJECTS = emulator/b1ee.$(OBJEXT)
 emulator_b1ee_OBJECTS = $(am_emulator_b1ee_OBJECTS)
@@ -925,13 +965,13 @@
 	src/rfkill.c src/hcid.h src/sdpd.h src/sdpd-server.c \
 	src/sdpd-request.c src/sdpd-service.c src/sdpd-database.c \
 	src/attrib-server.h src/attrib-server.c src/gatt-database.h \
-	src/gatt-database.c src/sdp-xml.h src/sdp-xml.c \
+	src/gatt_services.h src/ltrx_device_info_services.c src/ltrx_device_configuration_service.c src/gatt-database.c src/sdp-xml.h src/sdp-xml.c \
 	src/sdp-client.h src/sdp-client.c src/textfile.h \
 	src/textfile.c src/uuid-helper.h src/uuid-helper.c \
 	src/uinput.h src/plugin.h src/plugin.c src/storage.h \
 	src/storage.c src/advertising.h src/advertising.c src/agent.h \
 	src/agent.c src/error.h src/error.c src/adapter.h \
-	src/adapter.c src/profile.h src/profile.c src/service.h \
+	src/ltrx_le_advertising.h src/ltrx_le_advertising.c src/adapter.c src/profile.h src/profile.c src/service.h \
 	src/service.c src/gatt-client.h src/gatt-client.c src/device.h \
 	src/device.c src/dbus-common.c src/dbus-common.h src/eir.h \
 	src/eir.c
@@ -994,7 +1034,8 @@
 	src/bluetoothd-sdpd-service.$(OBJEXT) \
 	src/bluetoothd-sdpd-database.$(OBJEXT) \
 	src/bluetoothd-attrib-server.$(OBJEXT) \
-	src/bluetoothd-gatt-database.$(OBJEXT) \
+	src/bluetoothd-ltrx_device_info_service.$(OBJEXT) \
+        src/bluetoothd-ltrx_device_configuration_service.$(OBJEXT) \
 	src/bluetoothd-sdp-xml.$(OBJEXT) \
 	src/bluetoothd-sdp-client.$(OBJEXT) \
 	src/bluetoothd-textfile.$(OBJEXT) \
@@ -1003,12 +1044,14 @@
 	src/bluetoothd-storage.$(OBJEXT) \
 	src/bluetoothd-advertising.$(OBJEXT) \
 	src/bluetoothd-agent.$(OBJEXT) src/bluetoothd-error.$(OBJEXT) \
+	src/bluetoothd-ltrx_le_advertising.$(OBJEXT) \
 	src/bluetoothd-adapter.$(OBJEXT) \
 	src/bluetoothd-profile.$(OBJEXT) \
 	src/bluetoothd-service.$(OBJEXT) \
 	src/bluetoothd-gatt-client.$(OBJEXT) \
 	src/bluetoothd-device.$(OBJEXT) \
 	src/bluetoothd-dbus-common.$(OBJEXT) \
+	src/bluetoothd-gatt-database.$(OBJEXT) \
 	src/bluetoothd-eir.$(OBJEXT)
 nodist_src_bluetoothd_OBJECTS = $(am__objects_10)
 src_bluetoothd_OBJECTS = $(am_src_bluetoothd_OBJECTS) \
@@ -1612,7 +1655,7 @@
 	$(android_bluetoothd_snoop_SOURCES) $(android_haltest_SOURCES) \
 	$(android_ipc_tester_SOURCES) \
 	$(android_system_emulator_SOURCES) $(android_test_ipc_SOURCES) \
-	$(attrib_gatttool_SOURCES) $(client_bluetoothctl_SOURCES) \
+	$(attrib_gatttool_SOURCES) $(attrib_ltrx_gatttool_SOURCES) $(client_bluetoothctl_SOURCES) $(client_ltrx_beacon_scanner_SOURCES) \
 	$(emulator_b1ee_SOURCES) $(emulator_btvirt_SOURCES) \
 	$(emulator_hfp_SOURCES) $(monitor_btmon_SOURCES) \
 	$(obexd_src_obexd_SOURCES) $(nodist_obexd_src_obexd_SOURCES) \
@@ -1680,7 +1723,9 @@
 	$(am__android_system_emulator_SOURCES_DIST) \
 	$(am__android_test_ipc_SOURCES_DIST) \
 	$(am__attrib_gatttool_SOURCES_DIST) \
+	$(am__attrib_ltrx_gatttool_SOURCES_DIST) \
 	$(am__client_bluetoothctl_SOURCES_DIST) \
+	$(am__client_ltrx_beacon_scanner_SOURCES_DIST) \
 	$(am__emulator_b1ee_SOURCES_DIST) \
 	$(am__emulator_btvirt_SOURCES_DIST) \
 	$(am__emulator_hfp_SOURCES_DIST) \
@@ -2126,7 +2171,7 @@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 AM_MAKEFLAGS = --no-print-directory
-lib_LTLIBRARIES = $(am__append_2)
+lib_LTLIBRARIES = $(am__append_2) lib/libltrx-beacon.so lib/libltrx-gattclient.so
 noinst_LIBRARIES = $(am__append_7)
 noinst_LTLIBRARIES = lib/libbluetooth-internal.la \
 	gdbus/libgdbus-internal.la src/libshared-glib.la \
@@ -2336,7 +2381,7 @@
 			src/sdpd-server.c src/sdpd-request.c \
 			src/sdpd-service.c src/sdpd-database.c \
 			src/attrib-server.h src/attrib-server.c \
-			src/gatt-database.h src/gatt-database.c \
+			src/gatt-database.h src/gatt_services.h src/ltrx_device_info_services.c src/ltrx_device_configuration_service.c src/gatt-database.c \
 			src/sdp-xml.h src/sdp-xml.c \
 			src/sdp-client.h src/sdp-client.c \
 			src/textfile.h src/textfile.c \
@@ -2347,7 +2392,7 @@
 			src/advertising.h src/advertising.c \
 			src/agent.h src/agent.c \
 			src/error.h src/error.c \
-			src/adapter.h src/adapter.c \
+			src/adapter.h src/ltrx_le_advertising.h src/ltrx_le_advertising.c src/adapter.c \
 			src/profile.h src/profile.c \
 			src/service.h src/service.c \
 			src/gatt-client.h src/gatt-client.c \
@@ -2408,6 +2453,17 @@
 @CLIENT_TRUE@client_bluetoothctl_LDADD = gdbus/libgdbus-internal.la @GLIB_LIBS@ @DBUS_LIBS@ \
 @CLIENT_TRUE@				-lreadline
 
+@CLIENT_TRUE@client_ltrx_beacon_scanner_SOURCES = client/ltrx_beacon_scanner.c \
+@CLIENT_TRUE@					client/display.h client/display.c \
+@CLIENT_TRUE@					client/agent.h client/agent.c \
+@CLIENT_TRUE@					client/advertising.h \
+@CLIENT_TRUE@					client/advertising.c \
+@CLIENT_TRUE@					client/gatt.h client/gatt.c \
+@CLIENT_TRUE@					monitor/uuid.h monitor/uuid.c
+
+@CLIENT_TRUE@client_ltrx_beacon_scanner_LDADD = gdbus/libgdbus-internal.la @GLIB_LIBS@ @DBUS_LIBS@ \
+@CLIENT_TRUE@				-lreadline
+
 @MONITOR_TRUE@monitor_btmon_SOURCES = monitor/main.c monitor/bt.h \
 @MONITOR_TRUE@				monitor/display.h monitor/display.c \
 @MONITOR_TRUE@				monitor/hcidump.h monitor/hcidump.c \
@@ -2656,9 +2712,18 @@
 @READLINE_TRUE@				attrib/utils.c src/log.c client/display.c \
 @READLINE_TRUE@				client/display.h
 
+@READLINE_TRUE@attrib_ltrx_gatttool_SOURCES = attrib/ltrx_gatttool.c attrib/att.c attrib/gatt.c \
+@READLINE_TRUE@				attrib/gattrib.c btio/btio.c \
+@READLINE_TRUE@				attrib/gatttool.h attrib/ltrx_interactive.c \
+@READLINE_TRUE@				attrib/utils.c src/log.c client/display.c \
+@READLINE_TRUE@				client/display.h
+
 @READLINE_TRUE@attrib_gatttool_LDADD = lib/libbluetooth-internal.la \
 @READLINE_TRUE@			src/libshared-glib.la @GLIB_LIBS@ -lreadline
 
+@READLINE_TRUE@attrib_ltrx_gatttool_LDADD = lib/libbluetooth-internal.la \
+@READLINE_TRUE@			src/libshared-glib.la @GLIB_LIBS@ -lreadline
+
 @READLINE_TRUE@tools_obex_client_tool_SOURCES = $(gobex_sources) $(btio_sources) \
 @READLINE_TRUE@						tools/obex-client-tool.c
 
@@ -3929,6 +3994,10 @@
 	attrib/$(DEPDIR)/$(am__dirstamp)
 attrib/utils.$(OBJEXT): attrib/$(am__dirstamp) \
 	attrib/$(DEPDIR)/$(am__dirstamp)
+attrib/ltrx_gatttool.$(OBJEXT): attrib/$(am__dirstamp) \
+	attrib/$(DEPDIR)/$(am__dirstamp)
+attrib/ltrx_interactive.$(OBJEXT): attrib/$(am__dirstamp) \
+	attrib/$(DEPDIR)/$(am__dirstamp)
 client/$(am__dirstamp):
 	@$(MKDIR_P) client
 	@: > client/$(am__dirstamp)
@@ -3941,6 +4010,13 @@
 attrib/gatttool$(EXEEXT): $(attrib_gatttool_OBJECTS) $(attrib_gatttool_DEPENDENCIES) $(EXTRA_attrib_gatttool_DEPENDENCIES) attrib/$(am__dirstamp)
 	@rm -f attrib/gatttool$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(attrib_gatttool_OBJECTS) $(attrib_gatttool_LDADD) $(LIBS)
+attrib/ltrx_gatttool$(EXEEXT): $(attrib_ltrx_gatttool_OBJECTS) $(attrib_ltrx_gatttool_DEPENDENCIES) $(EXTRA_attrib_ltrx_gatttool_DEPENDENCIES) attrib/$(am__dirstamp)
+	@rm -f attrib/ltrx_gatttool$(EXEEXT)
+	$(AM_V_CCLD)$(LINK) $(attrib_ltrx_gatttool_OBJECTS) $(attrib_ltrx_gatttool_LDADD) $(LIBS)
+
+lib/libltrx-gattclient.so: $(tools_ltrx_gattclient_lib_OBJECTS) attrib/gatttool$(EXEEXT)
+	@rm -f lib/libltrx-gattclient.so
+	$(CCLD) -shared -o lib/libltrx-gattclient.so $(tools_ltrx_gattclient_lib_OBJECTS) -lglib-2.0 -ldbus-1 -lreadline
 client/main.$(OBJEXT): client/$(am__dirstamp) \
 	client/$(DEPDIR)/$(am__dirstamp)
 client/agent.$(OBJEXT): client/$(am__dirstamp) \
@@ -3961,6 +4037,15 @@
 client/bluetoothctl$(EXEEXT): $(client_bluetoothctl_OBJECTS) $(client_bluetoothctl_DEPENDENCIES) $(EXTRA_client_bluetoothctl_DEPENDENCIES) client/$(am__dirstamp)
 	@rm -f client/bluetoothctl$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(client_bluetoothctl_OBJECTS) $(client_bluetoothctl_LDADD) $(LIBS)
+
+client/ltrx_beacon_scanner$(EXEEXT): $(client_ltrx_beacon_scanner_OBJECTS) $(client_ltrx_beacon_scanner_DEPENDENCIES) $(EXTRA_client_ltrx_beacon_scanner_DEPENDENCIES) client/$(am__dirstamp)
+	@rm -f client/ltrx_beacon_scanner$(EXEEXT)
+	$(AM_V_CCLD)$(LINK) $(client_ltrx_beacon_scanner_OBJECTS) $(client_ltrx_beacon_scanner_LDADD) $(LIBS)
+
+lib/libltrx-beacon.so: $(tools_ltrx_beacon_lib_OBJECTS) client/bluetoothctl$(EXEEXT)
+	@rm -f lib/libltrx-beacon.so
+	$(CCLD) -shared -o lib/libltrx-beacon.so $(tools_ltrx_beacon_lib_OBJECTS) -lglib-2.0 -ldbus-1 -lreadline
+
 emulator/b1ee.$(OBJEXT): emulator/$(am__dirstamp) \
 	emulator/$(DEPDIR)/$(am__dirstamp)
 
@@ -4368,6 +4453,10 @@
 	src/$(DEPDIR)/$(am__dirstamp)
 src/bluetoothd-attrib-server.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
+src/bluetoothd-ltrx_device_info_service.$(OBJEXT): src/$(am__dirstamp) \
+	src/$(DEPDIR)/$(am__dirstamp)
+src/bluetoothd-ltrx_device_configuration_service.$(OBJEXT): src/$(am__dirstamp) \
+	src/$(DEPDIR)/$(am__dirstamp)
 src/bluetoothd-gatt-database.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
 src/bluetoothd-sdp-xml.$(OBJEXT): src/$(am__dirstamp) \
@@ -4388,6 +4477,8 @@
 	src/$(DEPDIR)/$(am__dirstamp)
 src/bluetoothd-error.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
+src/bluetoothd-ltrx_le_advertising.$(OBJEXT): src/$(am__dirstamp) \
+	src/$(DEPDIR)/$(am__dirstamp)
 src/bluetoothd-adapter.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
 src/bluetoothd-profile.$(OBJEXT): src/$(am__dirstamp) \
@@ -4405,7 +4496,7 @@
 
 src/bluetoothd$(EXEEXT): $(src_bluetoothd_OBJECTS) $(src_bluetoothd_DEPENDENCIES) $(EXTRA_src_bluetoothd_DEPENDENCIES) src/$(am__dirstamp)
 	@rm -f src/bluetoothd$(EXEEXT)
-	$(AM_V_CCLD)$(src_bluetoothd_LINK) $(src_bluetoothd_OBJECTS) $(src_bluetoothd_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(src_bluetoothd_LINK) $(src_bluetoothd_OBJECTS) $(src_bluetoothd_LDADD) $(LIBS) -lpthread
 tools/$(am__dirstamp):
 	@$(MKDIR_P) tools
 	@: > tools/$(am__dirstamp)
@@ -4506,7 +4597,7 @@
 
 tools/btgatt-server$(EXEEXT): $(tools_btgatt_server_OBJECTS) $(tools_btgatt_server_DEPENDENCIES) $(EXTRA_tools_btgatt_server_DEPENDENCIES) tools/$(am__dirstamp)
 	@rm -f tools/btgatt-server$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(tools_btgatt_server_OBJECTS) $(tools_btgatt_server_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(tools_btgatt_server_OBJECTS) $(tools_btgatt_server_LDADD) $(LIBS) -lpthread
 tools/btinfo.$(OBJEXT): tools/$(am__dirstamp) \
 	tools/$(DEPDIR)/$(am__dirstamp)
 
@@ -5181,6 +5272,8 @@
 @AMDEP_TRUE@@am__include@ @am__quote@attrib/$(DEPDIR)/gattrib.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@attrib/$(DEPDIR)/gatttool.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@attrib/$(DEPDIR)/interactive.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@attrib/$(DEPDIR)/ltrx_gatttool.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@attrib/$(DEPDIR)/ltrx_interactive.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@attrib/$(DEPDIR)/utils.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@btio/$(DEPDIR)/android_avdtptest-btio.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@btio/$(DEPDIR)/bluetoothd-btio.Po@am__quote@
@@ -5352,6 +5445,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@profiles/scanparam/$(DEPDIR)/bluetoothd-scpp.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@profiles/scanparam/$(DEPDIR)/scpp.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/android_avdtptest-log.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bluetoothd-ltrx_le_advertising.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bluetoothd-adapter.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bluetoothd-advertising.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bluetoothd-agent.Po@am__quote@
@@ -5362,6 +5456,8 @@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bluetoothd-eir.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bluetoothd-error.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bluetoothd-gatt-client.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bluetoothd-ltrx_device_info_service.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bluetoothd-ltrx_device_configuration_service.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bluetoothd-gatt-database.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bluetoothd-log.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bluetoothd-main.Po@am__quote@
@@ -7761,8 +7857,22 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bluetoothd_CFLAGS) $(CFLAGS) -c -o src/bluetoothd-attrib-server.obj `if test -f 'src/attrib-server.c'; then $(CYGPATH_W) 'src/attrib-server.c'; else $(CYGPATH_W) '$(srcdir)/src/attrib-server.c'; fi`
 
+src/bluetoothd-ltrx_device_info_service.o: src/ltrx_device_info_service.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bluetoothd_CFLAGS) $(CFLAGS) -MT src/bluetoothd-ltrx_device_info_service.o -MD -MP -MF src/$(DEPDIR)/bluetoothd-ltrx_device_info_service.Tpo -c -o src/bluetoothd-ltrx_device_info_service.o `test -f 'src/ltrx_device_info_service.c' || echo '$(srcdir)/'`src/ltrx_device_info_service.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/bluetoothd-ltrx_device_info_service.Tpo src/$(DEPDIR)/bluetoothd-ltrx_device_info_service.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/gatt-database.c' object='src/bluetoothd-gatt-database.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bluetoothd_CFLAGS) $(CFLAGS) -c -o src/bluetoothd-gatt-database.o `test -f 'src/gatt-database.c' || echo '$(srcdir)/'`src/gatt-database.c
+
+src/bluetoothd-ltrx_device_configuration_service.o: src/ltrx_device_configuration_service.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bluetoothd_CFLAGS) $(CFLAGS) -MT src/bluetoothd-ltrx_device_configuration_service.o -MD -MP -MF src/$(DEPDIR)/bluetoothd-ltrx_device_configuration_service.Tpo -c -o src/bluetoothd-ltrx_device_configuration_service.o `test -f 'src/ltrx_device_configuration_service.c' || echo '$(srcdir)/'`src/ltrx_device_configuration_service.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/bluetoothd-ltrx_device_configuration_service.Tpo src/$(DEPDIR)/bluetoothd-ltrx_device_configuration_service.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/gatt-database.c' object='src/bluetoothd-gatt-database.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@   $(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bluetoothd_CFLAGS) $(CFLAGS) -c -o src/bluetoothd-gatt-database.o `test -f 'src/gatt-database.c' || echo '$(srcdir)/'`src/gatt-database.c
+
 src/bluetoothd-gatt-database.o: src/gatt-database.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bluetoothd_CFLAGS) $(CFLAGS) -MT src/bluetoothd-gatt-database.o -MD -MP -MF src/$(DEPDIR)/bluetoothd-gatt-database.Tpo -c -o src/bluetoothd-gatt-database.o `test -f 'src/gatt-database.c' || echo '$(srcdir)/'`src/gatt-database.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bluetoothd_CFLAGS) $(CFLAGS) src/bluetoothd-ltrx_device_configuration_service.o src/bluetoothd-ltrx_device_info_service.o -MT src/bluetoothd-gatt-database.o src/bluetoothd-ltrx_device_configuration_service.o src/bluetoothd-ltrx_device_info_service.o -MD -MP -MF src/$(DEPDIR)/bluetoothd-gatt-database.Tpo -c -o src/bluetoothd-gatt-database.o `test -f 'src/gatt-database.c' || echo '$(srcdir)/'`src/gatt-database.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/bluetoothd-gatt-database.Tpo src/$(DEPDIR)/bluetoothd-gatt-database.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/gatt-database.c' object='src/bluetoothd-gatt-database.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
@@ -7901,6 +8011,13 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bluetoothd_CFLAGS) $(CFLAGS) -c -o src/bluetoothd-error.obj `if test -f 'src/error.c'; then $(CYGPATH_W) 'src/error.c'; else $(CYGPATH_W) '$(srcdir)/src/error.c'; fi`
 
+src/bluetoothd-ltrx_le_advertising.o: src/ltrx_le_advertising.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bluetoothd_CFLAGS) $(CFLAGS) -MT src/bluetoothd-ltrx_le_advertising.o -MD -MP -MF src/$(DEPDIR)/bluetoothd-ltrx_le_advertising.Tpo -c -o src/bluetoothd-ltrx_le_advertising.o `test -f 'src/ltrx_le_advertising.c' || echo '$(srcdir)/'`src/ltrx_le_advertising.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/bluetoothd-ltrx_le_advertising.Tpo src/$(DEPDIR)/bluetoothd-ltrx_le_advertising.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/ltrx_le_advertising.c' object='src/bluetoothd-ltrx_le_advertising.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@   $(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bluetoothd_CFLAGS) $(CFLAGS) -c -o src/bluetoothd-ltrx_le_advertising.o `test -f 'src/ltrx_le_advertising.c' || echo '$(srcdir)/'`src/ltrx_le_advertising.c
+
 src/bluetoothd-adapter.o: src/adapter.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bluetoothd_CFLAGS) $(CFLAGS) -MT src/bluetoothd-adapter.o -MD -MP -MF src/$(DEPDIR)/bluetoothd-adapter.Tpo -c -o src/bluetoothd-adapter.o `test -f 'src/adapter.c' || echo '$(srcdir)/'`src/adapter.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/bluetoothd-adapter.Tpo src/$(DEPDIR)/bluetoothd-adapter.Po
diff -ruN --new-file bluez_utils-5.43/src/adapter.c bluez_utils-5.43_mod_2/src/adapter.c
--- bluez_utils-5.43/src/adapter.c	2017-06-14 18:25:33.847679804 +0530
+++ bluez_utils-5.43_mod_2/src/adapter.c	2019-05-30 21:48:08.917491616 +0530
@@ -58,6 +58,7 @@
 #include "src/shared/queue.h"
 #include "src/shared/att.h"
 #include "src/shared/gatt-db.h"
+#include "src/ltrx_le_advertising_api.h"
 
 #include "hcid.h"
 #include "sdpd.h"
@@ -485,7 +486,7 @@
 	DBG("Changed settings: 0x%08x", changed_mask);
 
 	if (changed_mask & MGMT_SETTING_POWERED) {
-	        g_dbus_emit_property_changed(dbus_conn, adapter->path,
+		g_dbus_emit_property_changed(dbus_conn, adapter->path,
 					ADAPTER_INTERFACE, "Powered");
 
 		if (adapter->current_settings & MGMT_SETTING_POWERED) {
@@ -1192,7 +1193,15 @@
 	device = btd_adapter_find_device(adapter, addr, addr_type);
 	if (device)
 		return device;
+	
+	device = btd_adapter_find_device(adapter, addr,  BDADDR_LE_PUBLIC);
+	if (device)
+		return device;
 
+	device = btd_adapter_find_device(adapter, addr, BDADDR_BREDR);
+	if (device)
+		return device;
+	
 	return adapter_create_device(adapter, addr, addr_type);
 }
 
@@ -1449,7 +1458,7 @@
 	adapter->no_scan_restart_delay = !!adapter->current_discovery_filter;
 
 	DBG("adapter->current_discovery_filter == %d",
-	    !!adapter->current_discovery_filter);
+		!!adapter->current_discovery_filter);
 
 	new_type = get_scan_type(adapter);
 
@@ -1462,8 +1471,8 @@
 		 * then just keep it.
 		 */
 		if (!adapter->current_discovery_filter &&
-		    !adapter->filtered_discovery &&
-		    adapter->discovery_type == new_type) {
+			!adapter->filtered_discovery &&
+			adapter->discovery_type == new_type) {
 			if (adapter->discovering)
 				return FALSE;
 
@@ -1850,7 +1859,7 @@
  * otherwise it's pointing to filter. Returns 0 on succes, -1 on error
  */
 static int discovery_filter_to_mgmt_cp(struct btd_adapter *adapter,
-		       struct mgmt_cp_start_service_discovery **cp_ptr)
+			   struct mgmt_cp_start_service_discovery **cp_ptr)
 {
 	GSList *uuids = NULL;
 	struct mgmt_cp_start_service_discovery *cp;
@@ -1929,7 +1938,7 @@
 	 * starting discovery.
 	 */
 	if (filters_equal(adapter->current_discovery_filter, sd_cp) &&
-	    adapter->discovering != 0) {
+		adapter->discovering != 0) {
 		DBG("filters were equal, deciding to not restart the scan.");
 		g_free(sd_cp);
 		return;
@@ -2087,9 +2096,9 @@
 	 */
 	if (client) {
 		adapter->set_filter_list = g_slist_remove(
-					     adapter->set_filter_list, client);
+						 adapter->set_filter_list, client);
 		adapter->discovery_list = g_slist_prepend(
-					      adapter->discovery_list, client);
+						  adapter->discovery_list, client);
 		update_discovery_filter(adapter);
 		return dbus_message_new_method_return(msg);
 	}
@@ -2236,7 +2245,7 @@
 
 	dbus_message_iter_init(msg, &iter);
 	if (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY ||
-	    dbus_message_iter_get_element_type(&iter) != DBUS_TYPE_DICT_ENTRY)
+		dbus_message_iter_get_element_type(&iter) != DBUS_TYPE_DICT_ENTRY)
 		goto invalid_args;
 
 	dbus_message_iter_recurse(&iter, &subiter);
@@ -2255,7 +2264,7 @@
 			goto invalid_args;
 
 		if (dbus_message_iter_get_arg_type(&dictiter) !=
-							     DBUS_TYPE_VARIANT)
+								 DBUS_TYPE_VARIANT)
 			goto invalid_args;
 
 		dbus_message_iter_recurse(&dictiter, &variantiter);
@@ -2274,11 +2283,11 @@
 
 	/* only pathlos or rssi can be set, never both */
 	if ((*filter)->pathloss != DISTANCE_VAL_INVALID &&
-	    (*filter)->rssi != DISTANCE_VAL_INVALID)
+		(*filter)->rssi != DISTANCE_VAL_INVALID)
 		goto invalid_args;
 
 	DBG("filtered discovery params: transport: %d rssi: %d pathloss: %d",
-	    (*filter)->type, (*filter)->rssi, (*filter)->pathloss);
+		(*filter)->type, (*filter)->rssi, (*filter)->pathloss);
 
 	return true;
 
@@ -2304,7 +2313,7 @@
 		return btd_error_not_ready(msg);
 
 	if (MGMT_VERSION(mgmt_version, mgmt_revision) < MGMT_VERSION(1, 8))
-		return btd_error_not_supported(msg);
+		//return btd_error_not_supported(msg);
 
 	/* parse parameters */
 	if (!parse_discovery_filter_dict(adapter, &discovery_filter, msg))
@@ -2324,8 +2333,8 @@
 
 		/* Removing pre-set filter */
 		adapter->set_filter_list = g_slist_remove(
-					      adapter->set_filter_list,
-					      client);
+						  adapter->set_filter_list,
+						  client);
 		g_free(client->owner);
 		g_free(client);
 		DBG("successfully cleared pre-set filter");
@@ -2339,7 +2348,7 @@
 						discovery_disconnect, client,
 						discovery_destroy);
 		adapter->set_filter_list = g_slist_prepend(
-					     adapter->set_filter_list, client);
+						 adapter->set_filter_list, client);
 
 		DBG("successfully pre-set filter");
 	}
@@ -5541,10 +5550,10 @@
 		if (got_match) {
 			/* we have service match, check proximity */
 			if (item->rssi == DISTANCE_VAL_INVALID ||
-			    item->rssi <= rssi ||
-			    item->pathloss == DISTANCE_VAL_INVALID ||
-			    (eir_data->tx_power != 127 &&
-			     eir_data->tx_power - rssi <= item->pathloss))
+				item->rssi <= rssi ||
+				item->pathloss == DISTANCE_VAL_INVALID ||
+				(eir_data->tx_power != 127 &&
+				 eir_data->tx_power - rssi <= item->pathloss))
 				return true;
 
 			got_match = false;
@@ -5568,15 +5577,24 @@
 
 	memset(&eir_data, 0, sizeof(eir_data));
 	eir_parse(&eir_data, data, data_len);
-
 	if (bdaddr_type == BDADDR_BREDR || adapter->filtered_discovery)
 		discoverable = true;
 	else
 		discoverable = eir_data.flags & (EIR_LIM_DISC | EIR_GEN_DISC);
-
+        discoverable = true;
 	ba2str(bdaddr, addr);
 
 	dev = btd_adapter_find_device(adapter, bdaddr, bdaddr_type);
+        if (!dev)
+        {
+            bdaddr_type = BDADDR_LE_PUBLIC; 
+            dev = btd_adapter_find_device(adapter, bdaddr, bdaddr_type);
+        }
+        if (!dev)
+        {
+            bdaddr_type = BDADDR_LE_RANDOM;
+            dev = btd_adapter_find_device(adapter, bdaddr, bdaddr_type);
+        }
 	if (!dev) {
 		/*
 		 * If no client has requested discovery or the device is
@@ -5626,7 +5644,7 @@
 	}
 
 	if (adapter->filtered_discovery &&
-	    !is_filter_match(adapter->discovery_list, &eir_data, rssi)) {
+		!is_filter_match(adapter->discovery_list, &eir_data, rssi)) {
 		eir_data_free(&eir_data);
 		return;
 	}
@@ -6768,7 +6786,6 @@
 		disconnect_cb(dev, reason);
 	}
 }
-
 static void dev_disconnected(struct btd_adapter *adapter,
 					const struct mgmt_addr_info *addr,
 					uint8_t reason)
@@ -6778,7 +6795,7 @@
 
 	ba2str(&addr->bdaddr, dst);
 
-	DBG("Device %s disconnected, reason %u", dst, reason);
+	info("Device %s disconnected, reason %u", dst, reason);
 
 	device = btd_adapter_find_device(adapter, &addr->bdaddr, addr->type);
 	if (device) {
@@ -6788,6 +6805,7 @@
 
 	bonding_attempt_complete(adapter, &addr->bdaddr, addr->type,
 						MGMT_STATUS_DISCONNECTED);
+		advertise();
 }
 
 void btd_add_disconnect_cb(btd_disconnect_cb func)
@@ -7687,7 +7705,7 @@
 
 	ba2str(&ev->addr.bdaddr, addr);
 
-	DBG("hci%u device %s connected eir_len %u", index, addr, eir_len);
+	info("hci%u device %s connected eir_len %u", index, addr, eir_len);
 
 	device = btd_adapter_get_device(adapter, &ev->addr.bdaddr,
 								ev->addr.type);
diff -ruN --new-file bluez_utils-5.43/src/device.c bluez_utils-5.43_mod_2/src/device.c
--- bluez_utils-5.43/src/device.c	2017-06-14 18:25:33.847679804 +0530
+++ bluez_utils-5.43_mod_2/src/device.c	2019-05-08 14:12:46.041489084 +0530
@@ -53,6 +53,7 @@
 #include "src/shared/gatt-client.h"
 #include "src/shared/gatt-server.h"
 #include "src/shared/ad.h"
+#include "src/ltrx_le_advertising_api.h"
 #include "btio/btio.h"
 #include "lib/mgmt.h"
 #include "attrib/att.h"
@@ -4568,7 +4569,6 @@
 
 	btd_service_disconnect(service);
 }
-
 static void att_disconnected_cb(int err, void *user_data)
 {
 	struct btd_device *device = user_data;
@@ -4599,6 +4599,8 @@
 
 done:
 	attio_cleanup(device);
+        info("BLE central Disconnected\n");
+        advertise(); 
 }
 
 static void register_gatt_services(struct btd_device *device)
diff -ruN --new-file bluez_utils-5.43/src/gatt-database.c bluez_utils-5.43_mod_2/src/gatt-database.c
--- bluez_utils-5.43/src/gatt-database.c	2017-06-14 18:25:33.847679804 +0530
+++ bluez_utils-5.43_mod_2/src/gatt-database.c	2019-05-08 17:30:02.414314633 +0530
@@ -24,26 +24,7 @@
 #include <stdint.h>
 #include <stdlib.h>
 #include <errno.h>
-
-#include "lib/bluetooth.h"
-#include "lib/sdp.h"
-#include "lib/sdp_lib.h"
-#include "lib/uuid.h"
-#include "btio/btio.h"
-#include "gdbus/gdbus.h"
-#include "src/shared/util.h"
-#include "src/shared/queue.h"
-#include "src/shared/att.h"
-#include "src/shared/gatt-db.h"
-#include "src/shared/gatt-server.h"
-#include "log.h"
-#include "error.h"
-#include "adapter.h"
-#include "device.h"
-#include "gatt-database.h"
-#include "dbus-common.h"
-#include "profile.h"
-#include "service.h"
+#include "src/gatt_services.h"
 
 #ifndef ATT_CID
 #define ATT_CID 4
@@ -62,26 +43,10 @@
 #define UUID_GAP	0x1800
 #define UUID_GATT	0x1801
 
+
 #ifndef MIN
 #define MIN(a, b) ((a) < (b) ? (a) : (b))
 #endif
-
-struct btd_gatt_database {
-	struct btd_adapter *adapter;
-	struct gatt_db *db;
-	unsigned int db_id;
-	GIOChannel *le_io;
-	GIOChannel *l2cap_io;
-	uint32_t gap_handle;
-	uint32_t gatt_handle;
-	struct queue *device_states;
-	struct queue *ccc_callbacks;
-	struct gatt_db_attribute *svc_chngd;
-	struct gatt_db_attribute *svc_chngd_ccc;
-	struct queue *apps;
-	struct queue *profiles;
-};
-
 struct gatt_app {
 	struct btd_gatt_database *database;
 	char *owner;
@@ -467,11 +432,15 @@
 
 static void connect_cb(GIOChannel *io, GError *gerr, gpointer user_data)
 {
+	struct btd_gatt_database *database = user_data;
 	struct btd_adapter *adapter;
 	struct btd_device *device;
 	uint8_t dst_type;
+	struct bt_gatt_server *server;
 	bdaddr_t src, dst;
-
+	char bdaddress[20];
+	
+	system("hciconfig hci0 noscan");
 	if (gerr) {
 		error("%s", gerr->message);
 		return;
@@ -486,7 +455,8 @@
 		g_error_free(gerr);
 		return;
 	}
-
+	
+	dst_type = BDADDR_LE_RANDOM;
 	DBG("New incoming %s ATT connection", dst_type == BDADDR_BREDR ?
 							"BR/EDR" : "LE");
 
@@ -495,10 +465,15 @@
 		return;
 
 	device = btd_adapter_get_device(adapter, &dst, dst_type);
+	database->device = device;
+	
 	if (!device)
 		return;
 
 	device_attach_att(device, io);
+
+	ba2str(&dst, bdaddress);
+	info("BLE connected to %s\n", bdaddress);
 }
 
 static void gap_device_name_read_cb(struct gatt_db_attribute *attrib,
@@ -655,7 +630,7 @@
 
 	/* Add the GAP service */
 	bt_uuid16_create(&uuid, UUID_GAP);
-	service = gatt_db_add_service(database->db, &uuid, true, 5);
+	service = gatt_db_add_service(database->db, &uuid, true, GATT_GAP_SERVICE_DEF_LEN);
 	database->gap_handle = database_add_record(database, UUID_GAP, service,
 						"Generic Access Profile");
 
@@ -853,11 +828,13 @@
 
 	gatt_db_service_set_active(service, true);
 }
-
 static void register_core_services(struct btd_gatt_database *database)
 {
 	populate_gap_service(database);
 	populate_gatt_service(database);
+	/* new services added */
+	populate_device_info_service(database);
+	populate_device_config_service(database);
 }
 
 struct notify {
@@ -2607,12 +2584,13 @@
 		goto fail;
 
 	addr = btd_adapter_get_address(adapter);
-	database->le_io = bt_io_listen(connect_cb, NULL, NULL, NULL, &gerr,
-					BT_IO_OPT_SOURCE_BDADDR, addr,
-					BT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,
-					BT_IO_OPT_CID, ATT_CID,
-					BT_IO_OPT_SEC_LEVEL, BT_IO_SEC_LOW,
-					BT_IO_OPT_INVALID);
+	database->le_io = bt_io_listen(connect_cb, NULL, database, NULL, &gerr,
+									BT_IO_OPT_SOURCE_BDADDR, addr,
+									BT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,
+									BT_IO_OPT_CID, ATT_CID,
+									BT_IO_OPT_SEC_LEVEL, BT_IO_SEC_LOW,
+									BT_IO_OPT_INVALID);
+
 	if (!database->le_io) {
 		error("Failed to start listening: %s", gerr->message);
 		g_error_free(gerr);
@@ -2621,10 +2599,11 @@
 
 	/* BR/EDR socket */
 	database->l2cap_io = bt_io_listen(connect_cb, NULL, NULL, NULL, &gerr,
-					BT_IO_OPT_SOURCE_BDADDR, addr,
-					BT_IO_OPT_PSM, ATT_PSM,
-					BT_IO_OPT_SEC_LEVEL, BT_IO_SEC_LOW,
-					BT_IO_OPT_INVALID);
+									  BT_IO_OPT_SOURCE_BDADDR, addr,
+									  BT_IO_OPT_PSM, ATT_PSM,
+									  BT_IO_OPT_SEC_LEVEL, BT_IO_SEC_LOW,
+									  BT_IO_OPT_INVALID);
+
 	if (database->l2cap_io == NULL) {
 		error("Failed to start listening: %s", gerr->message);
 		g_error_free(gerr);
diff -ruN --new-file bluez_utils-5.43/src/gatt_services.h bluez_utils-5.43_mod_2/src/gatt_services.h
--- bluez_utils-5.43/src/gatt_services.h	1970-01-01 05:30:00.000000000 +0530
+++ bluez_utils-5.43_mod_2/src/gatt_services.h	2019-05-08 17:30:18.526483211 +0530
@@ -0,0 +1,62 @@
+#include "lib/bluetooth.h"
+#include "lib/sdp.h"
+#include "lib/sdp_lib.h"
+#include "lib/uuid.h"
+#include "btio/btio.h"
+#include "gdbus/gdbus.h"
+#include "src/shared/util.h"
+#include "src/shared/queue.h"
+#include "src/shared/att.h"
+#include "src/shared/gatt-db.h"
+#include "src/shared/gatt-server.h"
+#include "log.h"
+#include "error.h"
+#include "adapter.h"
+#include "device.h"
+#include "gatt-database.h"
+#include "dbus-common.h"
+#include "profile.h"
+#include "service.h"
+
+#define COLOR_BLUE      "\x1B[0;94m"
+#define COLOR_OFF       "\x1B[0m"
+
+#define GATT_GAP_SERVICE_DEF_LEN   6
+
+
+static void print_prompt(void)
+{
+	printf(COLOR_BLUE "[GATT client]" COLOR_OFF "# ");
+	fflush(stdout);
+}
+#define PRLOG(...) \
+		printf(__VA_ARGS__); print_prompt();
+
+
+struct btd_gatt_database {
+	struct btd_adapter *adapter;
+	struct btd_device *device;
+	struct gatt_db *db;
+	unsigned int db_id;
+	GIOChannel *le_io;
+	GIOChannel *l2cap_io;
+	uint32_t gap_handle;
+	uint32_t gatt_handle;
+	struct queue *device_states;
+	struct queue *ccc_callbacks;
+	struct gatt_db_attribute *svc_chngd;
+	struct gatt_db_attribute *svc_chngd_ccc;
+	struct queue *apps;
+	struct queue *profiles;
+	uint16_t device_config_status_notify_handle;
+	uint16_t device_config_status_notify_ccc_handle;
+	uint8_t device_config_status_notify_enabled;
+	uint8_t device_config_status;
+	uint8_t *device_config_xml_data;
+	uint32_t device_config_xml_data_length;
+	uint32_t device_config_checksum_value;
+};
+
+
+void populate_device_info_service(struct btd_gatt_database *database);
+void populate_device_config_service(struct btd_gatt_database *database); 
diff -ruN --new-file bluez_utils-5.43/src/log.h bluez_utils-5.43_mod_2/src/log.h
--- bluez_utils-5.43/src/log.h	2017-06-14 18:25:33.847679804 +0530
+++ bluez_utils-5.43_mod_2/src/log.h	2019-05-08 14:35:22.850821813 +0530
@@ -23,10 +23,22 @@
 
 #include <stdint.h>
 
+#define DBG_EN
+
 void error(const char *format, ...) __attribute__((format(printf, 1, 2)));
 void warn(const char *format, ...) __attribute__((format(printf, 1, 2)));
 void info(const char *format, ...) __attribute__((format(printf, 1, 2)));
 
+#ifdef DBG_EN
+#define DBG_ERR(fmt, args...)  error(fmt, ##args)
+#define DBG_WARN(fmt, args...) warn(fmt, ##args)
+#define DBG_INFO(fmt, args...) info(fmt, ##args)
+#else
+#define DBG_ERR(fmt, args...)
+#define DBG_WARN(fmt, args...) 
+#define DBG_INFO(fmt, args...)
+#endif
+
 void btd_log(uint16_t index, int priority, const char *format, ...)
 					__attribute__((format(printf, 3, 4)));
 
diff -ruN --new-file bluez_utils-5.43/src/ltrx_device_configuration_service.c bluez_utils-5.43_mod_2/src/ltrx_device_configuration_service.c
--- bluez_utils-5.43/src/ltrx_device_configuration_service.c	1970-01-01 05:30:00.000000000 +0530
+++ bluez_utils-5.43_mod_2/src/ltrx_device_configuration_service.c	2019-05-08 17:30:42.646727544 +0530
@@ -0,0 +1,556 @@
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <errno.h>
+#include "src/gatt_services.h"
+
+#define BAD_CHECKSUM_VALUE_ERROR   2
+#define BAD_LENGTH_VALUE_ERROR	 3
+#define UNABLE_TO_PROCESS_XML_FILE 5
+
+#define CLIENT_CHAR_CONFIG_DESC_LENGTH	2
+#define NOTIFY							0x00
+#define INDICATE						0x01
+#define NOTIFY_ENABLED					0x01
+#define NOTIFY_DISABLED					0x00
+
+#define DEVICE_CONFIG_SERVICE_UUID {0xF0, 0xDD, 0x79, 0x9C, \
+									0xC8, 0x83, 0x49, 0x76, \
+									0x96, 0xA5, 0x8B, 0xB4, \
+									0x90 ,0x7F ,0x41, 0xD6}
+
+#define DEVICE_CONFIG_STATUS_CHAR_UUID {0x3B, 0xC6, 0x3A, 0xDD, \
+										0x3B, 0x52, 0x4A, 0x3F, \
+										0xBE, 0x47, 0xA0, 0x48, \
+										0xBC ,0xA2 ,0x48, 0xBF}
+
+#define DEVICE_XML_CONFIG_PACKET_CHAR_UUID {0x24, 0xFD, 0x0A, 0x4F, \
+											0x68, 0x09, 0x44, 0xAB, \
+											0x95, 0x96, 0x52, 0x3D, \
+											0xB9 ,0xEB ,0xCD, 0x47}
+
+#define DEVICE_XML_CONFIG_PACKET_LENGTH_CHAR_UUID {0x60, 0x65, 0x68, 0x16, \
+												   0x87, 0xBE, 0x4C, 0xD0, \
+												   0x9C, 0xA7, 0xE8, 0xB8, \
+												   0x10 ,0xE1 ,0xEC, 0x23}
+
+#define DEVICE_CONFIG_CHECKSUM_CHAR_UUID {0x0B, 0x8E, 0x5A, 0x44, \
+										  0x33, 0x71, 0x4D, 0x0C, \
+										  0xB3, 0x8B, 0x56, 0xC1, \
+										  0xE0 ,0x34 ,0x48, 0xF6}
+
+
+static uint32_t xml_data_current_index;
+static void device_config_status_read_cb(struct gatt_db_attribute *attrib,
+										unsigned int id, uint16_t offset,
+										uint8_t opcode, struct bt_att *att,
+										void *user_data)
+{
+	struct btd_gatt_database *server = user_data;
+	uint8_t error = 0;
+	size_t len = 0;
+	const uint8_t *value = NULL;
+
+	PRLOG("Wifi Device Config Status Read called\n");
+	len = 1;
+
+	if (offset > len)
+	{
+		error = BT_ATT_ERROR_INVALID_OFFSET;
+		goto done;
+	}
+
+	len -= offset;
+	value = len ? &server->device_config_status : NULL;
+
+done:
+	gatt_db_attribute_read_result(attrib, id, error, value, len);
+
+}
+
+static bool calculate_checksum(void *data)
+{
+	struct btd_gatt_database *server = data;
+	uint32_t index;
+	uint32_t calculated_checksum = 0;
+
+	PRLOG("Calculating Checksum\n");
+	for(index = 0; index < server->device_config_xml_data_length; index++)
+	{
+		calculated_checksum += server->device_config_xml_data[index];
+	}
+	calculated_checksum = ~calculated_checksum;
+	calculated_checksum &= 0xFF;
+	calculated_checksum += 1;
+
+	if(calculated_checksum != server->device_config_checksum_value)
+		return false;
+
+	return true;
+}
+
+static void generate_xml_config_file(void *data)
+{
+	struct btd_gatt_database *server = data;
+	FILE* file = fopen("/ltrx_user/device_cfg.xml", "w");
+	uint32_t index;
+
+	for(index = 0; index < server->device_config_xml_data_length; index++)
+	{
+		fputc(server->device_config_xml_data[index], file);
+	}
+
+	fclose(file);
+}
+
+void trim(char *ch)
+{
+	int count = 0;
+
+	while(*ch == ' ') { count = count + 1; ch++; }
+	while(*ch != '\0') { *(ch - count) = *ch; ch++;}
+	*(ch - count) = '\0';
+}
+
+static bool xml_import(void)
+{
+	FILE *fp;
+	char status[100];
+
+	system("curl --anyauth -u admin:PASS http://localhost/import/config -X POST --form configrecord=@/ltrx_user/device_cfg.xml|grep \"<message>All XML configuration records have been imported.</message>\\|<message>ERROR: XML import failed.</message>\" > result");
+	fp = fopen("result", "r");
+	fgets(status, 100, fp);
+	fclose(fp);
+
+	PRLOG("xml status : %s\n", status);
+	system("rm result");
+	trim(status);
+
+	if(!memcmp(status, "<message>ERROR: XML import failed.</message>", 44)) return false;
+	if(!memcmp(status, "<message>All XML configuration records have been imported.</message>", 68)) return true;
+	return false;
+}
+
+static void device_config_status_ccc_read_cb(struct gatt_db_attribute *attrib,
+											unsigned int id, uint16_t offset,
+											uint8_t opcode, struct bt_att *att,
+											void *user_data)
+{
+	struct btd_gatt_database *server = user_data;
+	uint8_t value[2];
+
+	value[0] = server->device_config_status_notify_enabled ? 0x01 : 0x00;
+	value[1] = 0x00;
+
+	gatt_db_attribute_read_result(attrib, id, 0, value, 2);
+}
+
+static void device_config_status_ccc_write_cb(struct gatt_db_attribute *attrib,
+											 unsigned int id, uint16_t offset,
+											 const uint8_t *value, size_t len,
+											 uint8_t opcode, struct bt_att *att,
+											 void *user_data)
+{
+	struct btd_gatt_database *server = user_data;
+	uint8_t ecode = 0;
+	
+	if (!value || len != 2) {
+		ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
+		gatt_db_attribute_write_result(attrib, id, ecode);
+		return;
+	}
+	
+	if (offset) { 
+		ecode = BT_ATT_ERROR_INVALID_OFFSET;
+		gatt_db_attribute_write_result(attrib, id, ecode);
+		return;
+	}
+	
+	if (value[0] == NOTIFY_DISABLED)
+		server->device_config_status_notify_enabled = false;
+	else if (value[0] == NOTIFY_ENABLED) {
+		if (!server->device_config_status_notify_enabled)
+			server->device_config_status_notify_enabled = true;
+	} else
+		ecode = 0x80;
+
+	PRLOG("Wifi Device Config Status Notification Enabled: %s\n",
+			server->device_config_status_notify_enabled ? "true" : "false");
+	gatt_db_attribute_write_result(attrib, id, ecode);
+}
+
+void *process_xml_and_send_notification(void *data)
+{
+	struct btd_gatt_database *server = data;
+	struct bt_gatt_server *gatt = btd_device_get_gatt_server(server->device); 
+
+	if(calculate_checksum(data))
+	{
+		PRLOG("Checksum Matched\n");
+		generate_xml_config_file(data);
+		if(xml_import())
+		{
+			  PRLOG("Sending Xml Import Successful Notification\n");
+			  goto done;
+		}
+		else
+		{
+			server->device_config_status = UNABLE_TO_PROCESS_XML_FILE;
+			goto done;
+		}
+	}
+	else
+	{
+		server->device_config_status = BAD_CHECKSUM_VALUE_ERROR;
+		PRLOG("Checksum Mismatch\n");
+	}
+
+done:
+	xml_data_current_index = 0;
+	system("rm /ltrx_user/device_cfg.xml");
+	if(server->device_config_status_notify_enabled)
+		bt_gatt_server_send_notification(gatt, server->device_config_status_notify_handle,
+										&server->device_config_status, 1);
+
+}
+
+static void device_config_xml_data_packet_write_cb(struct gatt_db_attribute *attrib,
+										unsigned int id, uint16_t offset,
+										const uint8_t *value, size_t len,
+										uint8_t opcode, struct bt_att *att,
+										void *user_data)
+{
+	struct btd_gatt_database *server = user_data;
+	uint8_t ecode = 0;
+	struct bt_gatt_server *gatt = btd_device_get_gatt_server(server->device);
+
+	server->device_config_status = 0;
+	pthread_t check_checksum_and_process_xml;
+	/*
+	if (!value || len > 21) {
+			ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
+			goto done;
+	}
+
+	if (offset) {
+			ecode = BT_ATT_ERROR_INVALID_OFFSET;
+			goto done;
+	}
+	*/
+	if(xml_data_current_index + len > server->device_config_xml_data_length)
+	{
+		server->device_config_status = BAD_LENGTH_VALUE_ERROR;
+		if (server->device_config_status_notify_enabled)
+		{
+			bt_gatt_server_send_notification(gatt,
+											server->device_config_status_notify_handle,
+											&server->device_config_status, 1);
+		}
+	}
+	else
+	{
+		strncpy(&server->device_config_xml_data[xml_data_current_index], value, len);
+		server->device_config_xml_data[xml_data_current_index + len] = '\0';
+		xml_data_current_index += len; 
+		//PRLOG("Wifi Device Config Xml data packet value after write : %s\n", server->device_config_xml_data);
+		PRLOG("xml_data_current_index = %d server->device_config_xml_data_length = %d\n", xml_data_current_index, server->device_config_xml_data_length); 
+		gatt_db_attribute_write_result(attrib, id, ecode);
+
+		if(xml_data_current_index == server->device_config_xml_data_length)
+		{
+			if (!pthread_create(&check_checksum_and_process_xml, NULL, process_xml_and_send_notification, server)) {
+				PRLOG("process_xml_and_send_notification Thread create successfully !!!\n");
+				if ( ! pthread_detach(check_checksum_and_process_xml) )
+				{	PRLOG("process_xml_and_send_notification Thread detached successfully !!!\n");}
+				else
+				{
+					PRLOG("process_xml_and_send_notification Thread cannot be detached !!!\n");
+				}
+			}
+			else
+			{
+				PRLOG("process_xml_and_send_notification Thread cannot be created !!!\n");
+			}
+		}
+		else
+		{
+			if(server->device_config_status_notify_enabled)
+				bt_gatt_server_send_notification(gatt,
+												server->device_config_status_notify_handle,
+												&server->device_config_status, 1);
+		}
+	}
+}
+
+static void device_config_xml_data_length_read_cb(struct gatt_db_attribute *attrib,
+													unsigned int id, uint16_t offset,
+													uint8_t opcode, struct bt_att *att,
+													void *user_data)
+{
+	struct btd_gatt_database *server = user_data;
+	uint8_t error = 0;
+	size_t len = 8;
+	const uint8_t *value = NULL;
+	uint32_t flag = 0xFF;
+	uint8_t i;
+	uint8_t *xml_data_length_value = malloc(len * sizeof(uint8_t)); 
+
+	PRLOG("Wifi Device Config Xml data length Read called\n");
+
+	if (offset > len)
+	{
+		error = BT_ATT_ERROR_INVALID_OFFSET;
+		goto done;
+	}
+
+	for(i = 0; i < len; i++)
+	{
+		xml_data_length_value[i] = server->device_config_xml_data_length & flag;
+		flag <<= 8;
+	}
+
+	len -= offset;
+	value = len ? xml_data_length_value : NULL;
+
+done:
+	gatt_db_attribute_read_result(attrib, id, error, value, len);
+}
+
+static void device_config_xml_data_length_write_cb(struct gatt_db_attribute *attrib,
+													unsigned int id, uint16_t offset,
+													const uint8_t *value, size_t len,
+													uint8_t opcode, struct bt_att *att,
+													void *user_data)
+{
+	struct btd_gatt_database *server = user_data;
+	struct bt_gatt_server *gatt = btd_device_get_gatt_server(server->device);
+	uint8_t ecode = 0;
+	uint8_t i;
+/*
+	if (!value || len > 21) {
+			ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
+			goto done;
+	}
+
+	if (offset) {
+			ecode = BT_ATT_ERROR_INVALID_OFFSET;
+			goto done;
+	}
+*/
+	PRLOG("Device_config xml data length characteritsic write request value length = %d", len);
+	server->device_config_xml_data_length=0;	   
+
+	for(i = len - 1; i > 0; i--)
+	{
+		server->device_config_xml_data_length = server->device_config_xml_data_length + value[i];
+		server->device_config_xml_data_length = server->device_config_xml_data_length << 8;
+		PRLOG("i = %d, server->device_config_xml_data_length = %x\n", i, server->device_config_xml_data_length);
+	}
+
+	server->device_config_xml_data_length = server->device_config_xml_data_length + value[i];
+	PRLOG("i = %d, server->device_config_xml_data_length = %x\n", i, server->device_config_xml_data_length);
+
+	if(server->device_config_xml_data != NULL)
+	{
+		free(server->device_config_xml_data);
+		server->device_config_xml_data = NULL;
+	}
+
+	xml_data_current_index = 0;
+	server->device_config_xml_data = malloc(sizeof(uint8_t) * (server->device_config_xml_data_length + 1));
+	PRLOG("Wifi Device Config xml data length value after write : %ld\n", server->device_config_xml_data_length);
+
+done:
+	gatt_db_attribute_write_result(attrib, id, ecode);
+	server->device_config_status = 0;
+
+	if(server->device_config_status_notify_enabled)
+	{
+		 bt_gatt_server_send_notification(gatt, server->device_config_status_notify_handle,
+										 &server->device_config_status, 1);
+	}
+
+}
+
+static void device_config_checksum_read_cb(struct gatt_db_attribute *attrib,
+											unsigned int id, uint16_t offset,
+											uint8_t opcode, struct bt_att *att,
+											void *user_data)
+{
+	struct btd_gatt_database *server = user_data;
+	uint8_t error = 0;
+	size_t len = 8;
+	const uint8_t *value = NULL;
+	uint8_t *checksum_value = malloc(len * sizeof(uint8_t));
+	uint32_t flag = 0xFF;
+	uint8_t i;
+
+	//PRLOG("Wifi Device Config Checksum Read called\n");
+
+	if (offset > len) {
+		error = BT_ATT_ERROR_INVALID_OFFSET;
+		goto done;
+	}
+
+	for(i = 0; i < len; i++)
+	{
+		 checksum_value[i] = server->device_config_checksum_value & flag;
+		 flag <<= 8;
+	}
+	len -= offset;		
+	value = len ? checksum_value : NULL;
+
+done:
+	gatt_db_attribute_read_result(attrib, id, error, value, len);
+}
+
+static void device_config_checksum_write_cb(struct gatt_db_attribute *attrib,
+											unsigned int id, uint16_t offset,
+											const uint8_t *value, size_t len,
+											uint8_t opcode, struct bt_att *att,
+											void *user_data)
+{
+	struct btd_gatt_database *server = user_data;
+	uint8_t ecode = 0;
+	struct bt_gatt_server *gatt = btd_device_get_gatt_server(server->device);
+	uint8_t i;
+	
+	/*
+	if (!value || len > 21) {
+			ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
+			goto done;
+	}
+
+	if (offset) {
+			ecode = BT_ATT_ERROR_INVALID_OFFSET;
+			goto done;
+	}
+	*/
+	server->device_config_checksum_value=0;
+
+	for(i = len - 1; i > 0; i--)
+	{
+		server->device_config_checksum_value = server->device_config_checksum_value + value[i];
+		server->device_config_checksum_value = server->device_config_checksum_value << 8;
+	}
+	server->device_config_checksum_value = server->device_config_checksum_value + value[i];
+
+	//PRLOG("Wifi Device Config Checksum value after write : %d\n", server->device_config_checksum_value);
+
+done:
+	gatt_db_attribute_write_result(attrib, id, ecode);
+	server->device_config_status = 0;
+
+	if(server->device_config_status_notify_enabled)  
+	{
+		bt_gatt_server_send_notification(gatt, server->device_config_status_notify_handle,
+										&server->device_config_status, 1);
+	}
+}
+
+static void populate_device_config_service_uuid( uint8_t *des)
+{
+	uint8_t loop;
+	uint8_t device_config_service_uuid_data[] = DEVICE_CONFIG_SERVICE_UUID;
+
+	for(loop = 0; loop <= 15; loop++)
+		memcpy(&des[loop], &device_config_service_uuid_data[loop], 1);
+}
+
+static void populate_device_config_status_notify_uuid( uint8_t *des)
+{
+	uint8_t loop;
+	uint8_t device_config_status_notify_uuid_data[] = DEVICE_CONFIG_STATUS_CHAR_UUID;
+
+	for(loop = 0; loop <= 15; loop++)
+		memcpy(&des[loop], &device_config_status_notify_uuid_data[loop], 1);
+}
+
+static void populate_device_config_xml_data_packet_uuid( uint8_t *des)
+{
+	uint8_t loop;
+	uint8_t device_config_xml_data_packet_uuid_data[] = DEVICE_XML_CONFIG_PACKET_CHAR_UUID;
+
+	for(loop = 0; loop <= 15; loop++)
+		memcpy(&des[loop], &device_config_xml_data_packet_uuid_data[loop], 1);
+}
+
+static void populate_device_config_xml_data_packet_length_uuid( uint8_t *des)
+{
+	uint8_t loop;
+	uint8_t device_config_xml_data_packet_length_uuid_data[] = DEVICE_XML_CONFIG_PACKET_LENGTH_CHAR_UUID;
+
+	for(loop = 0; loop <= 15; loop++)
+		memcpy(&des[loop], &device_config_xml_data_packet_length_uuid_data[loop], 1);
+}
+
+static void populate_device_config_checksum_uuid( uint8_t *des)
+{
+	uint8_t loop;
+	uint8_t device_config_checksum_uuid_data[] = DEVICE_CONFIG_CHECKSUM_CHAR_UUID;
+
+	for(loop = 0; loop <= 15; loop++)
+		memcpy(&des[loop], &device_config_checksum_uuid_data[loop], 1);
+}
+
+void populate_device_config_service(struct btd_gatt_database *database)
+{
+	bt_uuid_t uuid;
+	struct gatt_db_attribute *service, *device_config_status_notify_handle, *device_config_status_notify_ccc_handle;
+	uint128_t device_config_128_uuid;
+
+	/* Add Wifi Device Config Service */
+	populate_device_config_service_uuid(device_config_128_uuid.data);
+	bt_uuid128_create(&uuid, device_config_128_uuid);
+	service = gatt_db_add_service(database->db, &uuid, true, 10);
+
+	/* Wifi Device Configuration Status Notification Characteristic */
+	populate_device_config_status_notify_uuid(device_config_128_uuid.data);
+	bt_uuid128_create(&uuid, device_config_128_uuid);
+	device_config_status_notify_handle = gatt_db_service_add_characteristic(service, &uuid,
+																			BT_ATT_PERM_READ, BT_GATT_CHRC_PROP_READ | BT_GATT_CHRC_PROP_NOTIFY,
+																			device_config_status_read_cb, NULL, database);
+
+	database->device_config_status_notify_handle = gatt_db_attribute_get_handle(device_config_status_notify_handle);
+
+	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
+	device_config_status_notify_ccc_handle = gatt_db_service_add_descriptor(service, &uuid, BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
+																			device_config_status_ccc_read_cb,
+																			device_config_status_ccc_write_cb, database);
+
+	database->device_config_status_notify_ccc_handle = gatt_db_attribute_get_handle(device_config_status_notify_ccc_handle);
+
+	/* Wifi Device Config XML Data Packet Characteristics */
+	populate_device_config_xml_data_packet_uuid(device_config_128_uuid.data);
+	bt_uuid128_create(&uuid, device_config_128_uuid);
+	gatt_db_service_add_characteristic(service, &uuid,
+										BT_ATT_PERM_WRITE,
+										BT_GATT_CHRC_PROP_WRITE,
+										NULL, device_config_xml_data_packet_write_cb, database);
+
+	/* Wifi Device Config XML Data Packet Length Characteristics */
+	populate_device_config_xml_data_packet_length_uuid(device_config_128_uuid.data);
+	bt_uuid128_create(&uuid, device_config_128_uuid);
+	gatt_db_service_add_characteristic(service, &uuid,
+										BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
+										BT_GATT_CHRC_PROP_READ | BT_GATT_CHRC_PROP_WRITE,
+										device_config_xml_data_length_read_cb, device_config_xml_data_length_write_cb, database);
+
+	/* Wifi Device Config Checksum Characteristics */
+	populate_device_config_checksum_uuid(device_config_128_uuid.data);
+	bt_uuid128_create(&uuid, device_config_128_uuid);
+	gatt_db_service_add_characteristic(service, &uuid,
+										BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
+										BT_GATT_CHRC_PROP_READ | BT_GATT_CHRC_PROP_WRITE,
+										device_config_checksum_read_cb, device_config_checksum_write_cb, database);
+
+	database->device_config_status = 0;
+	database->device_config_xml_data_length = 0;
+	database->device_config_xml_data = NULL;
+	database->device_config_checksum_value = 0;
+	database->device_config_status_notify_enabled = false;
+	gatt_db_service_set_active(service, true);
+}
diff -ruN --new-file bluez_utils-5.43/src/ltrx_device_info_service.c bluez_utils-5.43_mod_2/src/ltrx_device_info_service.c
--- bluez_utils-5.43/src/ltrx_device_info_service.c	1970-01-01 05:30:00.000000000 +0530
+++ bluez_utils-5.43_mod_2/src/ltrx_device_info_service.c	2019-05-08 17:30:42.646727544 +0530
@@ -0,0 +1,97 @@
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <errno.h>
+#include "src/gatt_services.h"
+
+#define UUID_DEVICE_INFO				0x180A
+#define UUID_DEVICE_INFO_MANU_NAME		0x2A29
+#define UUID_DEVICE_INFO_MODEL_NUM		0x2A24
+#define UUID_DEVICE_INFO_SYSTEM_ID		0x2A23
+#define UUID_DEVICE_INFO_SERIAL_NUM		0x2A25
+
+static void get_hostname(char *hostName)
+{
+	FILE *fp = fopen("/tmp/HOSTNAME", "r");
+	fscanf(fp, "%s", hostName);
+	fclose(fp);
+}
+
+void confirm_write(struct gatt_db_attribute *attr, int err, void *user_data)
+{
+	if (!err)
+		return;
+
+	fprintf(stderr, "Error caching attribute %p - err: %d\n", attr, err);
+	exit(1);
+}
+
+void populate_device_info_service(struct btd_gatt_database *database)
+{
+	bt_uuid_t uuid;
+	struct gatt_db_attribute *service, *dev_info_manu_name, *dev_info_model_num, *dev_info_serial_num, *dev_info_system_id;
+	uint8_t manu_name[] = "LANTRONIX";
+	uint8_t model_num[10];
+	uint8_t serial_num[25];
+	uint8_t system_id[] = { 0xbb, 0xb8, 0xa1, 0x80, 0x5f, 0x9f, 0x91, 0x71};
+	uint8_t hostName[40];
+	int index;
+
+	get_hostname(hostName);
+	/* add device info service */
+	bt_uuid16_create(&uuid, UUID_DEVICE_INFO);
+	service = gatt_db_add_service(database->db, &uuid, true, 9);
+
+	/* add manufacture name characteristic */
+	bt_uuid16_create(&uuid, UUID_DEVICE_INFO_MANU_NAME);
+	dev_info_manu_name = gatt_db_service_add_characteristic(service, &uuid,
+															BT_ATT_PERM_READ,
+															BT_GATT_CHRC_PROP_READ,
+															NULL, NULL, database);
+
+	gatt_db_attribute_write(dev_info_manu_name, 0, (void *) manu_name, 9,
+							BT_ATT_OP_WRITE_REQ, NULL, confirm_write, NULL);
+
+	/* add model number characteristic */
+	bt_uuid16_create(&uuid, UUID_DEVICE_INFO_MODEL_NUM);
+	dev_info_model_num = gatt_db_service_add_characteristic(service, &uuid,
+															 BT_ATT_PERM_READ,
+															 BT_GATT_CHRC_PROP_READ,
+															 NULL, NULL, database);
+
+	index = strcspn(hostName, "-");
+	strncpy(model_num, hostName, index);
+
+	gatt_db_attribute_write(dev_info_model_num, 0, (void *) model_num, index,
+													BT_ATT_OP_WRITE_REQ,
+													NULL, confirm_write,
+													NULL); 
+
+	/* add serial number characteristic */
+	bt_uuid16_create(&uuid, UUID_DEVICE_INFO_SERIAL_NUM);
+	dev_info_serial_num = gatt_db_service_add_characteristic(service, &uuid,
+															 BT_ATT_PERM_READ,
+															 BT_GATT_CHRC_PROP_READ,
+															 NULL, NULL, database);
+
+	strcpy(serial_num, &hostName[index+1]);
+
+	gatt_db_attribute_write(dev_info_serial_num, 0, (void *) serial_num, 12,
+							BT_ATT_OP_WRITE_REQ, NULL, confirm_write, NULL);
+
+	/* add system ID characteristic */
+	bt_uuid16_create(&uuid, UUID_DEVICE_INFO_SYSTEM_ID);
+	dev_info_system_id = gatt_db_service_add_characteristic(service, &uuid,
+															 BT_ATT_PERM_READ,
+															 BT_GATT_CHRC_PROP_READ,
+															 NULL, NULL, database);
+
+	gatt_db_attribute_write(dev_info_system_id, 0, (void *) system_id, 8,
+							BT_ATT_OP_WRITE_REQ, NULL, confirm_write, NULL);
+
+	gatt_db_service_set_active(service, true);
+}
+
diff -ruN --new-file bluez_utils-5.43/src/ltrx_le_advertising_api.h bluez_utils-5.43_mod_2/src/ltrx_le_advertising_api.h
--- bluez_utils-5.43/src/ltrx_le_advertising_api.h	1970-01-01 05:30:00.000000000 +0530
+++ bluez_utils-5.43_mod_2/src/ltrx_le_advertising_api.h	2019-05-08 17:30:56.062859425 +0530
@@ -0,0 +1,5 @@
+
+
+void get_hostname(char *hostName);
+void set_advertising_cmd(char *adv_data_cmd, char *hostName);
+void advertise(void);
diff -ruN --new-file bluez_utils-5.43/src/ltrx_le_advertising.c bluez_utils-5.43_mod_2/src/ltrx_le_advertising.c
--- bluez_utils-5.43/src/ltrx_le_advertising.c	1970-01-01 05:30:00.000000000 +0530
+++ bluez_utils-5.43_mod_2/src/ltrx_le_advertising.c	2019-06-27 20:18:14.630220664 +0530
@@ -0,0 +1,54 @@
+#include "ltrx_le_advertising_api.h"
+#include <inttypes.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+void get_hostname(char *hostName)
+{
+	FILE *fp = fopen("/tmp/HOSTNAME", "r");
+	fscanf(fp, "%s", hostName);
+	fclose(fp);
+}
+
+void set_advertising_cmd(char *adv_data_cmd, char *hostName)
+{
+	uint8_t index, ch;
+        if(!strncmp(hostName, "PW2050", 6))
+            sprintf(adv_data_cmd, "hcitool -i hci0 cmd 0x08 0x0008 1C 02 01 18 03 03 0a 18 14 09");
+        else if(!strncmp(hostName, "SGX5150", 7))
+            sprintf(adv_data_cmd, "hcitool -i hci0 cmd 0x08 0x0008 1D 02 01 18 03 03 0a 18 15 09");
+        else
+	    sprintf(adv_data_cmd, "hcitool -i hci0 cmd 0x08 0x0008 1F 02 01 18 03 03 0a 18 17 09");
+	printf("%s\n", adv_data_cmd);
+
+	for(index = 0; index < 22; index++)
+	{
+		if(index < strlen(hostName))
+		{
+			ch = hostName[index];
+			sprintf(adv_data_cmd, "%s %x", adv_data_cmd, ch);
+		}
+		else
+		{
+			sprintf(adv_data_cmd, "%s 00", adv_data_cmd);
+		}
+	}
+}
+
+void advertise(void)
+{
+	int ret;
+	uint8_t adv_data_cmd[128], hostName[40];
+
+	get_hostname(hostName);
+	info("hostName %s\n", hostName);
+
+	set_advertising_cmd(adv_data_cmd, hostName);
+	info("adv_data_cmd %s\n", adv_data_cmd);
+
+	ret = system("hciconfig hci0 leadv0");
+	ret = system(adv_data_cmd);
+	//ret = system("hcitool -i hci0 cmd 0x08 0x0009 04 03 19 C0 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00");
+	ret = system("hciconfig hci0 piscan");
+}
+
diff -ruN --new-file bluez_utils-5.43/src/main.c bluez_utils-5.43_mod_2/src/main.c
--- bluez_utils-5.43/src/main.c	2017-06-14 18:25:33.847679804 +0530
+++ bluez_utils-5.43_mod_2/src/main.c	2019-05-09 11:13:18.364099119 +0530
@@ -218,6 +218,8 @@
 	char *str;
 	int val;
 	gboolean boolean;
+	char hostName[40] = {} ;
+	FILE *fp = NULL;
 
 	if (!config)
 		return;
@@ -283,7 +285,9 @@
 	} else {
 		DBG("name=%s", str);
 		g_free(main_opts.name);
-		main_opts.name = str;
+		fp = fopen("/tmp/HOSTNAME", "r");
+		fscanf(fp, "%s", hostName);
+		main_opts.name = hostName;
 	}
 
 	str = g_key_file_get_string(config, "General", "Class", &err);
diff -ruN --new-file bluez_utils-5.43/tools/btgatt-server.c bluez_utils-5.43_mod_2/tools/btgatt-server.c
--- bluez_utils-5.43/tools/btgatt-server.c	2018-07-13 12:19:09.640817130 +0530
+++ bluez_utils-5.43_mod_2/tools/btgatt-server.c	2019-05-09 16:38:16.676853214 +0530
@@ -28,6 +28,7 @@
 #include <getopt.h>
 #include <unistd.h>
 #include <errno.h>
+#include <string.h>
 
 #include "lib/bluetooth.h"
 #include "lib/hci.h"
@@ -42,13 +43,22 @@
 #include "src/shared/timeout.h"
 #include "src/shared/gatt-db.h"
 #include "src/shared/gatt-server.h"
+#include "pthread.h"
+
+#if 0
+#include "mpnipc.h"
+#include "evolution_defines.h"
+#include "net_services.h"
+#include "network_libs.h"
+#endif
 
 #define UUID_GAP			0x1800
 #define UUID_GATT			0x1801
-#define UUID_HEART_RATE			0x180d
-#define UUID_HEART_RATE_MSRMT		0x2a37
-#define UUID_HEART_RATE_BODY		0x2a38
-#define UUID_HEART_RATE_CTRL		0x2a39
+#define UUID_DEVICE_INFO                0x180A
+#define UUID_DEVICE_INFO_MANU_NAME      0x2A29
+#define UUID_DEVICE_INFO_MODEL_NUM      0x2A24
+#define UUID_DEVICE_INFO_SYSTEM_ID      0x2A23
+#define UUID_DEVICE_INFO_SERIAL_NUM     0x2A25
 
 #define ATT_CID 4
 
@@ -71,10 +81,16 @@
 #define COLOR_BOLDGRAY	"\x1B[1;30m"
 #define COLOR_BOLDWHITE	"\x1B[1;37m"
 
-static const char test_device_name[] = "Very Long Test Device Name For Testing "
-				"ATT Protocol Operations On GATT Server";
-static bool verbose = false;
+#define TMPPATH "/tmp"
+
+static char hostName[25];
 
+static bool verbose = false;
+static int fd;
+static bdaddr_t src_addr;
+static struct server *server;
+static uint8_t network_id;
+static uint32_t xml_data_current_index;
 struct server {
 	int fd;
 	struct bt_att *att;
@@ -86,27 +102,109 @@
 
 	uint16_t gatt_svc_chngd_handle;
 	bool svc_chngd_enabled;
-
-	uint16_t hr_handle;
-	uint16_t hr_msrmt_handle;
-	uint16_t hr_energy_expended;
-	bool hr_visible;
-	bool hr_msrmt_enabled;
-	int hr_ee_count;
-	unsigned int hr_timeout_id;
+        uint16_t wifi_list_lentgth_char_handle;
+        bool wifi_scan_list_length_enabled;
+        uint8_t current_index;
+        uint16_t connection_status_notify_handle;
+        uint16_t connection_status_notify_enabled;
+        uint8_t wifi_config_security_value;
+        uint8_t wifi_config_ssid[22];
+        uint8_t wifi_config_passphrase[20];
+        uint8_t connection_status;
+        uint8_t device_config_status_notify_handle;
+        uint8_t device_config_status_notify_enabled;
+        uint8_t device_config_status;
+        uint8_t *wifi_device_config_xml_data;
+        uint32_t wifi_device_config_xml_data_length;
+        uint32_t wifi_device_config_checksum_value;
 };
+struct wifi_ap {
+	uint8_t ssid[22];
+        uint8_t bssid[17];
+        uint8_t channel;
+        uint8_t security_value;
+        uint8_t encrypt_value;
+};
+
+static struct wifi_ap Access_Point[26]; 
+
+static int l2cap_le_att_listen_and_accept(bdaddr_t *src, int sec,
+                                                        uint8_t src_type);
+static struct server *server_create(int fd, uint16_t mtu, bool hr_visible);
+static void server_destroy(struct server *server);
+void CfglockWait(void);
+void CfglockSignal(void);
 
 static void print_prompt(void)
 {
 	printf(COLOR_BLUE "[GATT server]" COLOR_OFF "# ");
 	fflush(stdout);
 }
-
+static void set_advertising_cmd(char *adv_data_cmd)
+{
+    uint8_t index, ch;
+    sprintf(adv_data_cmd, "hcitool -i hci0 cmd 0x08 0x0008 1F 02 01 18 03 03 0a 18 17 09");
+    printf("%s\n", adv_data_cmd);
+    for(index = 0; index < 22; index++)
+    {
+        if(index < strlen(hostName))
+        {
+            ch = hostName[index];
+            sprintf(adv_data_cmd, "%s %x", adv_data_cmd, ch);
+        }
+        else
+            sprintf(adv_data_cmd, "%s 00", adv_data_cmd);
+    }
+}
+static void advertise(void)
+{
+        int ret;
+        uint8_t adv_data_cmd[128];
+        set_advertising_cmd(adv_data_cmd);
+        ret = system("hciconfig hci0 leadv0");
+        ret = system(adv_data_cmd);
+}
+static void create_network_id(void)
+{
+	system("wpa_cli -i wlan0 add_network > networkID.txt");
+	FILE *file = fopen("networkID.txt", "r");
+	if (NULL == file)
+		PRLOG("networkID.txt file couldn't be opened\n");
+	else
+		network_id = fgetc(file);
+	fclose(file);
+	system("rm networkID.txt");
+}
+static void remove_network_id(void)
+{
+        uint8_t command[35];
+	sprintf(command, "wpa_cli -i wlan0 remove_network %c", network_id);
+	system(command);
+}
+static void refresh_network_id(void)
+{
+	remove_network_id();
+	sleep(1);
+	create_network_id();
+}
 static void att_disconnect_cb(int err, void *user_data)
 {
 	printf("Device disconnected: %s\n", strerror(err));
-
-	mainloop_quit();
+        system("rm /ltrx_user/device_cfg.xml"); 
+        advertise();
+        server_destroy(server);
+        free(server);
+        fd = l2cap_le_att_listen_and_accept(&src_addr, BT_SECURITY_LOW, BDADDR_LE_PUBLIC);
+        if (fd < 0) {
+                fprintf(stderr, "Failed to accept L2CAP ATT connection\n");
+                printf("Failed to accept L2CAP ATT connection\n");
+        }
+        server = server_create(fd, 23, false);
+        if (!server) {
+                close(fd);
+                printf("server couldn't be created\n");
+        }
+        printf("Server_Reinitiated\n");        
 }
 
 static void att_debug_cb(const char *str, void *user_data)
@@ -271,125 +369,1046 @@
 	gatt_db_attribute_write_result(attrib, id, ecode);
 }
 
-static void hr_msrmt_ccc_read_cb(struct gatt_db_attribute *attrib,
-					unsigned int id, uint16_t offset,
-					uint8_t opcode, struct bt_att *att,
-					void *user_data)
+static void start_scan(void)
 {
-	struct server *server = user_data;
-	uint8_t value[2];
+       int ret = system("wpa_cli -i wlan0 scan only_new=1");
+       sleep(5);
+       ret = system("wpa_cli -i wlan0 scan_results>wifi_list.txt"); 
+}
+static uint8_t populate_scan_list(void)
+{
+       FILE* file = fopen("wifi_list.txt", "r");
+       uint8_t line[256], *token, channel[4], loop;
+       uint8_t scan_list_length = 0, column, token_length;
+       uint8_t delimeter[2] = "\t";
+       if(!fgets(line, sizeof(line), file))
+	       goto done;
+
+       while (fgets(line, sizeof(line), file)) {
+              token = strtok(line, delimeter);
+              column = 1;
+	      if(scan_list_length>25) break;
+              while (token != NULL) {
+                     if(1 == column) memcpy(Access_Point[scan_list_length].bssid, token, 17); 
+                    
+                     else if(5 == column) 
+                     {
+                            memset(Access_Point[scan_list_length].ssid, 0, 22);
+                            token_length = strlen(token) - 1;
+                            if (token_length > 22)
+                            {
+                                  memcpy(Access_Point[scan_list_length].ssid, token, 22);
+                                  Access_Point[scan_list_length].ssid[21] = '\0';
+                            }
+                            else{ 
+                                  memcpy(Access_Point[scan_list_length].ssid, token, token_length);
+                                  Access_Point[scan_list_length].ssid[token_length] = '\0'; 
+                            }
+                     }
+                     else if(2 == column)
+                            Access_Point[scan_list_length].channel = (uint8_t) strtoul(&token[10], NULL, 10);
+                     else if(3 == column) Access_Point[scan_list_length].security_value = 2;
+                     else if(4 == column) Access_Point[scan_list_length].encrypt_value = 255;
+                     token = strtok(NULL, delimeter);
+                     column++;
+              }                     
+              scan_list_length++; 
+       }
+       printf("loop_exited\n");
+done:
+       fclose(file);
+       return scan_list_length; 
+}
 
-	value[0] = server->hr_msrmt_enabled ? 0x01 : 0x00;
-	value[1] = 0x00;
 
-	gatt_db_attribute_read_result(attrib, id, 0, value, 2);
+static void wifi_scan_list_length_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t error = 0;
+        size_t len = 0;
+        const uint8_t *value = NULL;
+        uint8_t scan_list_length = 20;
+
+        PRLOG("Wifi Scan List Length Read called\n");
+
+        len = 1;
+
+        if (offset > len) {
+                error = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
+
+        len -= offset;
+        start_scan(); 
+        scan_list_length = populate_scan_list();
+        value = len ? &scan_list_length : NULL;
+
+done:
+        gatt_db_attribute_read_result(attrib, id, error, value, len);
+}
+
+static void wifi_scan_list_length_ccc_write_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        const uint8_t *value, size_t len,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t ecode = 0;
+        uint8_t scan_list_length;
+
+        if (!value || len != 2) {
+                ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
+                gatt_db_attribute_write_result(attrib, id, ecode);
+                return;
+        }
+
+        if (offset) { 
+                ecode = BT_ATT_ERROR_INVALID_OFFSET;
+                gatt_db_attribute_write_result(attrib, id, ecode);
+                return;
+        }
+
+        if (value[0] == 0x00)
+                server->wifi_scan_list_length_enabled = false;
+        else if (value[0] == 0x01) {
+                if (!server->wifi_scan_list_length_enabled)
+                	server->wifi_scan_list_length_enabled = true;
+          
+                start_scan(); 
+                scan_list_length = populate_scan_list(); 
+        } else
+                ecode = 0x80;
+
+        PRLOG("Wifi Scan List length notification Enabled: %s\n",
+                                server->wifi_scan_list_length_enabled ? "true" : "false");
+        
+        gatt_db_attribute_write_result(attrib, id, ecode);
+        if(server->wifi_scan_list_length_enabled) bt_gatt_server_send_notification(server->gatt,
+                                                server->wifi_list_lentgth_char_handle,
+                                                &scan_list_length, 1);
+}
+
+static void wifi_scan_list_ccc_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t value[2];
+
+        value[0] = server->wifi_scan_list_length_enabled ? 0x01 : 0x00;
+        value[1] = 0x00;
+
+        gatt_db_attribute_read_result(attrib, id, 0, value, 2);
+}
+
+static void wifi_scan_current_index_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data; 
+        uint8_t error = 0;
+        size_t len = 0;
+        const uint8_t *value = NULL;
+
+        PRLOG("Current_index Read called\n");
+
+        len = 1;
+
+        if (offset > len) {
+                error = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
+
+        len -= offset;
+        value = len ? &server->current_index : NULL;
+
+done:
+        gatt_db_attribute_read_result(attrib, id, error, value, len);
+
 }
 
-static bool hr_msrmt_cb(void *user_data)
+static void wifi_scan_current_index_write_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        const uint8_t *value, size_t len,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t ecode = 0;
+        PRLOG("current_index write called wih value : %d\n", *value);
+        /*if (!value || len != 1) {
+                ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
+                goto done;
+        }
+
+        if (offset) {
+                ecode = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }*/
+     
+        server->current_index = *value;
+        PRLOG("current_index value after write : %d\n", server->current_index);
+        if(0xFF == server->current_index)
+        {
+               start_scan(); 
+               populate_scan_list();
+
+        }
+done:
+        gatt_db_attribute_write_result(attrib, id, ecode);
+}
+
+static void wifi_scan_ssid_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
 {
-	struct server *server = user_data;
-	bool expended_present = !(server->hr_ee_count % 10);
-	uint16_t len = 2;
-	uint8_t pdu[4];
-	uint32_t cur_ee;
+        struct server *server = user_data;
+        uint8_t error = 0;
+        size_t len = 0;
+        const uint8_t *value = NULL;
 
-	pdu[0] = 0x06;
-	pdu[1] = 90 + (rand() % 40);
+        PRLOG("Wifi Scan SSID Read called\n");
 
-	if (expended_present) {
-		pdu[0] |= 0x08;
-		put_le16(server->hr_energy_expended, pdu + 2);
-		len += 2;
-	}
+        len = strlen(Access_Point[server->current_index].ssid);
 
-	bt_gatt_server_send_notification(server->gatt,
-						server->hr_msrmt_handle,
-						pdu, len);
+        if (offset > len) {
+                error = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
 
+        len -= offset;
+        value = len ? &Access_Point[server->current_index].ssid[offset] : NULL;
 
-	cur_ee = server->hr_energy_expended;
-	server->hr_energy_expended = MIN(UINT16_MAX, cur_ee + 10);
-	server->hr_ee_count++;
+done:
+        gatt_db_attribute_read_result(attrib, id, error, value, len);
 
-	return true;
 }
 
-static void update_hr_msrmt_simulation(struct server *server)
+static void wifi_scan_bssid_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
 {
-	if (!server->hr_msrmt_enabled || !server->hr_visible) {
-		timeout_remove(server->hr_timeout_id);
-		return;
-	}
+        struct server *server = user_data;
+        uint8_t error = 0;
+        size_t len = 0;
+        const uint8_t *value = NULL;
+
+        PRLOG("Wifi Scan BSSID Read called\n");
+
+        len = 17;
+
+        if (offset > len) {
+                error = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
+
+        len -= offset;
+        value = len ? &Access_Point[server->current_index].bssid[offset] : NULL;
+
+done:
+        gatt_db_attribute_read_result(attrib, id, error, value, len);
 
-	server->hr_timeout_id = timeout_add(1000, hr_msrmt_cb, server, NULL);
 }
 
-static void hr_msrmt_ccc_write_cb(struct gatt_db_attribute *attrib,
-					unsigned int id, uint16_t offset,
-					const uint8_t *value, size_t len,
-					uint8_t opcode, struct bt_att *att,
-					void *user_data)
+static void wifi_scan_channel_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
 {
-	struct server *server = user_data;
-	uint8_t ecode = 0;
+        struct server *server = user_data;
+        uint8_t error = 0;
+        size_t len = 0;
+        const uint8_t *value = NULL;
 
-	if (!value || len != 2) {
-		ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
-		goto done;
-	}
+        PRLOG("Wifi Scan Channel Read called\n");
 
-	if (offset) {
-		ecode = BT_ATT_ERROR_INVALID_OFFSET;
-		goto done;
-	}
+        len = 1;
 
-	if (value[0] == 0x00)
-		server->hr_msrmt_enabled = false;
-	else if (value[0] == 0x01) {
-		if (server->hr_msrmt_enabled) {
-			PRLOG("HR Measurement Already Enabled\n");
-			goto done;
-		}
+        if (offset > len) {
+                error = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
 
-		server->hr_msrmt_enabled = true;
-	} else
-		ecode = 0x80;
+        len -= offset;
+        value = len ? &Access_Point[server->current_index].channel : NULL;
+
+done:
+        gatt_db_attribute_read_result(attrib, id, error, value, len);
+
+}
+
+static void wifi_scan_security_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t error = 0;
+        size_t len = 0;
+        const uint8_t *value = NULL;
 
-	PRLOG("HR: Measurement Enabled: %s\n",
-				server->hr_msrmt_enabled ? "true" : "false");
+        PRLOG("Wifi Scan Security Read called\n");
 
-	update_hr_msrmt_simulation(server);
+        len = 1;
+
+        if (offset > len) {
+                error = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
+
+        len -= offset;
+        value = len ? &Access_Point[server->current_index].security_value : NULL;
 
 done:
-	gatt_db_attribute_write_result(attrib, id, ecode);
+        gatt_db_attribute_read_result(attrib, id, error, value, len);
+
 }
 
-static void hr_control_point_write_cb(struct gatt_db_attribute *attrib,
-					unsigned int id, uint16_t offset,
-					const uint8_t *value, size_t len,
-					uint8_t opcode, struct bt_att *att,
-					void *user_data)
+static void wifi_scan_encryption_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
 {
-	struct server *server = user_data;
-	uint8_t ecode = 0;
+        struct server *server = user_data;
+        uint8_t error = 0;
+        size_t len = 0;
+        const uint8_t *value = NULL;
 
-	if (!value || len != 1) {
-		ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
-		goto done;
-	}
+        PRLOG("Wifi Scan Encryption Read called\n");
 
-	if (offset) {
-		ecode = BT_ATT_ERROR_INVALID_OFFSET;
+        len = 1;
+
+        if (offset > len) {
+                error = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
+
+        len -= offset;
+        value = len ? &Access_Point[server->current_index].encrypt_value : NULL;
+
+done:
+        gatt_db_attribute_read_result(attrib, id, error, value, len);
+
+}
+static bool check_connection_status(void)
+{
+	FILE *file;
+	uint8_t status[50];
+
+	PRLOG("executing ---> wpa_cli -i wlan0 status |grep -w ssid > connection_status.txt\n");
+	system("wpa_cli -i wlan0 status>/dev/null");
+        sleep(1);
+	system("wpa_cli -i wlan0 status>/dev/null");
+        sleep(1);
+	system("wpa_cli -i wlan0 status|grep -w ssid>connection_status.txt");
+
+	PRLOG("executing ---> cat connection.txt\n");
+	system("cat connection_status.txt");
+        file = fopen("connection_status.txt", "r");
+	if(NULL == file) 
+        {
+		PRLOG("connection_status.txt file not created\n");
 		goto done;
 	}
+        if(!fgets(status, sizeof(status), file))
+		goto done;
 
-	if (value[0] == 1) {
-		PRLOG("HR: Energy Expended value reset\n");
-		server->hr_energy_expended = 0;
+	status[strlen(status) - 1] = '\0';
+	PRLOG("connection status : %s server->wifi_config ssid : %s  %s\n", status, server->wifi_config_ssid, &status[5]);
+	if(!strcmp(&status[5], server->wifi_config_ssid))
+	{
+		fclose(file);
+		system("rm connection_status.txt");
+		return true;
 	}
 
 done:
-	gatt_db_attribute_write_result(attrib, id, ecode);
+	refresh_network_id();
+	fclose(file);
+	system("rm connection_status.txt");
+	return false;
+}
+static void connect_to_network(void)
+{
+	char command[100];
+	sprintf(command, "wpa_cli -i wlan0 set_network %c ssid '\"%s\"'", network_id, server->wifi_config_ssid);
+	PRLOG("Executing ---> %s\n", command);
+	system(command);
+        sprintf(command, "wpa_cli -i wlan0 set_network %c psk '\"%s\"'", network_id, server->wifi_config_passphrase);
+	PRLOG("Executing ---> %s\n", command);
+        system(command);
+	sprintf(command, "wpa_cli -i wlan0 enable_network %c", network_id);
+	PRLOG("Executing ---> %s\n", command);
+	system(command);
+	sleep(9);
+        	
+}
+static void wifi_config_connection_status_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t error = 0;
+        size_t len = 0;
+        const uint8_t *value = NULL;
+
+        PRLOG("Wifi Config Connection Status Read called\n");
+
+        len = 1;
+
+        if (offset > len) {
+                error = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
+
+        len -= offset;
+        value = len ? &server->connection_status : NULL;
+
+done:
+        gatt_db_attribute_read_result(attrib, id, error, value, len);
+
+}
+
+static void wifi_config_connetion_status_ccc_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t value[2];
+
+        value[0] = server->connection_status_notify_enabled ? 0x01 : 0x00;
+        value[1] = 0x00;
+
+        gatt_db_attribute_read_result(attrib, id, 0, value, 2);
+}
+
+static void wifi_config_connetion_status_ccc_write_cb(struct gatt_db_attribute *attrib,
+                                                      unsigned int id, uint16_t offset,
+                                                      const uint8_t *value, size_t len,
+                                                      uint8_t opcode, struct bt_att *att,
+                                                      void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t ecode = 0;
+
+        if (!value || len != 2) {
+                ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
+                gatt_db_attribute_write_result(attrib, id, ecode);
+                return;
+        }
+
+        if (offset) {
+                ecode = BT_ATT_ERROR_INVALID_OFFSET;
+                gatt_db_attribute_write_result(attrib, id, ecode);
+                return;
+        }
+
+        if (value[0] == 0x00)
+                server->connection_status_notify_enabled = false;
+        else if (value[0] == 0x01) {
+                if (!server->connection_status_notify_enabled)
+                	server->connection_status_notify_enabled = true;
+        } else
+                ecode = 0x80;
+
+        PRLOG("Wifi Config Connection Status Notification Enabled: %s\n",
+                                server->connection_status_notify_enabled ? "true" : "false");
+        gatt_db_attribute_write_result(attrib, id, ecode);
+}
+
+static void wifi_config_security_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t error = 0;
+        size_t len = 0;
+        const uint8_t *value = NULL;
+
+        PRLOG("Wifi Config Security Read called\n");
+
+        len = 1;
+
+        if (offset > len) {
+                error = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
+
+        len -= offset;
+        value = len ? &server->wifi_config_security_value : NULL;
+
+done:
+        gatt_db_attribute_read_result(attrib, id, error, value, len);
+}
+
+static void wifi_config_security_write_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        const uint8_t *value, size_t len,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t ecode = 0;
+        /*if (!value || len > 21) {
+                ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
+                goto done;
+        }
+
+        if (offset) {
+                ecode = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }*/
+
+        server->wifi_config_security_value = *value;
+        PRLOG("Wifi Config Securiy value after write : %d\n", server->wifi_config_security_value);
+
+done:
+        gatt_db_attribute_write_result(attrib, id, ecode);
+}
+
+static void wifi_config_ssid_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t error = 0;
+        size_t len = 0;
+        const uint8_t *value = NULL;
+
+        PRLOG("Wifi Config SSID Read called\n");
+
+        len = strlen(server->wifi_config_ssid);
+
+        if (offset > len) {
+                error = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
+
+        len -= offset;
+        value = len ? &server->wifi_config_ssid[offset] : NULL;
+
+done:
+        gatt_db_attribute_read_result(attrib, id, error, value, len);
+
+}
+
+static void wifi_config_ssid_write_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        const uint8_t *value, size_t len,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t ecode = 0;
+        if (!value || len > 21) {
+                ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
+                goto done;
+        }
+
+        if (offset) {
+                ecode = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
+        
+        strncpy(server->wifi_config_ssid, value, len);
+        server->wifi_config_ssid[len] = '\0';
+        PRLOG("Wifi Config SSID value after write : %s\n", server->wifi_config_ssid);
+
+done:
+        gatt_db_attribute_write_result(attrib, id, ecode);
+}
+
+static void wifi_config_passphrase_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t error = 0;
+        size_t len = 0;
+        const uint8_t *value = NULL;
+
+        PRLOG("Wifi Config Passphrase Read called\n");
+
+        len = strlen(server->wifi_config_passphrase);
+
+        if (offset > len) {
+                error = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
+
+        len -= offset;
+        value = len ? &server->wifi_config_passphrase[offset] : NULL;
+
+done:
+        gatt_db_attribute_read_result(attrib, id, error, value, len);
+
+}
+
+static void wifi_config_passphrase_write_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        const uint8_t *value, size_t len,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t ecode = 0;
+        if (!value || len > 19) {
+                ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
+                goto done;
+        }
+
+        if (offset) {
+                ecode = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
+
+        strncpy(server->wifi_config_passphrase, value, len);
+        server->wifi_config_passphrase[len] = '\0';
+        PRLOG("passphrase value after write : %s\n", server->wifi_config_passphrase);
+done:
+        gatt_db_attribute_write_result(attrib, id, ecode);
+	connect_to_network();
+	if(check_connection_status())
+	{	
+		PRLOG("Connected\n");
+                server->connection_status = 1;
+	}
+        else
+	{
+		PRLOG("Connection Failed\n");	
+                server->connection_status = 0;
+	}
+        if(server->connection_status_notify_enabled)  bt_gatt_server_send_notification(server->gatt,
+                                                server->connection_status_notify_handle,
+                                                &server->connection_status, 1);
+}
+
+static void wifi_device_config_status_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t error = 0;
+        size_t len = 0;
+        const uint8_t *value = NULL;
+
+        PRLOG("Wifi Device Config Status Read called\n");
+
+        len = 1;
+
+        if (offset > len) {
+                error = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
+
+        len -= offset;
+        value = len ? &server->device_config_status : NULL;
+
+done:
+        gatt_db_attribute_read_result(attrib, id, error, value, len);
+
+}
+
+static bool calculate_checksum(void)
+{
+    uint32_t index;
+    uint32_t calculated_checksum = 0;
+    PRLOG("Calculating Checksum\n");
+    for(index = 0; index < server->wifi_device_config_xml_data_length; index++)
+    {
+        calculated_checksum += server->wifi_device_config_xml_data[index];
+    }
+    calculated_checksum = ~calculated_checksum;
+    calculated_checksum &= 0xFF;
+    calculated_checksum += 1;
+    if(calculated_checksum != server->wifi_device_config_checksum_value)
+        return false;
+
+    return true;
+}
+static void generate_xml_config_file(void)
+{
+    FILE* file = fopen("/ltrx_user/device_cfg.xml", "w");
+    uint32_t index;
+    for(index = 0; index < server->wifi_device_config_xml_data_length; index++)
+    {
+        fputc(server->wifi_device_config_xml_data[index], file);
+    }
+    fclose(file);
+}
+void trim(char *ch)
+{
+    int count = 0;
+    while(*ch == ' ') { count = count + 1; ch++; }
+    while(*ch != '\0') { *(ch - count) = *ch; ch++;}
+    *(ch - count) = '\0';
+}
+static bool xml_import(void)
+{
+#if 0
+	int rc;
+        mpnipc_msg *msg;
+	ipc_xml_req *pXmlReq;
+	ipc_xml_reply *pXmlReply;
+        msg = malloc(sizeof(mpnipc_msg));
+
+        msg->msg_id = MPN_MSG_IMPORT_CFG;
+        msg->sender_id = MPN_ID_SDKUSER;
+        msg->msgbody_len = sizeof(ipc_xml_req);
+
+        pXmlReq = (ipc_xml_req *)msg->msgbody;
+        strncpy(pXmlReq->filePath, "device_cfg.xml", sizeof(pXmlReq->filePath) - 1);
+        strncpy(pXmlReq->user, "admin", sizeof(pXmlReq->user));	
+        pXmlReq->userFile = strncmp(pXmlReq->filePath, TMPPATH, strlen(TMPPATH)) ? 1 : 0;
+	CfglockWait();
+        rc = (
+            mpnipc_send_and_get_msg(NULL, msg, msg, MPN_DEST_EVO) == MPN_MSG_SUCCESS
+            && (msg->status_flags & MPN_MSG_ERROR_FLAG) == 0
+            );
+	CfglockSignal();
+	PRLOG("rc = %d\n", rc);
+        pXmlReply = (ipc_xml_reply *)msg->msgbody;
+        if(!rc)
+        {
+		if(*pXmlReply->errorMsg)
+                    PRLOG("XML import failed : %s", pXmlReply->errorMsg);
+                else 
+                    PRLOG("XML import failed\n");
+		free(msg);
+		return false;
+        }
+	else
+	{
+            if(*pXmlReply->errorMsg)
+                PRLOG("XML import successful : %s", pXmlReply->errorMsg);
+            else 
+                PRLOG("XML import successful\n");
+        }
+	free(msg);
+	return true;
+#endif
+        FILE *fp;
+        char status[100];
+        system("curl --anyauth -u admin:PASS http://localhost/import/config -X POST --form configrecord=@device_cfg.xml|grep \"<message>All XML configuration records have been imported.</message>\\|<message>ERROR: XML import failed.</message>\" > result");
+        fp = fopen("result", "r");
+        fgets(status, 100, fp);
+        fclose(fp);
+        PRLOG("xml status : %s\n", status);
+        system("rm result");
+        trim(status);
+        if(!memcmp(status, "<message>ERROR: XML import failed.</message>", 44)) return false;
+        if(!memcmp(status, "<message>All XML configuration records have been imported.</message>", 68)) return true;
+        return false;
+    
+}
+
+static void wifi_device_config_status_ccc_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t value[2];
+
+        value[0] = server->device_config_status_notify_enabled ? 0x01 : 0x00;
+        value[1] = 0x00;
+
+        gatt_db_attribute_read_result(attrib, id, 0, value, 2);
+}
+
+static void wifi_device_config_status_ccc_write_cb(struct gatt_db_attribute *attrib,
+                                                      unsigned int id, uint16_t offset,
+                                                      const uint8_t *value, size_t len,
+                                                      uint8_t opcode, struct bt_att *att,
+                                                      void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t ecode = 0;
+
+        if (!value || len != 2) {
+                ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
+                gatt_db_attribute_write_result(attrib, id, ecode);
+                return;
+        }
+
+        if (offset) { 
+                ecode = BT_ATT_ERROR_INVALID_OFFSET;
+                gatt_db_attribute_write_result(attrib, id, ecode);
+                return;
+        }
+
+        if (value[0] == 0x00)
+                server->device_config_status_notify_enabled = false;
+        else if (value[0] == 0x01) {
+                if (!server->device_config_status_notify_enabled)
+                        server->device_config_status_notify_enabled = true;
+        } else
+                ecode = 0x80;
+
+        PRLOG("Wifi Device Config Status Notification Enabled: %s\n",
+                                server->device_config_status_notify_enabled ? "true" : "false");
+        gatt_db_attribute_write_result(attrib, id, ecode);
+}
+void *process_xml_and_send_notification(void *data)
+{
+             if(calculate_checksum())
+             {
+                  PRLOG("Checksum Matched\n");
+                  generate_xml_config_file();
+                  if(xml_import())
+                  {
+                      PRLOG("Sending Xml Import Successful Notification\n");
+                      goto done;
+                  }
+                  else
+                  {
+                      server->device_config_status = 5;
+                      goto done;
+                  }
+             }
+             else
+             {
+                  server->device_config_status = 2;
+                  PRLOG("Checksum Mismatch\n");
+             }
+done:
+        xml_data_current_index = 0;
+        system("rm /ltrx_user/device_cfg.xml");
+        if(server->device_config_status_notify_enabled)  bt_gatt_server_send_notification(server->gatt,
+                                                server->device_config_status_notify_handle,
+                                                &server->device_config_status, 1);
+}
+static void wifi_device_config_xml_data_packet_write_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        const uint8_t *value, size_t len,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t ecode = 0;
+        server->device_config_status = 0;
+        pthread_t check_checksum_and_process_xml;
+        /*if (!value || len > 21) {
+                ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
+                goto done;
+        }
+
+        if (offset) {
+                ecode = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }*/
+        if(xml_data_current_index + len > server->wifi_device_config_xml_data_length)
+        {
+             server->device_config_status = 3;
+             if(server->device_config_status_notify_enabled)  bt_gatt_server_send_notification(server->gatt,
+                                                server->device_config_status_notify_handle,
+                                                &server->device_config_status, 1);
+        }
+        else {
+        strncpy(&server->wifi_device_config_xml_data[xml_data_current_index], value, len);
+        server->wifi_device_config_xml_data[xml_data_current_index + len] = '\0';
+        xml_data_current_index += len; 
+        PRLOG("Wifi Device Config Xml data packet value after write : %s\n", server->wifi_device_config_xml_data);
+        PRLOG("xml_data_current_index = %d server->wifi_device_config_xml_data_length = %d\n", xml_data_current_index, server->wifi_device_config_xml_data_length); 
+        gatt_db_attribute_write_result(attrib, id, ecode);
+        if(xml_data_current_index == server->wifi_device_config_xml_data_length)
+        {
+/*             if(calculate_checksum()) 
+             {
+		  PRLOG("Checksum Matched\n");
+                  generate_xml_config_file();
+		  if(xml_import())
+		  {   
+                      PRLOG("Sending Xml Import Successful Notification\n");
+		      goto done;
+		  }
+		  else
+                  {
+                      server->device_config_status = 5;
+		      goto done;
+		  }
+             }
+             else
+             {
+                  server->device_config_status = 2;
+	          PRLOG("Checksum Mismatch\n");
+	     }*/
+             if (!pthread_create(&check_checksum_and_process_xml, NULL, process_xml_and_send_notification, NULL)) {
+                 PRLOG("process_xml_and_send_notification Thread create successfully !!!\n");
+                 if ( ! pthread_detach(check_checksum_and_process_xml) )
+                     PRLOG("process_xml_and_send_notification Thread detached successfully !!!\n");
+                 else
+                     PRLOG("process_xml_and_send_notification Thread cannot be detached !!!\n");
+             } 
+             else {
+                     PRLOG("process_xml_and_send_notification Thread cannot be created !!!\n");
+             }             	  
+        }
+        else{
+        if(server->device_config_status_notify_enabled)  bt_gatt_server_send_notification(server->gatt,
+                                                server->device_config_status_notify_handle,
+                                                &server->device_config_status, 1);}}
+
+}
+
+static void wifi_device_config_xml_data_length_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t error = 0;
+        size_t len = 8;
+        const uint8_t *value = NULL;
+        uint8_t *xml_data_length_value = malloc(len * sizeof(uint8_t)); 
+
+        PRLOG("Wifi Device Config Xml data length Read called\n");
+
+        if (offset > len) {
+                error = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
+        
+        uint32_t flag = 0xFF;
+        uint8_t i;
+        for(i = 0; i < len; i++)
+        {
+             xml_data_length_value[i] = server->wifi_device_config_xml_data_length & flag;
+             flag <<= 8;
+        }
+
+        len -= offset;
+        value = len ? xml_data_length_value : NULL;
+
+done:
+        gatt_db_attribute_read_result(attrib, id, error, value, len);
+}
+
+static void wifi_device_config_xml_data_length_write_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        const uint8_t *value, size_t len,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t ecode = 0;
+        /*if (!value || len > 21) {
+                ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
+                goto done;
+        }
+
+        if (offset) {
+                ecode = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }*/
+        PRLOG("Device_config xml data length characteritsic write request value length = %d", len);
+        server->wifi_device_config_xml_data_length=0;       
+        uint8_t i;
+        for(i = len - 1; i > 0; i--)
+        {
+            server->wifi_device_config_xml_data_length = server->wifi_device_config_xml_data_length + value[i];
+            server->wifi_device_config_xml_data_length = server->wifi_device_config_xml_data_length << 8;
+            PRLOG("i = %d, server->wifi_device_config_xml_data_length = %x\n", i, server->wifi_device_config_xml_data_length);
+        }
+        server->wifi_device_config_xml_data_length = server->wifi_device_config_xml_data_length + value[i];
+        PRLOG("i = %d, server->wifi_device_config_xml_data_length = %x\n", i, server->wifi_device_config_xml_data_length);
+        if(server->wifi_device_config_xml_data != NULL)
+        {
+            free(server->wifi_device_config_xml_data);
+            server->wifi_device_config_xml_data = NULL;
+        }
+        xml_data_current_index = 0;
+        server->wifi_device_config_xml_data = malloc(sizeof(uint8_t) * (server->wifi_device_config_xml_data_length + 1));
+        PRLOG("Wifi Device Config xml data length value after write : %ld\n", server->wifi_device_config_xml_data_length);
+done:
+        gatt_db_attribute_write_result(attrib, id, ecode);
+        server->device_config_status = 0;
+        if(server->device_config_status_notify_enabled)  bt_gatt_server_send_notification(server->gatt,
+                                                server->device_config_status_notify_handle,
+                                                &server->device_config_status, 1);
+
+}
+
+static void wifi_device_config_checksum_read_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t error = 0;
+        size_t len = 8;
+        const uint8_t *value = NULL;
+        uint8_t *checksum_value = malloc(len * sizeof(uint8_t));
+
+        PRLOG("Wifi Device Config Checksum Read called\n");
+
+        if (offset > len) {
+                error = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }
+
+        uint32_t flag = 0xFF;
+        uint8_t i;
+        for(i = 0; i < len; i++)
+        {
+             checksum_value[i] = server->wifi_device_config_checksum_value & flag;
+             flag <<= 8;
+        }
+        len -= offset;        
+        value = len ? checksum_value : NULL;
+
+done:
+        gatt_db_attribute_read_result(attrib, id, error, value, len);
+}
+
+static void wifi_device_config_checksum_write_cb(struct gatt_db_attribute *attrib,
+                                        unsigned int id, uint16_t offset,
+                                        const uint8_t *value, size_t len,
+                                        uint8_t opcode, struct bt_att *att,
+                                        void *user_data)
+{
+        struct server *server = user_data;
+        uint8_t ecode = 0;
+        /*if (!value || len > 21) {
+                ecode = BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;
+                goto done;
+        }
+
+        if (offset) {
+                ecode = BT_ATT_ERROR_INVALID_OFFSET;
+                goto done;
+        }*/
+        server->wifi_device_config_checksum_value=0;
+        uint8_t i;
+        for(i = len - 1; i > 0; i--)
+        {
+            server->wifi_device_config_checksum_value = server->wifi_device_config_checksum_value + value[i];
+            server->wifi_device_config_checksum_value = server->wifi_device_config_checksum_value << 8;
+        }
+        server->wifi_device_config_checksum_value = server->wifi_device_config_checksum_value + value[i];
+
+        PRLOG("Wifi Device Config Checksum value after write : %d\n", server->wifi_device_config_checksum_value);
+
+done:
+        gatt_db_attribute_write_result(attrib, id, ecode);
+        server->device_config_status = 0;
+        if(server->device_config_status_notify_enabled)  bt_gatt_server_send_notification(server->gatt,
+                                                server->device_config_status_notify_handle,
+                                                &server->device_config_status, 1);
 }
 
 static void confirm_write(struct gatt_db_attribute *attr, int err,
@@ -450,6 +1469,11 @@
 							BT_ATT_OP_WRITE_REQ,
 							NULL, confirm_write,
 							NULL);
+       
+        server->name_len = strlen(hostName) + 1; 
+        server->device_name = malloc(server->name_len);
+        memcpy(server->device_name, hostName, server->name_len -1);
+        server->device_name[server->name_len -1] = '\0';
 
 	gatt_db_service_set_active(service, true);
 }
@@ -476,72 +1500,440 @@
 				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
 				gatt_svc_chngd_ccc_read_cb,
 				gatt_svc_chngd_ccc_write_cb, server);
-
+           
 	gatt_db_service_set_active(service, true);
 }
 
-static void populate_hr_service(struct server *server)
+static void populate_device_info_service(struct server *server)
 {
 	bt_uuid_t uuid;
-	struct gatt_db_attribute *service, *hr_msrmt, *body;
-	uint8_t body_loc = 1;  /* "Chest" */
-
-	/* Add Heart Rate Service */
-	bt_uuid16_create(&uuid, UUID_HEART_RATE);
-	service = gatt_db_add_service(server->db, &uuid, true, 8);
-	server->hr_handle = gatt_db_attribute_get_handle(service);
-
-	/* HR Measurement Characteristic */
-	bt_uuid16_create(&uuid, UUID_HEART_RATE_MSRMT);
-	hr_msrmt = gatt_db_service_add_characteristic(service, &uuid,
-						BT_ATT_PERM_NONE,
-						BT_GATT_CHRC_PROP_NOTIFY,
-						NULL, NULL, NULL);
-	server->hr_msrmt_handle = gatt_db_attribute_get_handle(hr_msrmt);
+        struct gatt_db_attribute *service, *dev_info_manu_name, *dev_info_model_num, *dev_info_serial_num, *dev_info_system_id;
+        uint8_t manu_name[] = "LANTRONIX";
+        uint8_t model_num[10];
+	uint8_t serial_num[25];
+        uint8_t system_id[] = { 0xbb, 0xb8, 0xa1, 0x80, 0x5f, 0x9f, 0x91, 0x71};   
+        //add device info service 
+        bt_uuid16_create(&uuid, UUID_DEVICE_INFO);
+        service = gatt_db_add_service(server->db, &uuid, true, 7);
+
+        //add manufacture name characteristic
+        bt_uuid16_create(&uuid, UUID_DEVICE_INFO_MANU_NAME);
+        dev_info_manu_name = gatt_db_service_add_characteristic(service, &uuid, 
+                                                                BT_ATT_PERM_READ,
+                                                                BT_GATT_CHRC_PROP_READ,
+                                                                NULL, NULL, server);
+
+        gatt_db_attribute_write(dev_info_manu_name, 0, (void *) manu_name, 9,
+                                                        BT_ATT_OP_WRITE_REQ,
+                                                        NULL, confirm_write,
+                                                        NULL);
+        //add model number characteristic
+        bt_uuid16_create(&uuid, UUID_DEVICE_INFO_MODEL_NUM);
+        dev_info_model_num = gatt_db_service_add_characteristic(service, &uuid,
+                                                                 BT_ATT_PERM_READ,
+                                                                 BT_GATT_CHRC_PROP_READ,
+                                                                 NULL, NULL, server);
+        int index = strcspn(hostName, "-");
+        strncpy(model_num, hostName, index);
+        
+        gatt_db_attribute_write(dev_info_model_num, 0, (void *) model_num, 8,
+                                                        BT_ATT_OP_WRITE_REQ,
+                                                        NULL, confirm_write,
+                                                        NULL);
+
+	//add serial number characteristic
+	bt_uuid16_create(&uuid, UUID_DEVICE_INFO_SERIAL_NUM);
+	dev_info_serial_num = gatt_db_service_add_characteristic(service, &uuid,
+			                                         BT_ATT_PERM_READ,
+								 BT_GATT_CHRC_PROP_READ,
+								 NULL, NULL, server);
 
-	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
-	gatt_db_service_add_descriptor(service, &uuid,
-					BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
-					hr_msrmt_ccc_read_cb,
-					hr_msrmt_ccc_write_cb, server);
+        strcpy(serial_num, hostName);
+	PRLOG("serial_num = %s\n", serial_num);
 
-	/*
-	 * Body Sensor Location Characteristic. Make reads obtain the value from
-	 * the database.
-	 */
-	bt_uuid16_create(&uuid, UUID_HEART_RATE_BODY);
-	body = gatt_db_service_add_characteristic(service, &uuid,
-						BT_ATT_PERM_READ,
-						BT_GATT_CHRC_PROP_READ,
-						NULL, NULL, server);
-	gatt_db_attribute_write(body, 0, (void *) &body_loc, sizeof(body_loc),
-							BT_ATT_OP_WRITE_REQ,
+        gatt_db_attribute_write(dev_info_serial_num, 0, (void *) serial_num, 20,
+			                                BT_ATT_OP_WRITE_REQ,
 							NULL, confirm_write,
 							NULL);
 
-	/* HR Control Point Characteristic */
-	bt_uuid16_create(&uuid, UUID_HEART_RATE_CTRL);
-	gatt_db_service_add_characteristic(service, &uuid,
-						BT_ATT_PERM_WRITE,
-						BT_GATT_CHRC_PROP_WRITE,
-						NULL, hr_control_point_write_cb,
-						server);
+        //add system ID characteristic
+        bt_uuid16_create(&uuid, UUID_DEVICE_INFO_SYSTEM_ID);
+        dev_info_system_id = gatt_db_service_add_characteristic(service, &uuid,
+                                                                 BT_ATT_PERM_READ,
+                                                                 BT_GATT_CHRC_PROP_READ,
+                                                                 NULL, NULL, server);
+
+        gatt_db_attribute_write(dev_info_system_id, 0, (void *) system_id, 8,
+                                                        BT_ATT_OP_WRITE_REQ,
+                                                        NULL, confirm_write,
+                                                        NULL);
+        gatt_db_service_set_active(service, true);
+}
+
+
+static void populate_wifi_scan_service_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_scan_service_uuid_data[] = {0x1C, 0xDE, 0xB3, 0x08, 0xC1, 0x81, 0x11, 0xE6, 0xA4, 0xA6, 0xCE, 0xC0, 0xC9 ,0x32 ,0xCE, 0x01};    
+    
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_scan_service_uuid_data[loop], 1);    
+}
+static void populate_wifi_scan_list_length_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_list_length_uuid_data[] = {0x1A, 0x60, 0x09, 0xA0, 0xDD, 0x66, 0x49, 0xBB, 0xBB, 0x07, 0x12, 0xC6, 0xB3 ,0xA0 ,0xE6, 0x9E};
 
-	if (server->hr_visible)
-		gatt_db_service_set_active(service, true);
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_list_length_uuid_data[loop], 1);
 }
 
+static void populate_wifi_scan_current_index_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_scan_current_index_uuid_data[] = {0x6B, 0xB1, 0xCF, 0xDF, 0xC9, 0xEB, 0x4A, 0x44, 0x9A, 0x4D, 0xF9, 0xBC, 0xC6 ,0xC0 ,0x24, 0x43};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_scan_current_index_uuid_data[loop], 1);
+}
+
+static void populate_wifi_scan_ssid_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_scan_ssid_uuid_data[] = {0x9B, 0xC7, 0xF4, 0x39, 0xD7, 0xAE, 0x4A, 0x56, 0x99, 0x47, 0x3A, 0xFF, 0x54 ,0x2D ,0x5B, 0x0B};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_scan_ssid_uuid_data[loop], 1);
+}
+       
+static void populate_wifi_scan_bssid_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_scan_bssid_uuid_data[] = {0x2C, 0x46, 0x1C, 0x73, 0xC6, 0x87, 0x4E, 0x99, 0x82, 0x2B, 0x47, 0x61, 0x27 ,0x60 ,0x59, 0x33};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_scan_bssid_uuid_data[loop], 1);
+}
+
+static void populate_wifi_scan_channel_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_scan_channel_uuid_data[] = {0x98, 0xC7, 0xB0, 0xA6, 0x6C, 0xEE, 0x49, 0x44, 0xA3, 0x05, 0x86, 0x16, 0x81 ,0xDF ,0xC8, 0x9A};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_scan_channel_uuid_data[loop], 1);
+}
+
+static void populate_wifi_scan_security_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_scan_security_uuid_data[] = {0x78, 0x6E, 0x88, 0x70, 0x34, 0xF4, 0x4B, 0x3B, 0xA5, 0x77, 0x37, 0xD1, 0xDC ,0x5A ,0x58, 0x73};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_scan_security_uuid_data[loop], 1);
+}
+
+static void populate_wifi_scan_encryption_uuid( uint8_t *des)
+{
+    uint8_t loop; 
+    uint8_t wifi_scan_encryption_uuid_data[] = {0x26, 0x0C, 0xC5, 0x8E, 0xDF, 0xA9, 0x44, 0x5F, 0xA8, 0x89, 0xD8, 0xD2, 0x2C ,0x88 ,0x72, 0x39};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_scan_encryption_uuid_data[loop], 1);
+}
+
+static void populate_wifi_scan_service(struct server *server)
+{
+        bt_uuid_t uuid;
+        struct gatt_db_attribute *service, *wifi_scan_list_len;
+        uint128_t wifi_scan_128_uuid;
+        
+        /* Add Wifi Scan Service */
+        populate_wifi_scan_service_uuid(wifi_scan_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_scan_128_uuid);
+        service = gatt_db_add_service(server->db, &uuid, true, 16);
+
+        /* Wifi Scan List Length Characteristic */
+        populate_wifi_scan_list_length_uuid(wifi_scan_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_scan_128_uuid);
+        wifi_scan_list_len = gatt_db_service_add_characteristic(service, &uuid,
+                                                BT_ATT_PERM_READ,
+                                                BT_GATT_CHRC_PROP_READ | BT_GATT_CHRC_PROP_NOTIFY,
+                                                wifi_scan_list_length_read_cb, NULL, NULL);
+        if(!wifi_scan_list_len) printf("failed adding characterictic");
+        server->wifi_list_lentgth_char_handle = gatt_db_attribute_get_handle(wifi_scan_list_len);
+
+        bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
+        gatt_db_service_add_descriptor(service, &uuid,
+                                        BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
+                                        wifi_scan_list_ccc_read_cb,
+                                        wifi_scan_list_length_ccc_write_cb, server);
+                 
+        /* Current Index Characteristic */
+        populate_wifi_scan_current_index_uuid(wifi_scan_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_scan_128_uuid);
+        gatt_db_service_add_characteristic(service, &uuid,
+                                           BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
+                                           BT_GATT_CHRC_PROP_READ | BT_GATT_CHRC_PROP_WRITE,
+                                           wifi_scan_current_index_read_cb, wifi_scan_current_index_write_cb, server);
+
+        /* SSID Characteristic */
+        populate_wifi_scan_ssid_uuid(wifi_scan_128_uuid.data);        
+        bt_uuid128_create(&uuid, wifi_scan_128_uuid);
+        gatt_db_service_add_characteristic(service, &uuid,
+                                           BT_ATT_PERM_READ,
+                                           BT_GATT_CHRC_PROP_READ,
+                                           wifi_scan_ssid_read_cb, NULL, server);
+
+        /* BSSID Characterictic */
+        populate_wifi_scan_bssid_uuid(wifi_scan_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_scan_128_uuid);
+        gatt_db_service_add_characteristic(service, &uuid,
+                                           BT_ATT_PERM_READ,
+                                           BT_GATT_CHRC_PROP_READ,
+                                           wifi_scan_bssid_read_cb, NULL, server);
+
+        /* Channel Characteristic */
+        populate_wifi_scan_channel_uuid(wifi_scan_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_scan_128_uuid);
+        gatt_db_service_add_characteristic(service, &uuid,
+                                           BT_ATT_PERM_READ,
+                                           BT_GATT_CHRC_PROP_READ,
+                                           wifi_scan_channel_read_cb, NULL, server);
+         
+        /* Security Characteristic */
+        populate_wifi_scan_security_uuid(wifi_scan_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_scan_128_uuid);
+        gatt_db_service_add_characteristic(service, &uuid,
+                                           BT_ATT_PERM_READ,
+                                           BT_GATT_CHRC_PROP_READ,
+                                           wifi_scan_security_read_cb, NULL, server);
+
+        /* Encryption Characteristic */
+        populate_wifi_scan_encryption_uuid(wifi_scan_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_scan_128_uuid);
+        gatt_db_service_add_characteristic(service, &uuid,
+                                           BT_ATT_PERM_READ,
+                                           BT_GATT_CHRC_PROP_READ,
+                                           wifi_scan_encryption_read_cb, NULL, server);
+          
+        server->current_index = 0; 
+        server->wifi_scan_list_length_enabled = false;
+        gatt_db_service_set_active(service, true);        
+}
+static void populate_wifi_config_service_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_config_service_uuid_data[] = {0x1B, 0x7E, 0x82, 0x51, 0x28, 0x77, 0x41, 0xC3, 0xB4, 0x6E, 0xCF, 0x05, 0x7C ,0x56 ,0x20, 0x23};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_config_service_uuid_data[loop], 1);
+}
+static void populate_wifi_config_connection_status_notify_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_config_connection_status_notify_uuid_data[] = {0x8A, 0xC3, 0x2D, 0x3F, 0x5C, 0xB9, 0x4D, 0x44, 0xBE, 0xC2, 0xEE, 0x68, 0x91 ,0x69 ,0xF6, 0x26};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_config_connection_status_notify_uuid_data[loop], 1);
+}
+static void populate_wifi_config_security_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_config_security_uuid_data[] = {0xCA, 0xC2, 0xAB, 0xA4, 0xED, 0xBB, 0x4C, 0x4A, 0xBB, 0xAF, 0x0A, 0x84, 0xA5 ,0xCD ,0x93, 0xA1};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_config_security_uuid_data[loop], 1);
+}
+static void populate_wifi_config_ssid_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_config_ssid_uuid_data[] = {0xAC, 0xA0, 0xEF, 0x7C, 0xEE, 0xAA, 0x48, 0xAD, 0x95, 0x08, 0x19, 0xA6, 0xCE ,0xF6 ,0xB3, 0x56};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_config_ssid_uuid_data[loop], 1);
+}
+
+static void populate_wifi_config_passphrase_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_config_passphrase_uuid_data[] = {0x40, 0xB7, 0xDE, 0x33, 0x93, 0xE4, 0x4C, 0x8B, 0xA8, 0x76, 0xD8, 0x33, 0xB4 ,0x15 ,0xA6, 0xCE};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_config_passphrase_uuid_data[loop], 1);
+}
+static void populate_wifi_config_service(struct server *server)
+{
+        bt_uuid_t uuid;
+        struct gatt_db_attribute *service, *connection_status_notify_handle;
+        uint128_t wifi_config_128_uuid;
+
+        /* Add Wifi Config Service */
+        populate_wifi_config_service_uuid(wifi_config_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_config_128_uuid);
+        service = gatt_db_add_service(server->db, &uuid, true, 10);
+
+        /* Wifi Connection Status Notification Characteristic */
+        populate_wifi_config_connection_status_notify_uuid(wifi_config_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_config_128_uuid);
+        connection_status_notify_handle = gatt_db_service_add_characteristic(service, &uuid,
+                                                BT_ATT_PERM_READ,
+                                                BT_GATT_CHRC_PROP_READ | BT_GATT_CHRC_PROP_NOTIFY,
+                                                wifi_config_connection_status_read_cb, NULL, NULL);
+  
+        server->connection_status_notify_handle = gatt_db_attribute_get_handle(connection_status_notify_handle);
+
+        bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
+        gatt_db_service_add_descriptor(service, &uuid,
+                                        BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
+                                        wifi_config_connetion_status_ccc_read_cb,
+                                        wifi_config_connetion_status_ccc_write_cb, server);
+
+        /* Security Characteristic */
+        populate_wifi_config_security_uuid(wifi_config_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_config_128_uuid);
+        gatt_db_service_add_characteristic(service, &uuid,
+                                           BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
+                                           BT_GATT_CHRC_PROP_READ | BT_GATT_CHRC_PROP_WRITE,
+                                           wifi_config_security_read_cb, wifi_config_security_write_cb, server);
+
+        /* SSID Characteristic */
+        populate_wifi_config_ssid_uuid(wifi_config_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_config_128_uuid);
+        gatt_db_service_add_characteristic(service, &uuid,
+                                           BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
+                                           BT_GATT_CHRC_PROP_READ | BT_GATT_CHRC_PROP_WRITE,
+                                           wifi_config_ssid_read_cb, wifi_config_ssid_write_cb, server);
+
+        /* Passphrase Characteristic */
+        populate_wifi_config_passphrase_uuid(wifi_config_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_config_128_uuid);
+        gatt_db_service_add_characteristic(service, &uuid,
+                                           BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
+                                           BT_GATT_CHRC_PROP_READ | BT_GATT_CHRC_PROP_WRITE,
+                                           wifi_config_passphrase_read_cb, wifi_config_passphrase_write_cb, server);
+
+        server->connection_status = 0;
+	server->connection_status_notify_enabled = false;
+        gatt_db_service_set_active(service, true);
+
+}
+static void populate_wifi_device_config_service_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_device_config_service_uuid_data[] = {0xF0, 0xDD, 0x79, 0x9C, 0xC8, 0x83, 0x49, 0x76, 0x96, 0xA5, 0x8B, 0xB4, 0x90 ,0x7F ,0x41, 0xD6};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_device_config_service_uuid_data[loop], 1);
+}
+static void populate_wifi_device_config_status_notify_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_device_config_status_notify_uuid_data[] = {0x3B, 0xC6, 0x3A, 0xDD, 0x3B, 0x52, 0x4A, 0x3F, 0xBE, 0x47, 0xA0, 0x48, 0xBC ,0xA2 ,0x48, 0xBF};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_device_config_status_notify_uuid_data[loop], 1);
+}
+
+static void populate_wifi_device_config_xml_data_packet_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_device_config_xml_data_packet_uuid_data[] = {0x24, 0xFD, 0x0A, 0x4F, 0x68, 0x09, 0x44, 0xAB, 0x95, 0x96, 0x52, 0x3D, 0xB9 ,0xEB ,0xCD, 0x47};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_device_config_xml_data_packet_uuid_data[loop], 1);
+}
+
+static void populate_wifi_device_config_xml_data_packet_length_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_device_config_xml_data_packet_length_uuid_data[] = {0x60, 0x65, 0x68, 0x16, 0x87, 0xBE, 0x4C, 0xD0, 0x9C, 0xA7, 0xE8, 0xB8, 0x10 ,0xE1 ,0xEC, 0x23};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_device_config_xml_data_packet_length_uuid_data[loop], 1);
+}
+
+static void populate_wifi_device_config_checksum_uuid( uint8_t *des)
+{
+    uint8_t loop;
+    uint8_t wifi_device_config_checksum_uuid_data[] = {0x0B, 0x8E, 0x5A, 0x44, 0x33, 0x71, 0x4D, 0x0C, 0xB3, 0x8B, 0x56, 0xC1, 0xE0 ,0x34 ,0x48, 0xF6};
+
+    for(loop = 0; loop <= 15; loop++)
+          memcpy(&des[loop], &wifi_device_config_checksum_uuid_data[loop], 1);
+}
+ 
+static void populate_wifi_device_config_service(struct server *server)
+{
+        bt_uuid_t uuid;
+        struct gatt_db_attribute *service, *device_config_status_notify_handle;
+        uint128_t wifi_device_config_128_uuid;
+
+        /* Add Wifi Device Config Service */
+        populate_wifi_device_config_service_uuid(wifi_device_config_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_device_config_128_uuid);
+        service = gatt_db_add_service(server->db, &uuid, true, 10);
+
+        /* Wifi Device Configuration Status Notification Characteristic */
+        populate_wifi_device_config_status_notify_uuid(wifi_device_config_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_device_config_128_uuid);
+        device_config_status_notify_handle = gatt_db_service_add_characteristic(service, &uuid,
+                                                BT_ATT_PERM_READ,
+                                                BT_GATT_CHRC_PROP_READ | BT_GATT_CHRC_PROP_NOTIFY,
+                                                wifi_device_config_status_read_cb, NULL, server);
+
+        server->device_config_status_notify_handle = gatt_db_attribute_get_handle(device_config_status_notify_handle);
+
+        bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
+        gatt_db_service_add_descriptor(service, &uuid,
+                                        BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
+                                        wifi_device_config_status_ccc_read_cb,
+                                        wifi_device_config_status_ccc_write_cb, server);
+         
+        /* Wifi Device Config XML Data Packet Characteristics */
+        populate_wifi_device_config_xml_data_packet_uuid(wifi_device_config_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_device_config_128_uuid);
+        gatt_db_service_add_characteristic(service, &uuid,
+                                           BT_ATT_PERM_WRITE,
+                                           BT_GATT_CHRC_PROP_WRITE,
+                                           NULL, wifi_device_config_xml_data_packet_write_cb, server);
+
+        /* Wifi Device Config XML Data Packet Length Characteristics */
+        populate_wifi_device_config_xml_data_packet_length_uuid(wifi_device_config_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_device_config_128_uuid);        
+        gatt_db_service_add_characteristic(service, &uuid,
+                                           BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
+                                           BT_GATT_CHRC_PROP_READ | BT_GATT_CHRC_PROP_WRITE,
+                                           wifi_device_config_xml_data_length_read_cb, wifi_device_config_xml_data_length_write_cb, server);
+
+        /* Wifi Device Config Checksum Characteristics */
+        populate_wifi_device_config_checksum_uuid(wifi_device_config_128_uuid.data);
+        bt_uuid128_create(&uuid, wifi_device_config_128_uuid);
+        gatt_db_service_add_characteristic(service, &uuid,
+                                           BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
+                                           BT_GATT_CHRC_PROP_READ | BT_GATT_CHRC_PROP_WRITE,
+                                           wifi_device_config_checksum_read_cb, wifi_device_config_checksum_write_cb, server);
+
+        server->device_config_status = 0;
+        server->wifi_device_config_xml_data_length = 0;
+        server->wifi_device_config_xml_data = NULL;
+        server->wifi_device_config_checksum_value = 0;
+        server->device_config_status_notify_enabled = false;
+        gatt_db_service_set_active(service, true);
+
+}        
 static void populate_db(struct server *server)
 {
 	populate_gap_service(server);
 	populate_gatt_service(server);
-	populate_hr_service(server);
+        populate_device_info_service(server);
+        populate_wifi_scan_service(server);
+        populate_wifi_config_service(server);
+        populate_wifi_device_config_service(server);
 }
 
 static struct server *server_create(int fd, uint16_t mtu, bool hr_visible)
 {
 	struct server *server;
-	size_t name_len = strlen(test_device_name);
 
 	server = new0(struct server, 1);
 	if (!server) {
@@ -565,17 +1957,6 @@
 		fprintf(stderr, "Failed to set ATT disconnect handler\n");
 		goto fail;
 	}
-
-	server->name_len = name_len + 1;
-	server->device_name = malloc(name_len + 1);
-	if (!server->device_name) {
-		fprintf(stderr, "Failed to allocate memory for device name\n");
-		goto fail;
-	}
-
-	memcpy(server->device_name, test_device_name, name_len);
-	server->device_name[name_len] = '\0';
-
 	server->fd = fd;
 	server->db = gatt_db_new();
 	if (!server->db) {
@@ -589,7 +1970,6 @@
 		goto fail;
 	}
 
-	server->hr_visible = hr_visible;
 
 	if (verbose) {
 		bt_att_set_debug(server->att, att_debug_cb, "att: ", NULL);
@@ -597,9 +1977,6 @@
 							"server: ", NULL);
 	}
 
-	/* Random seed for generating fake Heart Rate measurements */
-	srand(time(NULL));
-
 	/* bt_gatt_server already holds a reference */
 	populate_db(server);
 
@@ -607,7 +1984,6 @@
 
 fail:
 	gatt_db_unref(server->db);
-	free(server->device_name);
 	bt_att_unref(server->att);
 	free(server);
 
@@ -616,7 +1992,6 @@
 
 static void server_destroy(struct server *server)
 {
-	timeout_remove(server->hr_timeout_id);
 	bt_gatt_server_unref(server->gatt);
 	gatt_db_unref(server->db);
 }
@@ -628,23 +2003,16 @@
 
 	printf("Options:\n"
 		"\t-i, --index <id>\t\tSpecify adapter index, e.g. hci0\n"
-		"\t-m, --mtu <mtu>\t\t\tThe ATT MTU to use\n"
-		"\t-s, --security-level <sec>\tSet security level (low|"
-								"medium|high)\n"
-		"\t-t, --type [random|public] \t The source address type\n"
 		"\t-v, --verbose\t\t\tEnable extra logging\n"
-		"\t-r, --heart-rate\t\tEnable Heart Rate service\n"
-		"\t-h, --help\t\t\tDisplay help\n");
+		"\t-h, --help\t\t\tDisplay help\n"
+                "\t-b, --bdadress\t\t\tSets the serial number of the device\n");
 }
 
 static struct option main_options[] = {
 	{ "index",		1, 0, 'i' },
-	{ "mtu",		1, 0, 'm' },
-	{ "security-level",	1, 0, 's' },
-	{ "type",		1, 0, 't' },
 	{ "verbose",		0, 0, 'v' },
-	{ "heart-rate",		0, 0, 'r' },
 	{ "help",		0, 0, 'h' },
+        { "bdaddress",          1, 0, 'b' },
 	{ }
 };
 
@@ -710,414 +2078,6 @@
 	return -1;
 }
 
-static void notify_usage(void)
-{
-	printf("Usage: notify [options] <value_handle> <value>\n"
-					"Options:\n"
-					"\t -i, --indicate\tSend indication\n"
-					"e.g.:\n"
-					"\tnotify 0x0001 00 01 00\n");
-}
-
-static struct option notify_options[] = {
-	{ "indicate",	0, 0, 'i' },
-	{ }
-};
-
-static bool parse_args(char *str, int expected_argc,  char **argv, int *argc)
-{
-	char **ap;
-
-	for (ap = argv; (*ap = strsep(&str, " \t")) != NULL;) {
-		if (**ap == '\0')
-			continue;
-
-		(*argc)++;
-		ap++;
-
-		if (*argc > expected_argc)
-			return false;
-	}
-
-	return true;
-}
-
-static void conf_cb(void *user_data)
-{
-	PRLOG("Received confirmation\n");
-}
-
-static void cmd_notify(struct server *server, char *cmd_str)
-{
-	int opt, i;
-	char *argvbuf[516];
-	char **argv = argvbuf;
-	int argc = 1;
-	uint16_t handle;
-	char *endptr = NULL;
-	int length;
-	uint8_t *value = NULL;
-	bool indicate = false;
-
-	if (!parse_args(cmd_str, 514, argv + 1, &argc)) {
-		printf("Too many arguments\n");
-		notify_usage();
-		return;
-	}
-
-	optind = 0;
-	argv[0] = "notify";
-	while ((opt = getopt_long(argc, argv, "+i", notify_options,
-								NULL)) != -1) {
-		switch (opt) {
-		case 'i':
-			indicate = true;
-			break;
-		default:
-			notify_usage();
-			return;
-		}
-	}
-
-	argc -= optind;
-	argv += optind;
-
-	if (argc < 1) {
-		notify_usage();
-		return;
-	}
-
-	handle = strtol(argv[0], &endptr, 16);
-	if (!endptr || *endptr != '\0' || !handle) {
-		printf("Invalid handle: %s\n", argv[0]);
-		return;
-	}
-
-	length = argc - 1;
-
-	if (length > 0) {
-		if (length > UINT16_MAX) {
-			printf("Value too long\n");
-			return;
-		}
-
-		value = malloc(length);
-		if (!value) {
-			printf("Failed to construct value\n");
-			return;
-		}
-
-		for (i = 1; i < argc; i++) {
-			if (strlen(argv[i]) != 2) {
-				printf("Invalid value byte: %s\n",
-								argv[i]);
-				goto done;
-			}
-
-			value[i-1] = strtol(argv[i], &endptr, 16);
-			if (endptr == argv[i] || *endptr != '\0'
-							|| errno == ERANGE) {
-				printf("Invalid value byte: %s\n",
-								argv[i]);
-				goto done;
-			}
-		}
-	}
-
-	if (indicate) {
-		if (!bt_gatt_server_send_indication(server->gatt, handle,
-							value, length,
-							conf_cb, NULL, NULL))
-			printf("Failed to initiate indication\n");
-	} else if (!bt_gatt_server_send_notification(server->gatt, handle,
-								value, length))
-		printf("Failed to initiate notification\n");
-
-done:
-	free(value);
-}
-
-static void heart_rate_usage(void)
-{
-	printf("Usage: heart-rate on|off\n");
-}
-
-static void cmd_heart_rate(struct server *server, char *cmd_str)
-{
-	bool enable;
-	uint8_t pdu[4];
-	struct gatt_db_attribute *attr;
-
-	if (!cmd_str) {
-		heart_rate_usage();
-		return;
-	}
-
-	if (strcmp(cmd_str, "on") == 0)
-		enable = true;
-	else if (strcmp(cmd_str, "off") == 0)
-		enable = false;
-	else {
-		heart_rate_usage();
-		return;
-	}
-
-	if (enable == server->hr_visible) {
-		printf("Heart Rate Service already %s\n",
-						enable ? "visible" : "hidden");
-		return;
-	}
-
-	server->hr_visible = enable;
-	attr = gatt_db_get_attribute(server->db, server->hr_handle);
-	gatt_db_service_set_active(attr, server->hr_visible);
-	update_hr_msrmt_simulation(server);
-
-	if (!server->svc_chngd_enabled)
-		return;
-
-	put_le16(server->hr_handle, pdu);
-	put_le16(server->hr_handle + 7, pdu + 2);
-
-	server->hr_msrmt_enabled = false;
-	update_hr_msrmt_simulation(server);
-
-	bt_gatt_server_send_indication(server->gatt,
-						server->gatt_svc_chngd_handle,
-						pdu, 4, conf_cb, NULL, NULL);
-}
-
-static void print_uuid(const bt_uuid_t *uuid)
-{
-	char uuid_str[MAX_LEN_UUID_STR];
-	bt_uuid_t uuid128;
-
-	bt_uuid_to_uuid128(uuid, &uuid128);
-	bt_uuid_to_string(&uuid128, uuid_str, sizeof(uuid_str));
-
-	printf("%s\n", uuid_str);
-}
-
-static void print_incl(struct gatt_db_attribute *attr, void *user_data)
-{
-	struct server *server = user_data;
-	uint16_t handle, start, end;
-	struct gatt_db_attribute *service;
-	bt_uuid_t uuid;
-
-	if (!gatt_db_attribute_get_incl_data(attr, &handle, &start, &end))
-		return;
-
-	service = gatt_db_get_attribute(server->db, start);
-	if (!service)
-		return;
-
-	gatt_db_attribute_get_service_uuid(service, &uuid);
-
-	printf("\t  " COLOR_GREEN "include" COLOR_OFF " - handle: "
-					"0x%04x, - start: 0x%04x, end: 0x%04x,"
-					"uuid: ", handle, start, end);
-	print_uuid(&uuid);
-}
-
-static void print_desc(struct gatt_db_attribute *attr, void *user_data)
-{
-	printf("\t\t  " COLOR_MAGENTA "descr" COLOR_OFF
-					" - handle: 0x%04x, uuid: ",
-					gatt_db_attribute_get_handle(attr));
-	print_uuid(gatt_db_attribute_get_type(attr));
-}
-
-static void print_chrc(struct gatt_db_attribute *attr, void *user_data)
-{
-	uint16_t handle, value_handle;
-	uint8_t properties;
-	uint16_t ext_prop;
-	bt_uuid_t uuid;
-
-	if (!gatt_db_attribute_get_char_data(attr, &handle,
-								&value_handle,
-								&properties,
-								&ext_prop,
-								&uuid))
-		return;
-
-	printf("\t  " COLOR_YELLOW "charac" COLOR_OFF
-				" - start: 0x%04x, value: 0x%04x, "
-				"props: 0x%02x, ext_prop: 0x%04x, uuid: ",
-				handle, value_handle, properties, ext_prop);
-	print_uuid(&uuid);
-
-	gatt_db_service_foreach_desc(attr, print_desc, NULL);
-}
-
-static void print_service(struct gatt_db_attribute *attr, void *user_data)
-{
-	struct server *server = user_data;
-	uint16_t start, end;
-	bool primary;
-	bt_uuid_t uuid;
-
-	if (!gatt_db_attribute_get_service_data(attr, &start, &end, &primary,
-									&uuid))
-		return;
-
-	printf(COLOR_RED "service" COLOR_OFF " - start: 0x%04x, "
-				"end: 0x%04x, type: %s, uuid: ",
-				start, end, primary ? "primary" : "secondary");
-	print_uuid(&uuid);
-
-	gatt_db_service_foreach_incl(attr, print_incl, server);
-	gatt_db_service_foreach_char(attr, print_chrc, NULL);
-
-	printf("\n");
-}
-
-static void cmd_services(struct server *server, char *cmd_str)
-{
-	gatt_db_foreach_service(server->db, NULL, print_service, server);
-}
-
-static bool convert_sign_key(char *optarg, uint8_t key[16])
-{
-	int i;
-
-	if (strlen(optarg) != 32) {
-		printf("sign-key length is invalid\n");
-		return false;
-	}
-
-	for (i = 0; i < 16; i++) {
-		if (sscanf(optarg + (i * 2), "%2hhx", &key[i]) != 1)
-			return false;
-	}
-
-	return true;
-}
-
-static void set_sign_key_usage(void)
-{
-	printf("Usage: set-sign-key [options]\nOptions:\n"
-		"\t -c, --sign-key <remote csrk>\tRemote CSRK\n"
-		"e.g.:\n"
-		"\tset-sign-key -c D8515948451FEA320DC05A2E88308188\n");
-}
-
-static bool remote_counter(uint32_t *sign_cnt, void *user_data)
-{
-	static uint32_t cnt = 0;
-
-	if (*sign_cnt < cnt)
-		return false;
-
-	cnt = *sign_cnt;
-
-	return true;
-}
-
-static void cmd_set_sign_key(struct server *server, char *cmd_str)
-{
-	char *argv[3];
-	int argc = 0;
-	uint8_t key[16];
-
-	memset(key, 0, 16);
-
-	if (!parse_args(cmd_str, 2, argv, &argc)) {
-		set_sign_key_usage();
-		return;
-	}
-
-	if (argc != 2) {
-		set_sign_key_usage();
-		return;
-	}
-
-	if (!strcmp(argv[0], "-c") || !strcmp(argv[0], "--sign-key")) {
-		if (convert_sign_key(argv[1], key))
-			bt_att_set_remote_key(server->att, key, remote_counter,
-									server);
-	} else
-		set_sign_key_usage();
-}
-
-static void cmd_help(struct server *server, char *cmd_str);
-
-typedef void (*command_func_t)(struct server *server, char *cmd_str);
-
-static struct {
-	char *cmd;
-	command_func_t func;
-	char *doc;
-} command[] = {
-	{ "help", cmd_help, "\tDisplay help message" },
-	{ "notify", cmd_notify, "\tSend handle-value notification" },
-	{ "heart-rate", cmd_heart_rate, "\tHide/Unhide Heart Rate Service" },
-	{ "services", cmd_services, "\tEnumerate all services" },
-	{ "set-sign-key", cmd_set_sign_key,
-			"\tSet remote signing key for signed write command"},
-	{ }
-};
-
-static void cmd_help(struct server *server, char *cmd_str)
-{
-	int i;
-
-	printf("Commands:\n");
-	for (i = 0; command[i].cmd; i++)
-		printf("\t%-15s\t%s\n", command[i].cmd, command[i].doc);
-}
-
-static void prompt_read_cb(int fd, uint32_t events, void *user_data)
-{
-	ssize_t read;
-	size_t len = 0;
-	char *line = NULL;
-	char *cmd = NULL, *args;
-	struct server *server = user_data;
-	int i;
-
-	if (events & (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) {
-		mainloop_quit();
-		return;
-	}
-
-	read = getline(&line, &len, stdin);
-	if (read < 0)
-		return;
-
-	if (read <= 1) {
-		cmd_help(server, NULL);
-		print_prompt();
-		return;
-	}
-
-	line[read-1] = '\0';
-	args = line;
-
-	while ((cmd = strsep(&args, " \t")))
-		if (*cmd != '\0')
-			break;
-
-	if (!cmd)
-		goto failed;
-
-	for (i = 0; command[i].cmd; i++) {
-		if (strcmp(command[i].cmd, cmd) == 0)
-			break;
-	}
-
-	if (command[i].cmd)
-		command[i].func(server, args);
-	else
-		fprintf(stderr, "Unknown command: %s\n", line);
-
-failed:
-	print_prompt();
-
-	free(line);
-}
-
 static void signal_cb(int signum, void *user_data)
 {
 	switch (signum) {
@@ -1129,21 +2089,44 @@
 		break;
 	}
 }
-
+static void getHostName(char *device_info)
+{
+        FILE *fp;
+        system("hostname > hostname");
+        fp = fopen("hostname", "r");
+        fscanf(fp, "%s", hostName);
+        fclose(fp);
+        char *ch = hostName;
+        char serial_no[13];
+        int i;
+        while(*ch != '\0')
+        {
+             if(*ch == '-')
+             {
+                 *ch = '\0';
+                 break;
+             }
+             ch++;
+        }
+        strcat(hostName, "-");
+        for(i = 0; i < 12; i++)
+            serial_no[i] = device_info[i + 14];
+        serial_no[12] = '\0';
+        strcat(hostName, serial_no);
+        system("rm hostname");
+}
 int main(int argc, char *argv[])
 {
 	int opt;
-	bdaddr_t src_addr;
 	int dev_id = -1;
-	int fd;
 	int sec = BT_SECURITY_LOW;
 	uint8_t src_type = BDADDR_LE_PUBLIC;
 	uint16_t mtu = 0;
+        char device_info[29];
 	sigset_t mask;
-	bool hr_visible = false;
-	struct server *server;
-
-	while ((opt = getopt_long(argc, argv, "+hvrs:t:m:i:",
+	FILE *fp;
+   
+	while ((opt = getopt_long(argc, argv, "+hvrs:t:m:i:b",
 						main_options, NULL)) != -1) {
 		switch (opt) {
 		case 'h':
@@ -1152,57 +2135,17 @@
 		case 'v':
 			verbose = true;
 			break;
-		case 'r':
-			hr_visible = true;
-			break;
-		case 's':
-			if (strcmp(optarg, "low") == 0)
-				sec = BT_SECURITY_LOW;
-			else if (strcmp(optarg, "medium") == 0)
-				sec = BT_SECURITY_MEDIUM;
-			else if (strcmp(optarg, "high") == 0)
-				sec = BT_SECURITY_HIGH;
-			else {
-				fprintf(stderr, "Invalid security level\n");
-				return EXIT_FAILURE;
-			}
-			break;
-		case 't':
-			if (strcmp(optarg, "random") == 0)
-				src_type = BDADDR_LE_RANDOM;
-			else if (strcmp(optarg, "public") == 0)
-				src_type = BDADDR_LE_PUBLIC;
-			else {
-				fprintf(stderr,
-					"Allowed types: random, public\n");
-				return EXIT_FAILURE;
-			}
-			break;
-		case 'm': {
-			int arg;
-
-			arg = atoi(optarg);
-			if (arg <= 0) {
-				fprintf(stderr, "Invalid MTU: %d\n", arg);
-				return EXIT_FAILURE;
-			}
-
-			if (arg > UINT16_MAX) {
-				fprintf(stderr, "MTU too large: %d\n", arg);
-				return EXIT_FAILURE;
-			}
-
-			mtu = (uint16_t) arg;
-			break;
-		}
 		case 'i':
 			dev_id = hci_devid(optarg);
 			if (dev_id < 0) {
 				perror("Invalid adapter");
 				return EXIT_FAILURE;
 			}
-
 			break;
+                case 'b':
+                        optind = 3;
+                        strcpy(device_info, argv[2]);
+                        break;
 		default:
 			fprintf(stderr, "Invalid option: %c\n", opt);
 			return EXIT_FAILURE;
@@ -1224,32 +2167,25 @@
 		perror("Adapter not available");
 		return EXIT_FAILURE;
 	}
+        getHostName(device_info);
+        PRLOG("HostName = %s\n", hostName);
+
+        advertise();
 
 	fd = l2cap_le_att_listen_and_accept(&src_addr, sec, src_type);
 	if (fd < 0) {
 		fprintf(stderr, "Failed to accept L2CAP ATT connection\n");
 		return EXIT_FAILURE;
 	}
-
+        //create_network_id();
 	mainloop_init();
 
-	server = server_create(fd, mtu, hr_visible);
+	server = server_create(fd, 23, 0);
 	if (!server) {
 		close(fd);
 		return EXIT_FAILURE;
 	}
-
-	if (mainloop_add_fd(fileno(stdin),
-				EPOLLIN | EPOLLRDHUP | EPOLLHUP | EPOLLERR,
-				prompt_read_cb, server, NULL) < 0) {
-		fprintf(stderr, "Failed to initialize console\n");
-		server_destroy(server);
-
-		return EXIT_FAILURE;
-	}
-
 	printf("Running GATT server\n");
-
 	sigemptyset(&mask);
 	sigaddset(&mask, SIGINT);
 	sigaddset(&mask, SIGTERM);
@@ -1261,8 +2197,10 @@
 	mainloop_run();
 
 	printf("\n\nShutting down...\n");
-
+        
 	server_destroy(server);
 
+	system("rm wifi_list.txt");
+        //free(hostName);
 	return EXIT_SUCCESS;
 }
diff -ruN --new-file bluez_utils-5.43/tools/hcitool.c bluez_utils-5.43_mod_2/tools/hcitool.c
--- bluez_utils-5.43/tools/hcitool.c	2017-06-14 18:25:33.855679802 +0530
+++ bluez_utils-5.43_mod_2/tools/hcitool.c	2019-08-29 14:37:08.548540553 +0530
@@ -2411,7 +2411,7 @@
 	struct hci_filter nf, of;
 	struct sigaction sa;
 	socklen_t olen;
-	int len;
+	int len, num_of_scanned_devices = 0;
 
 	olen = sizeof(of);
 	if (getsockopt(dd, SOL_HCI, HCI_FILTER, &of, &olen) < 0) {
@@ -2439,7 +2439,7 @@
 		char addr[18];
 
 		while ((len = read(dd, buf, sizeof(buf))) < 0) {
-			if (errno == EINTR && signal_received == SIGINT) {
+			if ((errno == EINTR && signal_received == SIGINT) || num_of_scanned_devices > 400) {
 				len = 0;
 				goto done;
 			}
@@ -2461,15 +2461,20 @@
 		info = (le_advertising_info *) (meta->data + 1);
 		if (check_report_filter(filter_type, info)) {
 			char name[30];
-
+                        num_of_scanned_devices++;
 			memset(name, 0, sizeof(name));
 
 			ba2str(&info->bdaddr, addr);
 			eir_parse_name(info->data, info->length,
 							name, sizeof(name) - 1);
-
-			printf("%s %s\n", addr, name);
+                        if (info->bdaddr_type == LE_PUBLIC_ADDRESS) 
+			   printf("%s\t%s\t\t(public address)\n", addr, name);
+                        else if (info->bdaddr_type == LE_RANDOM_ADDRESS)
+                            printf("%s\t%s\t\t(random address)\n", addr, name);
+                        else 
+                            printf("%s\t%s\t\t(Unknown address type)\n", addr, name);
 		}
+                if(num_of_scanned_devices > 400) break;
 	}
 
 done:
diff -ruN --new-file bluez_utils-5.43/tools/rfcomm.c bluez_utils-5.43_mod_2/tools/rfcomm.c
--- bluez_utils-5.43/tools/rfcomm.c	2017-06-14 18:25:33.855679802 +0530
+++ bluez_utils-5.43_mod_2/tools/rfcomm.c	2019-05-08 17:37:12.933653355 +0530
@@ -434,6 +434,9 @@
 	socklen_t alen;
 	char dst[18], devname[MAXPATHLEN];
 	int sk, nsk, fd, lm, try = 30;
+	char pid[10] = {};
+	char cmd [30] = {};
+	FILE *fp = NULL;
 
 	laddr.rc_family = AF_BLUETOOTH;
 	bacpy(&laddr.rc_bdaddr, bdaddr);
@@ -538,6 +541,7 @@
 	ba2str(&req.dst, dst);
 	printf("Connection from %s to %s\n", dst, devname);
 	printf("Press CTRL-C for hangup\n");
+	system("logger -s SPP Connected\n");
 
 	memset(&sa, 0, sizeof(sa));
 	sa.sa_flags   = SA_NOCLDSTOP;
@@ -576,6 +580,18 @@
 	sigaction(SIGINT,  &sa, NULL);
 
 	printf("Disconnected\n");
+	system("logger -s SPP Disconnected\n");
+
+	if( access( "/tmp/ser_cli_4.pid", F_OK ) != -1 ) {
+		fp = fopen("/tmp/ser_cli_4.pid", "r");
+		fscanf(fp, "%s" , pid);
+		sprintf(cmd, "kill -9 %s", pid);
+		system(cmd);
+		fclose(fp); 
+	} else {
+		/* file doesn't exist */
+		system("File doesn't exist\n");
+	}
 
 	close(fd);
 	return;
