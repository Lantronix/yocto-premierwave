diff --git a/sysklogd/klogd.c b/sysklogd/klogd.c
index df0edee..d4bd46e 100644
--- a/sysklogd/klogd.c
+++ b/sysklogd/klogd.c
@@ -59,7 +59,7 @@
 #include "libbb.h"
 #include "common_bufsiz.h"
 #include <syslog.h>
-
+#include <unistd.h>
 
 /* The Linux-specific klogctl(3) interface does not rely on the filesystem and
  * allows us to change the console loglevel. Alternatively, we read the
@@ -228,6 +228,9 @@ int klogd_main(int argc UNUSED_PARAM, char **argv)
 	/* We want klogd_read to not be restarted, thus _norestart: */
 	bb_signals_norestart(BB_FATAL_SIGS, record_signo);
 
+        //LTRX:
+        sleep(4);  /* wait for syslogd up and running */
+
 	syslog(LOG_NOTICE, "klogd started: %s", bb_banner);
 
 	write_pidfile_std_path_and_ext("klogd");
diff --git a/sysklogd/syslogd.c b/sysklogd/syslogd.c
index 6ddfd77..8031a2e 100644
--- a/sysklogd/syslogd.c
+++ b/sysklogd/syslogd.c
@@ -176,6 +176,9 @@
 
 #if ENABLE_FEATURE_REMOTE_LOG
 #include <netinet/in.h>
+/* LTRX: 10/14/2011 Added following includes for res_init() support */
+#include <arpa/nameser.h>
+#include <resolv.h>
 #endif
 
 #if ENABLE_FEATURE_IPC_SYSLOG
@@ -184,6 +187,7 @@
 #include <sys/shm.h>
 #endif
 
+#define DEFAULT_LOG_FILE_PATH "/var/log/messages" /* LTRX: created define for default log file path */
 
 #define DEBUG 0
 
@@ -197,7 +201,7 @@
 
 enum {
 	MAX_READ = CONFIG_FEATURE_SYSLOGD_READ_BUFFER_SIZE,
-	DNS_WAIT_SEC = 2 * 60,
+        DNS_WAIT_SEC = 60, /* LTRX: 10/14/2011 Changed DNS_WAIT_SECS to 60 from 120. */
 };
 
 /* Semaphore operation structures */
@@ -291,7 +295,7 @@ struct globals {
 
 static const struct init_globals init_data = {
 	.logFile = {
-		.path = "/var/log/messages",
+                .path = DEFAULT_LOG_FILE_PATH,  /* LTRX: used define instead of string constant */
 		.fd = -1,
 	},
 #ifdef SYSLOGD_MARK
@@ -349,6 +353,17 @@ enum {
 	OPT_cfg         = IF_FEATURE_SYSLOGD_CFG(   (1 << OPTBIT_cfg        )) + 0,
 	OPT_kmsg        = IF_FEATURE_KMSG_SYSLOG(   (1 << OPTBIT_kmsg       )) + 0,
 };
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#define SHM_SIZE 1024  /* make it a 1K shared memory segment */
+static uint32_t remote_send_success;
+static uint32_t remote_send_failed;
+
 #define OPTION_STR "m:nO:l:St" \
 	IF_FEATURE_ROTATE_LOGFILE("s:" ) \
 	IF_FEATURE_ROTATE_LOGFILE("b:" ) \
@@ -709,6 +724,7 @@ static void log_locally(time_t now, char *msg, logFile_t *log_file)
 		if (log_file->last_log_time != now) {
 			log_file->last_log_time = now;
 			close(log_file->fd);
+                        log_file->fd = -1; /*LTRX: sets log fd to -1 if closed.*/
 			goto reopen;
 		}
 	}
@@ -787,6 +803,7 @@ static void log_locally(time_t now, char *msg, logFile_t *log_file)
 		fcntl(log_file->fd, F_SETLKW, &fl);
 #endif
 		close(log_file->fd);
+                log_file->fd = -1; /*LTRX: sets log fd to -1 if closed.*/
 		goto reopen;
 	}
 /* TODO: what to do on write errors ("disk full")? */
@@ -864,11 +881,11 @@ static void timestamp_and_log(int pri, char *msg, int len)
 	}
 
 	if (option_mask32 & OPT_small)
-		sprintf(G.printbuf, "%s %s\n", timestamp, msg);
+                sprintf(G.printbuf, "%s %s\r\n", timestamp, msg); /*LTRX: Append carriage return and newline to syslog entries.*/
 	else {
 		char res[20];
 		parse_fac_prio_20(pri, res);
-		sprintf(G.printbuf, "%s %.64s %s %s\n", timestamp, G.hostname, res, msg);
+                sprintf(G.printbuf, "%s %.64s %s %s\r\n", timestamp, G.hostname, res, msg); /*LTRX: Append carriage return and newline to syslog entries.*/
 	}
 
 	/* Log message locally (to file or shared mem) */
@@ -893,7 +910,20 @@ static void timestamp_and_log(int pri, char *msg, int len)
 #if ENABLE_FEATURE_IPC_SYSLOG
 		if ((option_mask32 & OPT_circularlog) && G.shbuf) {
 			log_to_shmem(G.printbuf);
-			return;
+                /*
+                    !!!!
+                    LTRX: If local or serial line logging is enabled, we want to keep
+                          going instead of returning right away. We can determine if
+                          one of these log methods is enabled by checking to see if
+                          the log file name global has changed from its default value.
+                          This is a bit of a kludge, though it is much simpler than
+                          modifying syslogd to take an additional command line option.
+                    !!!!
+                */
+                    if (! strcmp(G.logFile.path, DEFAULT_LOG_FILE_PATH))
+                    {
+                        return;
+                    }
 		}
 #endif
 		log_locally(now, G.printbuf, &G.logFile);
@@ -994,6 +1024,8 @@ static int try_to_resolve_remote(remoteHost_t *rh)
 		if ((now - rh->last_dns_resolve) < DNS_WAIT_SEC)
 			return -1;
 		rh->last_dns_resolve = now;
+                /* LTRX: 10/14/2011: reload DNS configuration with res_init() prior to host2sockaddr() */
+                res_init();
 		rh->remoteAddr = host2sockaddr(rh->remoteHostname, 514);
 		if (!rh->remoteAddr)
 			return -1;
@@ -1002,12 +1034,38 @@ static int try_to_resolve_remote(remoteHost_t *rh)
 }
 #endif
 
+static void syslog_sighandler(int signo)
+{
+       if (G.logFile.fd >= 0) {
+               close(G.logFile.fd);
+       }
+       record_signo(signo);
+}
+
 static void do_syslogd(void) NORETURN;
 static void do_syslogd(void)
 {
 #if ENABLE_FEATURE_REMOTE_LOG
 	llist_t *item;
+        int pri = (LOG_USER | LOG_NOTICE);
 #endif
+        key_t key;
+        int shmid;
+        int mode;
+        char * shm_data=NULL;
+        if ((key = ftok("/sbin/syslogd", 'R')) != -1) {
+                if ((shmid = shmget(key, SHM_SIZE, 0644 | IPC_CREAT)) != -1) {
+                        shm_data = shmat(shmid, (void *)0, 0);
+                        if (shm_data == (char *)(-1)) {
+                                shm_data = NULL;
+                        }
+                }
+        }
+        if(shm_data!=NULL)
+        {
+                snprintf(shm_data, SHM_SIZE, "%d:%d", 0, 0);/*initialize*/
+        }
+
 #if ENABLE_FEATURE_SYSLOGD_DUP
 	int last_sz = -1;
 	char *last_buf;
@@ -1017,8 +1075,9 @@ static void do_syslogd(void)
 #endif
 
 	/* Set up signal handlers (so that they interrupt read()) */
-	signal_no_SA_RESTART_empty_mask(SIGTERM, record_signo);
-	signal_no_SA_RESTART_empty_mask(SIGINT, record_signo);
+        signal_no_SA_RESTART_empty_mask(SIGTERM, syslog_sighandler);/*LTRX: To close open file handle in termination signal handler.*/
+        signal_no_SA_RESTART_empty_mask(SIGINT, syslog_sighandler);
+
 	//signal_no_SA_RESTART_empty_mask(SIGQUIT, record_signo);
 	signal(SIGHUP, SIG_IGN);
 #ifdef SYSLOGD_MARK
@@ -1089,27 +1148,73 @@ static void do_syslogd(void)
 				rh->remoteFD = try_to_resolve_remote(rh);
 				if (rh->remoteFD == -1)
 					continue;
+                                int local_port = 0;//any
+                                char* port = getenv("SYSLOGD_LOCALPORT");
+                                if(port)
+                                {
+                                    local_port = atoi(port);
+                                    struct sockaddr_in local;
+                                    local.sin_family = AF_INET;
+                                    local.sin_port = htons(local_port);
+                                    local.sin_addr.s_addr = htonl(INADDR_ANY);
+                                    xbind(rh->remoteFD, (struct sockaddr *) &local, sizeof(local));
+                                }
 			}
+                        // LTRX: check severity code with configured log level
+                        {
+                          char *endbuf = recvbuf + sz;
+                          char *p = recvbuf;
+
+                          while (p < endbuf)
+                            {
+                              if (*p == '<') {
+                                /* Parse the magic priority number */
+                                pri = bb_strtou(p + 1, &p, 10);
+                                if (*p == '>')
+                                  p++;
+                                if (pri & ~(LOG_FACMASK | LOG_PRIMASK))
+                                  pri = (LOG_USER | LOG_NOTICE);
+                                break;
+                              }
+                              else
+                                p++;
+                            }
+                        }
 
 			/* Send message to remote logger.
 			 * On some errors, close and set remoteFD to -1
 			 * so that DNS resolution is retried.
 			 */
-			if (sendto(rh->remoteFD, recvbuf, sz+1,
-					MSG_DONTWAIT | MSG_NOSIGNAL,
-					&(rh->remoteAddr->u.sa), rh->remoteAddr->len) == -1
-			) {
-				switch (errno) {
-				case ECONNRESET:
-				case ENOTCONN: /* paranoia */
-				case EPIPE:
-					close(rh->remoteFD);
-					rh->remoteFD = -1;
-					free(rh->remoteAddr);
-					rh->remoteAddr = NULL;
-				}
-			}
-		}
+                        if (LOG_PRI(pri) < G.logLevel)
+                        {
+                            if (sendto(rh->remoteFD, recvbuf, sz+1,
+                                MSG_DONTWAIT | MSG_NOSIGNAL,
+                                &(rh->remoteAddr->u.sa), rh->remoteAddr->len) == -1
+                            )
+                            {
+                                //failed
+                                remote_send_failed++;
+                                switch (errno) {
+
+                                    case ECONNRESET:
+                                    case ENOTCONN: /* paranoia */
+                                    case EPIPE:
+                                    close(rh->remoteFD);
+                                    rh->remoteFD = -1;
+                                      free(rh->remoteAddr);
+                                    rh->remoteAddr = NULL;
+                                }
+                            }
+                            else
+                            {
+                                //success
+                                remote_send_success++;
+                            }
+                            if (shm_data != NULL) {
+                                snprintf(shm_data, SHM_SIZE, "%d:%d", remote_send_success, remote_send_failed);
+                            }
+                        }
+                }
 #endif
 		if (!ENABLE_FEATURE_REMOTE_LOG || (option_mask32 & OPT_locallog)) {
 			recvbuf[sz] = '\0'; /* ensure it *is* NUL terminated */
@@ -1118,6 +1223,10 @@ static void do_syslogd(void)
 	} /* while (!bb_got_signal) */
 
 	timestamp_and_log_internal("syslogd exiting");
+        if (shmdt(shm_data) == -1) {
+
+        }
+
 	remove_pidfile_std_path_and_ext("syslogd");
 	ipcsyslog_cleanup();
 	if (option_mask32 & OPT_kmsg)
